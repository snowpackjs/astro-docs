---
import chroma from 'chroma-js';
import { escape, unescape } from 'html-escaper';
import rangeParser from 'parse-numeric-range';

export interface Props {
	lang?: string;
	title?: string;
	highlightedLines?: string;
	highlightedExpressions?: string;
}

const { lang = '', title = '', highlightedLines = '', highlightedExpressions = '' } = Astro.props as Props;

const isTerminal = ['shellscript', 'shell', 'bash', 'sh', 'zsh'].includes(lang);

// Generate HTML code from the title (if any), improving the ability to wrap long file paths
// into multiple lines by inserting a line break opportunity after each slash
const titleHtml = escape(title).replace(/([\\/])/g, '$1<wbr/>');

// Render the default slot, which contains the syntax-highlighted code in HTML format
// as processed by Astro's Shiki integration
let codeSnippetHtml = await Astro.slots.render('default');

codeSnippetHtml = applyMarking(codeSnippetHtml, highlightedLines, highlightedExpressions);

function applyMarking(highlightedCodeHtml: string, markedLines: string, markedExpressions: string) {
	const arrMarkedLines = rangeParser(markedLines || '');
	const markedRegExp = markedExpressions ? new RegExp(unescape(markedExpressions), 'gd') : undefined;

	if (!arrMarkedLines.length && !markedRegExp) return highlightedCodeHtml;

	const lines = highlightedCodeHtml.trim().split(/\r?\n/);
	const lineRegExp = /^((?:<pre.*?><code.*?>)?<span class=")(line.*?)(".*?>)(.*)(<\/span>(?:<\/code><\/pre>)?)$/;

	lines.forEach((line, i) => {
		lines[i] = line.replace(lineRegExp, (_, beforeLineClass, lineClass, afterLineClass, tokensHtml, afterTokens) => {
			const classes = new Set(lineClass.split(' '));

			// Apply line marking
			let isLineMarked = false;
			if (arrMarkedLines.includes(i + 1)) {
				classes.add('mark');
				isLineMarked = true;
			}
			lineClass = [...classes].join(' ');

			// Apply inline marking
			tokensHtml = applyInlineMarking(tokensHtml, markedRegExp, isLineMarked);

			return `${beforeLineClass}${lineClass}${afterLineClass}${tokensHtml}${afterTokens}`;
		});
	});

	return lines.join('\n');
}

type SyntaxToken = {
	tokenType: 'syntax';
	color: string;
	innerHtml: string;
	text: string;
	textStart: number;
	textEnd: number;
};

type MarkerToken = {
	tokenType: 'marker';
	markerType: 'mark' | 'ins' | 'del';
	closing?: boolean;
};

type InlineToken = MarkerToken | SyntaxToken;

type InsertionPoint = {
	tokenIndex: number;
	innerHtmlOffset: number;
};

function applyInlineMarking(lineHtml: string, markedRegExp: RegExp | undefined, isLineMarked: boolean) {
	// Split line into inline tokens
	const tokenMatches = lineHtml.matchAll(/<span style="color: (#[0-9A-Fa-f]+)">(.*?)<\/span>/g);
	const tokens: InlineToken[] = [];
	let textLine = '';
	for (const tokenMatch of tokenMatches) {
		const [, color, innerHtml] = tokenMatch;
		const text = unescape(innerHtml);
		tokens.push({
			tokenType: 'syntax',
			color,
			innerHtml,
			text,
			textStart: textLine.length,
			textEnd: textLine.length + text.length,
		});
		textLine += text;
	}

	// If a regular expression for inline marking was given, search and mark matches
	if (markedRegExp) {
		// console.log('RegExp: ' + JSON.stringify({ lineHtml, markedRegExp: markedRegExp.toString() }, null, 2));
		const markerRanges: {
			start: InsertionPoint;
			end: InsertionPoint;
		}[] = [];
		const markerMatches = textLine.matchAll(markedRegExp);
		for (const markerMatch of markerMatches) {
			// Read the start and end ranges from the `indices` property,
			// which is made available through the RegExp flag `d`
			// (and unfortunately not recognized by TypeScript)
			let indices = (markerMatch as any).indices as ([start: number, end: number] | null)[];
			// If accessing the group indices is unsupported, use the full match as fallback
			if (!indices || !indices.length) {
				const fullMatchIndex = markerMatch.index as number;
				indices = [[fullMatchIndex, fullMatchIndex + markerMatch[0].length]];
			}
			// If there are multiple non-null indices, remove the first one
			// as it is the full match and we only want to mark capture groups
			indices = indices.filter((range) => range);
			if (indices.length > 1) {
				indices.shift();
			}
			// Merge overlapping ranges
			const distinctRanges = union(indices as [number, number][]);

			distinctRanges.forEach((range) => {
				if (!range) return;
				markerRanges.push({
					start: textPositionToTokenPosition(tokens, range[0]),
					end: textPositionToTokenPosition(tokens, range[1]),
				});
			});
		}

		// If matches were found, mutate inline tokens in reverse direction (from end to start),
		// inserting opening and closing marker tokens at the correct positions,
		// optionally splitting syntax tokens if they only match partially
		if (markerRanges.length) {
			markerRanges.reverse().forEach((markerRange) => {
				const markerToken: MarkerToken = {
					tokenType: 'marker',
					markerType: 'mark',
				};

				insertMarkerTokenAtPosition(tokens, markerRange.end, { ...markerToken, closing: true });
				insertMarkerTokenAtPosition(tokens, markerRange.start, markerToken);
			});
		}
	}

	// Ensure proper color contrast of syntax tokens inside marked ranges
	const markerColor = chroma('#2e336b');
	let inInlineMarker = false;
	tokens.forEach((token) => {
		if (token.tokenType === 'marker') {
			inInlineMarker = !token.closing;
			return;
		}
		if (inInlineMarker || isLineMarked) {
			const tokenColor = chroma(token.color);
			const fixedTokenColor = ensureMinContrast(tokenColor, markerColor, 6);
			token.color = fixedTokenColor.hex();
		}
	});

	return tokens.map(renderToken).join('');
}

function union(intervals: [number, number][]): [number, number][] {
	if (!intervals.length) {
		return [];
	}
	intervals = intervals.sort((a, b) => a[0] - b[0]);
	const result: [number, number][] = [];
	let [start, end] = intervals[0];
	for (let i = 1, n = intervals.length; i < n; i++) {
		const [nextStart, nextEnd] = intervals[i];
		if (end < nextStart) {
			result.push([start, end]);
			start = nextStart;
		}
		if (end < nextEnd) {
			end = nextEnd;
		}
	}
	return [...result, [start, end]];
}

function ensureMinContrast(textColor: chroma.Color, backgroundColor: chroma.Color, minContrast: number): chroma.Color {
	const oldContrast = chroma.contrast(textColor, backgroundColor);
	if (oldContrast >= minContrast)
		return textColor;

	const textL = textColor.luminance();
	const bgL = backgroundColor.luminance();
	const lightenTargetL = ((bgL + 0.05) * minContrast) - 0.05;
	const darkenTargetL = ((bgL + 0.05) / minContrast) - 0.05;
	const lightenedColor = textColor.luminance(lightenTargetL);
	const darkenedColor = textColor.luminance(darkenTargetL);
	const lightenedContrast = chroma.contrast(lightenedColor, backgroundColor);
	const darkenedContrast = chroma.contrast(darkenedColor, backgroundColor);

	// If we couldn't improve the contrast, return the old text color
	if (lightenedContrast <= oldContrast && darkenedContrast <= oldContrast)
		return textColor;
	
	// First try to achieve the desired minimum contrast without inverting
	if (textL >= bgL && lightenedContrast >= minContrast)
		return lightenedColor;
	if (textL < bgL && darkenedContrast >= minContrast)
		return darkenedColor;

	// If that didn't work, return the color that achieves the best contrast
	return lightenedContrast > darkenedContrast ? lightenedColor : darkenedColor;
}

function renderToken(token: InlineToken) {
	if (token.tokenType === 'marker') return `<${token.closing ? '/' : ''}${token.markerType}>`;
	return `<span style="color:${token.color}">${token.innerHtml}</span>`;
}

function textPositionToTokenPosition(tokens: InlineToken[], textPosition: number): InsertionPoint {
	for (const [tokenIndex, token] of tokens.entries()) {
		if (token.tokenType !== 'syntax') continue;

		if (textPosition === token.textStart) {
			return {
				tokenIndex,
				innerHtmlOffset: 0,
			};
		}

		// The text position is inside the current token
		if (textPosition > token.textStart && textPosition < token.textEnd) {
			// To determine the correct position in tokensHtml based on textPosition,
			// we need to take position shifts due to HTML entity escaping into account,
			// so we insert a special character ('\n') at textPosition, escape the string,
			// and finally determine the new special character position
			const innerHtmlOffset = escape(
				token.text.slice(0, textPosition - token.textStart) +
					// Insert our special character at textPosition
					'\n' +
					token.text.slice(textPosition - token.textStart)
			).indexOf('\n');

			return {
				tokenIndex,
				innerHtmlOffset,
			};
		}
	}

	return {
		tokenIndex: tokens.length - 1,
		innerHtmlOffset: 0,
	};
}

function insertMarkerTokenAtPosition(tokens: InlineToken[], position: InsertionPoint, markerToken: MarkerToken) {
	// Insert the new token inside the given token by splitting it
	if (position.innerHtmlOffset > 0) {
		const insideToken = tokens[position.tokenIndex];
		if (insideToken.tokenType !== 'syntax') throw new Error(`Cannot insert a marker token inside a token of type "${insideToken.tokenType}"!`);

		const newInnerHtmlBeforeMarker = insideToken.innerHtml.slice(0, position.innerHtmlOffset);
		const tokenAfterMarker = {
			...insideToken,
			innerHtml: insideToken.innerHtml.slice(position.innerHtmlOffset),
		};
		insideToken.innerHtml = newInnerHtmlBeforeMarker;
		tokens.splice(position.tokenIndex + 1, 0, markerToken, tokenAfterMarker);
		return;
	}

	// Insert the new token before the given token
	tokens.splice(position.tokenIndex, 0, markerToken);
}
---
<style lang="scss" is:global>
	.code-snippet {
		--glow-border: 1px solid var(--theme-glow-highlight);
		filter: drop-shadow(0 0 0.3rem var(--theme-glow-diffuse));

		.header, pre {
			border: var(--glow-border);
			border-radius: 0.3rem;
			line-height: 1.65;
		}

		.header {
			display: none;
			border-bottom: none;
			padding: 0.25rem 1rem 0.25rem 1rem;
			line-height: 1.65;
			z-index: 1;
			position: relative;
			top: 1px;
			background-color: var(--theme-code-tabs);
			color: var(--theme-code-text);
			font-size: 0.9rem;
			font-weight: 500;
			letter-spacing: 0.025ch;
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		pre {
			margin: 0;
			padding: var(--padding-block) 0;
			background-color: var(--theme-code-bg) !important;

			&:focus-visible {
				outline: 3px solid var(--theme-accent);
				outline-offset: -3px;
			}

			& > code {
				all: unset;
				display: inline-block;
				min-width: 100%;
				--padding-inline: 1.25rem;

				& > .line {
					--accent-margin: 0rem;
					display: inline-block;
					min-width: calc(100% - var(--accent-margin));
					padding-inline-start: var(--padding-inline);
					padding-inline-end: calc(2 * var(--padding-inline));

					& span {
						position: relative;
					}

					// Support line-level mark/ins/del
					&.mark,
					&.ins,
					&.del {
						--accent-margin: 0.25rem;
						--accent-width: 0.15rem;
						background: var(--line-marker-bg-color);
						margin-inline-start: var(--accent-margin);
						border-inline-start: var(--accent-width) solid var(--line-marker-border-color);
						padding-inline-start: calc(var(--padding-inline) - var(--accent-margin) - var(--accent-width)) !important;
					}
					&.mark {
						--line-marker-bg-color: var(--theme-code-mark-bg);
						--line-marker-border-color: var(--theme-code-mark-border);
					}
					&.ins {
						--line-marker-bg-color: var(--theme-code-ins-bg);
						--line-marker-border-color: var(--theme-code-ins-border);
					}
					&.del {
						--line-marker-bg-color: var(--theme-code-del-bg);
						--line-marker-border-color: var(--theme-code-del-border);
					}

					// Support inline mark/ins/del
					& mark,
					& ins,
					& del {
						all: unset;
						background: var(--inline-marker-bg-color);
						box-shadow: 0 0 0 0.05rem var(--inline-marker-bg-color), 0 0 0 0.1rem var(--inline-marker-border-color);
						border-radius: 0.05rem;
					}
					& mark {
						--inline-marker-bg-color: var(--theme-code-mark-bg);
						--inline-marker-border-color: var(--theme-code-mark-border);
					}
					& ins {
						--inline-marker-bg-color: var(--theme-code-ins-bg);
						--inline-marker-border-color: var(--theme-code-ins-border);
					}
					& del {
						--inline-marker-bg-color: var(--theme-code-del-bg);
						--inline-marker-border-color: var(--theme-code-del-border);
					}
				}
			}
		}

		&.has-title {
			& .header {
				display: inline-block;
			}

			& pre {
				border-top-left-radius: 0;
			}
		}

		&.is-terminal {
			--theme-glow-highlight: rgba(255, 255, 255, 0.2);
			--theme-glow-diffuse: rgba(0, 0, 0, 0.4);

			& .header {
				display: flex;
				align-items: center;
				justify-content: center;
				padding-bottom: 0.175rem;
				min-height: 1.75rem;
				position: relative;

				&::before {
					content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 60 16' preserveAspectRatio='xMidYMid meet' fill='rgba(255, 255, 255, 0.15)'%3E%3Ccircle cx='8' cy='8' r='8'/%3E%3Ccircle cx='30' cy='8' r='8'/%3E%3Ccircle cx='52' cy='8' r='8'/%3E%3C/svg%3E");
					position: absolute;
					left: 1rem;
					width: 2.1rem;
					line-height: 0;
				}
			}

			& pre {
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
		}
		
		::selection {
			color: white;
			background-color: var(--theme-code-selection-bg);
		}
	}
</style>
<figure class:list={[
	'code-snippet',
	isTerminal && 'is-terminal',
	titleHtml && 'has-title',
	`lang-${lang}`
]}>
	<figcaption class="header">{
		titleHtml && <span class="title" set:html={titleHtml} />
	}</figcaption>
	<Fragment set:html={codeSnippetHtml} />
</figure>
