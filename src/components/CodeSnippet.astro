---
import { escape, unescape } from 'html-escaper';
import rangeParser from 'parse-numeric-range';

export interface Props {
	lang?: string;
	title?: string;
	highlightedLines?: string;
	highlightedExpressions?: string;
}

const { lang = '', title = '', highlightedLines = '', highlightedExpressions = '' } = Astro.props as Props;

const isTerminal = ['shellscript', 'shell', 'bash', 'sh', 'zsh'].includes(lang);

// Generate HTML code from the title (if any), improving the ability to wrap long file paths
// into multiple lines by inserting a line break opportunity after each slash
const titleHtml = escape(title).replace(/([\\/])/g, '$1<wbr/>');

// Render the default slot, which contains the syntax-highlighted code in HTML format
// as processed by Astro's Shiki integration
let codeSnippetHtml = await Astro.slots.render('default');

codeSnippetHtml = highlightLinesAndExpressions(codeSnippetHtml, highlightedLines, highlightedExpressions);

function highlightLinesAndExpressions(codeSnippetHtml: string, highlightedLines: string, highlightedExpressions: string) {
	const arrHighlightedLines = rangeParser(highlightedLines || '');
	const inlineHighlightRegExp = highlightedExpressions ? new RegExp(unescape(highlightedExpressions), 'g') : undefined;

	if (!arrHighlightedLines.length && !inlineHighlightRegExp)
		return codeSnippetHtml;

	const lines = codeSnippetHtml.trim().split(/\r?\n/);
	const lineRegExp = /^((?:<pre.*?><code.*?>)?<span class=")(line.*?)(".*?>)(.*)(<\/span>(?:<\/code><\/pre>)?)$/;

	lines.forEach((line, i) => {
		lines[i] = line.replace(lineRegExp, (_, beforeLineClass, lineClass, afterLineClass, tokensHtml, afterTokens) => {

			if (arrHighlightedLines.includes(i + 1)) {
				const classes = new Set(lineClass.split(' '));
				classes.add('highlighted');
				lineClass = [...classes].join(' ');
			}

			if (inlineHighlightRegExp) {
				tokensHtml = highlightExpressions(tokensHtml, inlineHighlightRegExp);
			}

			return `${beforeLineClass}${lineClass}${afterLineClass}${tokensHtml}${afterTokens}`;
		});
	});

	return lines.join('\n');
}

function highlightExpressions(tokensHtml: string, inlineHighlightRegExp: RegExp) {
	const tokenMatches = tokensHtml.matchAll(/(<span style=".*?".*?>)(.*?)(<\/span>)/g);
	const tokens: any = [];
	let textLine = '';
	for (const tokenMatch of tokenMatches) {
		const [fullMatch, openingTag, textHtml, closingTag] = tokenMatch;
		const text = unescape(textHtml);
		const start = tokenMatch.index as number;
		tokens.push({
			openingTag,
			textHtml,
			text,
			closingTag,
			start,
			end: start + fullMatch.length,
			textStart: textLine.length,
			textEnd: textLine.length + text.length,
		});
		textLine += text;
	}

	const textHighlightRanges = [];
	const textMatches = textLine.matchAll(inlineHighlightRegExp);
	for (const textMatch of textMatches) {
		const start = textMatch.index as number;
		const end = start + textMatch[0].length;
		textHighlightRanges.push({
			start,
			end,
			match: textMatch[0],
		});
	}

	if (textHighlightRanges.length) {
		// Mutate tokensHtml in reverse direction (from end to start),
		// inserting the opening and closing highlight tags at the correct positions,
		// optionally splitting tokens if highlight boundaries do not match token boundaries
		textHighlightRanges.reverse().forEach(textHighlightRange => {
			tokensHtml = insertTag(tokensHtml, tokens, textHighlightRange.end, '</span>');
			tokensHtml = insertTag(tokensHtml, tokens, textHighlightRange.start, '<span class="highlighted">');
		});
	}

	return tokensHtml;
}

function insertTag(tokensHtml: string, tokens: any, textPosition: number, tag: string) {
	let position = -1;
	tokens.some((token: any) => {
		if (textPosition === token.textStart) {
			position = token.start;
			return true;
		}
		if (textPosition === token.textEnd) {
			position = token.end;
			return true;
		}
		// The text position is inside the current token
		if (textPosition > token.textStart && textPosition < token.textEnd) {
			// To determine the correct position in tokensHtml based on textPosition,
			// we need to take position shifts due to HTML entity escaping into account,
			// so we insert a marker ('\n') at textPosition, escape the string,
			// and finally determine the new marker position
			let positionInEscapedTokenText = escape(
				token.text.slice(0, textPosition - token.textStart) +
				// Insert our marker at textPosition
				'\n' +
				token.text.slice(textPosition - token.textStart)
			).indexOf('\n');
			position = (
				// Begin at the position of the token in tokensHtml 
				token.start +
				// Add the length of the opening tag
				token.openingTag.length +
				// And finally add the position in the escaped token text
				positionInEscapedTokenText
			);
			// We need to split the token to insert the tag, so we close it, 
			// insert the tag, and then repeat the opening tag again
			tag = `</span>${tag}${token.openingTag}`;
			return true;
		}
	});

	if (position === -1)
		throw new Error(`Failed to insert tag "${tag}" at textPosition ${textPosition}: No matching tokens found!`);

	// Insert the tag at the determined position and return the updated HTML code
	tokensHtml = tokensHtml.slice(0, position) + tag + tokensHtml.slice(position);
	return tokensHtml;
}
---
<style lang="scss" is:global>
	.code-snippet {
		--glow-border: 1px solid var(--theme-glow-highlight);
		filter: drop-shadow(0 0 0.3rem var(--theme-glow-diffuse));

		.header, pre {
			border: var(--glow-border);
			border-radius: 0.3rem;
			line-height: 1.65;
		}

		.header {
			display: none;
			border-bottom: none;
			padding: 0.25rem 1rem 0.25rem 1rem;
			line-height: 1.65;
			z-index: 1;
			position: relative;
			top: 1px;
			background-color: var(--theme-code-tabs);
			color: var(--theme-code-text);
			font-size: 0.9rem;
			font-weight: 500;
			letter-spacing: 0.025ch;
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		pre {
			margin: 0;
			padding: var(--padding-block) 0;
			background-color: var(--theme-code-bg) !important;

			&:focus-visible {
				outline: 3px solid var(--theme-accent);
				outline-offset: -3px;
			}

			& > code {
				all: unset;
				display: inline-block;
				min-width: 100%;
				--padding-inline: 1.25rem;

				& > .line {
					--accent-margin: 0rem;
					display: inline-block;
					min-width: calc(100% - var(--accent-margin));
					padding-inline-start: var(--padding-inline);
					padding-inline-end: calc(2 * var(--padding-inline));
				}

				& > .line.highlighted {
					--accent-margin: 0.25rem;
					--accent-width: 0.25rem;
					background: var(--theme-code-highlight-bg);
					margin-inline-start: var(--accent-margin);
					border-inline-start: var(--accent-width) solid var(--theme-code-highlight-border);
					padding-inline-start: calc(var(--padding-inline) - var(--accent-margin) - var(--accent-width)) !important;
				}

				& > .line .highlighted {
					background: var(--theme-code-highlight-bg);
					box-shadow: 0 0 0 1px var(--theme-code-highlight-border);
					border-radius: 0.2rem;
					padding-inline: 0.15rem;
					margin-inline: 0.1rem;
				}
			}
		}

		&.has-title {
			& .header {
				display: inline-block;
			}

			& pre {
				border-top-left-radius: 0;
			}
		}

		&.is-terminal {
			--theme-glow-highlight: rgba(255, 255, 255, 0.2);
			--theme-glow-diffuse: rgba(0, 0, 0, 0.4);

			& .header {
				display: flex;
				align-items: center;
				justify-content: center;
				padding-bottom: 0.175rem;
				min-height: 1.75rem;
				position: relative;

				&::before {
					content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 60 16' preserveAspectRatio='xMidYMid meet' fill='rgba(255, 255, 255, 0.15)'%3E%3Ccircle cx='8' cy='8' r='8'/%3E%3Ccircle cx='30' cy='8' r='8'/%3E%3Ccircle cx='52' cy='8' r='8'/%3E%3C/svg%3E");
					position: absolute;
					left: 1rem;
					width: 2.1rem;
					line-height: 0;
				}
			}

			& pre {
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
		}
		
		::selection {
			color: white;
			background-color: var(--theme-code-selection-bg);
		}
	}
</style>
<figure class:list={[
	'code-snippet',
	isTerminal && 'is-terminal',
	titleHtml && 'has-title',
	`lang-${lang}`
]}>
	<figcaption class="header">{
		titleHtml && <span class="title" set:html={titleHtml} />
	}</figcaption>
	<Fragment set:html={codeSnippetHtml} />
</figure>
