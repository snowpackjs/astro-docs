---
layout: ~/layouts/MainLayout.astro
title: Gu√≠a de migraci√≥n
description: C√≥mo migrar tu proyecto de Astro a la √∫ltima versi√≥n.
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'



Esta gu√≠a te ayudar√° a migrar desde alguna versi√≥n vieja a la √∫ltima versi√≥n de Astro.

Puedes actualizar a la √∫ltima versi√≥n de Astro en tu proyecto utilizando tu gestor de paquetes. Si est√°s utilizando integraciones de Astro, deber√≠as considerar actualizarlas tambi√©n a la √∫ltima versi√≥n disponible.
<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # actualiza la dependencia astro:
  npm upgrade astro
  # o, para actualizar todas las dependencias:
  npm upgrade
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # actualiza la dependencia astro:
  pnpm upgrade astro
  # o, para actualizar todas las dependencias:
  pnpm upgrade
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # actualiza la dependencia astro:
  yarn upgrade astro
  # o, para actualizar todas las dependencias:
  yarn upgrade
  ```
  </Fragment>
</PackageManagerTabs>


Lee la siguiente gu√≠a para ver los aspectos m√°s destacados e instrucciones sobre c√≥mo manejar los cambios no retrocompatibles.

## Astro 1.0

Astro v1.0 introduce algunos cambios que requieren tu atenci√≥n si migras desde versiones v0.x y v1.0-beta. Sigue leyendo para m√°s detalles.

### Actualizaci√≥n: Vite 3

Astro v1.0 ha sido actualizado de Vite 2 a [Vite 3](https://vitejs.dev/). Nos hemos encargado de la mayor√≠a de la actualizaci√≥n por ti; sin embargo, alg√∫n comportamiento sutil puede cambiar entre versiones. Puedes acudir a la [Gu√≠a de Migraci√≥n de Vite](https://vitejs.dev/guide/migration.html#general-changes) oficial si tienes problemas.

### Deprecado: `Astro.canonicalURL`

Ahora puedes usar el nuevo helper [`Astro.url`](/es/reference/api-reference/#astrourl) para construir tu propia URL can√≥nica desde la p√°gina/request URL actual.

```js del="Astro.canonicalURL" ins="new URL(Astro.url.pathname, Astro.site)"
// Antes:
const canonicalURL = Astro.canonicalURL;
// Despu√©s:
const canonicalURL = new URL(Astro.url.pathname, Astro.site);
```

### Cambio: Especificidad del CSS Local

La [especificidad](https://developer.mozilla.org/es/docs/Web/CSS/Specificity) ahora va a ser respetada en los estilos CSS locales. Este cambio causar√° que la mayor√≠a de los estilos locales _respeten_ la precedencia sobre los estilos globales. Pero, este comportamiento no es garantizado de manera expl√≠cita.

T√©cnicamente, esto se logra utilizando [la pseudo-clase `:where()`](https://developer.mozilla.org/es/docs/Web/CSS/:where) en vez de usar clases directamente en el output de CSS de Astro.

Usemos el siguiente bloque de estilo en un componente de Astro como ejemplo:

```astro
<style>
  div { color: red; } /* especificidad 0-0-1 */
</style>
```

Anteriormente, Astro transformar√≠a este bloque en el siguiente CSS, que tiene una especificidad de `0-1-1` ‚Äî una especificidad mayor al CSS fuente:

```css del=".astro-XXXXXX"
div.astro-XXXXXX { color: red; } /* especificidad 0-1-1 */
```

Ahora, Astro envuelve el selector de clase con `:where()`, manteniendo la especificidad:

```css ins=":where(.astro-XXXXXX)"
div:where(.astro-XXXXXX) { color: red; } /* especificidad 0-0-1 */
```
El anterior aumento en especificidad complicaba la combinaci√≥n entre estilos locales en Astro con archivos CSS o librer√≠as de estilo (por ejemplo, Tailwind, CSS Modules, Styled Components, Stitches), Este cambio permite que los estilos locales en Astro funcionen en conjunto de manera consistente mientras se preservan los l√≠mites exclusivos que previenen que los estilos se filtren fuera del componente.

:::caution
Al actualizar, por favor realiza una inspecci√≥n visual de tu proyecto para asegurarte que se apliquen los estilos esperados. De no ser as√≠, puedes buscar el estilo local e incrementar la especificidad del selector manualmente para mantener el comportamiento anterior.
:::

### Deprecado: Componentes y JSX en Markdown

Astro ya no es compatible con componentes o expresiones JSX en p√°ginas de Markdown por defecto. Para obtener soporte a largo plazo debes migrar a la integraci√≥n [`@astrojs/mdx`](/es/guides/integrations-guide/mdx/).

Para hacer la migraci√≥n m√°s simple, puedes utilizar la nueva [legacy flag](/es/reference/configuration-reference/#legacyastroflavoredmarkdown) para volver a activar las caracter√≠sticas previas de Markdown.

### Convertir archivos `.md` a `.mdx`

Si MDX no te es familiar, te presentamos unos pasos que puedes seguir para convertir un archivo "Astro Flavored Markdown" a MDX. Mientras m√°s aprendas sobre MDX, ¬°si√©ntete libre de explorar otras maneras de escribir tus p√°ginas!

1. Instala la integraci√≥n [`@astrojs/mdx`](/es/guides/integrations-guide/mdx/).

2. Cambia la extensi√≥n de tus archivos `.md` a `.mdx`

3. Remueve cualquier propiedad `setup:` de tu frontmatter y escribe las importaciones debajo del frontmatter.

    ```mdx del={4-5} ins={10}
    // src/pages/posts/my-post.mdx
    ---
    layout: '../../layouts/BaseLayout.astro'
    setup: |
      import ReactCounter from '../../components/ReactCounter.jsx'
    title: 'Migrando a MDX'
    date: 2022-07-26
    tags: ["markdown", "mdx", "astro"]
    ---
    import ReactCounter from '../../components/ReactCounter.jsx'

    # {frontmatter.title}

    Este es mi componente de contador, funcionando en MDX:

    <ReactCounter client:load />
    ```

4. Actualiza el uso de `Astro.glob()` que actualmente retornen archivos `.md` para que ahora retornen tus archivos `.mdx`.

    :::caution
    El objeto retornado al importar archivos `.mdx` (inclusive usando Astro.glob) difiere del objeto retornado al importar archivos `.md`. Sin embargo, `frontmatter`, `file`, y `url` funcionan de manera id√©ntica.
    :::

5. Actualiza el uso del componente `<Content />` para usar la exportaci√≥n por defecto cuando importas MDX:

    ```astro title="src/pages/index.astro" ins=".default"
    ---
    // M√∫ltiples importaciones con Astro.glob
    const mdxPosts = await Astro.glob('./posts/*.mdx');
    ---

    {mdxPosts.map(Post => <Post.default />)}
    ```

    ```astro title="src/pages/index.astro" ins="default as"
    ---
    // Importa una sola p√°gina
    import { default as About } from './about.mdx';
    ---

    <About />
    ```

:::tip
Mientras est√©s migrando a MDX, puede que quieras [activar la flag legacy](/es/reference/configuration-reference/#legacyastroflavoredmarkdown) e incluir ambos archivos **`.md` y `.mdx`**, as√≠ tu sitio contin√∫a funcionando normalmente aun luego de haber convertido todos tus archivos. Puedes hacerlo de la siguiente manera:

```astro
---
const mdPosts = await Astro.glob('../pages/posts/*.md');
const mdxPosts = await Astro.glob('../pages/posts/*.mdx');
const allPosts = [...mdxPosts, ...mdPosts];
---
```
:::

### Componente `<Markdown />` Removido

El componente `<Markdown />` incluido en Astro ha sido movido a un paquete aparte. Para continuar usando este componente, debes instalar `@astrojs/markdown-component` y actualizar tus importaciones como corresponde. Para m√°s detalles, lee [el README de `@astrojs/markdown`](https://github.com/withastro/astro/tree/main/packages/markdown/component).

:::tip
Astro ahora soporta [MDX](https://mdxjs.com/) a trav√©s de nuestra [Integraci√≥n con MDX](https://github.com/withastro/astro/tree/main/packages/integrations/mdx). MDX te permite incluir ambos Markdown y componentes importados en el mismo archivo. MDX puede ser una buena alternativa al componente `<Markdown />` gracias a su gran comunidad y APIs estables.
:::

## Migrar a v1.0.0-beta

El 4 de abril de 2022 publicamos Astro 1.0 Beta! üéâ

Si te encuentras en la v0.25 o anterior, aseg√∫rate de haber le√≠do y seguido la [Gu√≠a de Migraci√≥n a v0.26](#migrar-a-v026), la cual contiene muchos cambios no retrocompatibles.

La versi√≥n `v1.0.0-beta.0` de Astro no contiene cambios no retrocompatibles. A continuaci√≥n, veremos unos cambios peque√±os que fueron introducidos durante el per√≠odo de beta.

### Cambio: RSS Feeds

Los feeds RSS ahora deben ser generados usando el paquete `@astrojs/rss`, tal como se describe en nuestra [gu√≠a de RSS](/es/guides/rss/).

## Migrar a v0.26
### Nueva API de Configuraci√≥n

Nuestra API de Configuraci√≥n ha sido redise√±ada para resolver algunos puntos de confusi√≥n que se han generado durante el √∫ltimo a√±o. La mayor√≠a de las opciones de configuraci√≥n han sido movidas o renombradas, por lo cual es posible que sea una actualizaci√≥n r√°pida para la mayor√≠a de los usuarios. Unas pocas opciones han sido refactorizadas m√°s profundamente, y pueden requerir algunos cambios adicionales:

- `.buildOptions.site` ha sido reemplazado por `.site` (tu dominio desplegado) y una nueva opci√≥n `.base` (tu subdirecci√≥n desplegada).
- `.markdownOptions` ha sido reemplazado por `.markdown`, un objeto de configuraci√≥n similar con peque√±os cambios para simplificar la configuraci√≥n del Markdown.
- `.sitemap` fue movido dentro de la integraci√≥n [@astrojs/sitemap](https://www.npmjs.com/package/@astrojs/sitemap).

Si ejecutas Astro con configuraci√≥n legacy, ver√°s una advertencia con instrucciones sobre c√≥mo actualizar. Lee nuestra [Referencia de configuraci√≥n](/es/reference/configuration-reference/) para m√°s informaci√≥n.

Lee [RFC0019](https://github.com/withastro/rfcs/blob/main/proposals/0019-config-finalization.md) para obtener m√°s contexto sobre estos cambios.

### Nueva API de Markdown

Astro v0.26 publica una nueva API de Markdown para tu contenido. Esto incluye tres grandes cambios al usuario:
- Ahora puedes usar `import`/`import()` para contenido markdown directamente utilizando una importaci√≥n ESM.
- Una renovada API `Astro.glob()`, para importaciones glob m√°s simples (especialmente para Markdown).
- **CAMBIO NO RETROCOMPATIBLE:** `Astro.fetchContent()` ha sido eliminado y reemplazado por `Astro.glob()`
- **CAMBIO NO RETROCOMPATIBLE:** Se ha actualizado la interfaz de los objetos de Markdown.

```js del={2} ins={4}
// v0.25
let allPosts = Astro.fetchContent('./posts/*.md');
// v0.26+
let allPosts = await Astro.glob('./posts/*.md');
```

Al migrar, ten cuidado con la nueva interfaz de los objetos de Markdown. El frontmatter, por ejemplo, ha sido movido a la propiedad `.frontmatter`, entonces referencias tales como `post.title` deber√≠an cambiarse por `post.frontmatter.title`.

Esto deber√≠a resolver muchos problemas para usuarios de Markdown, incluyendo algunas mejoras de performance para sitios grandes.

Lee [RFC0017](https://github.com/withastro/rfcs/blob/main/proposals/0017-markdown-content-redesign.md) para obtener m√°s contexto sobre estos cambios.

### Nuevo comportamiento de Script por defecto

Las etiquetas `<script>` en los componentes Astro ahora son construidos, empaquetados y optimizados por defecto. Esto logra finalmente que nuestra sintaxis de componentes de Astro sea m√°s consistente, a tono con el comportamiento optimizado por defecto que nuestras etiquetas `<style>` tienen hoy en d√≠a.

Esto incluye algunos cambios de los que deber√≠as estar al tanto:

- **NO RETROCOMPATIBLE:** `<script hoist>` es el nuevo comportamiento por defecto de `<script>`. El atributo `hoist` fue eliminado. Para usar el nuevo comportamiento por defecto, aseg√∫rate que no haya otros atributos en la etiqueta `<script>`. Por ejemplo, elimina `type="module"` si lo estabas utilizando.
- Nueva directiva `<script is:inline>`, para revertir una etiqueta `<script>` a su comportamiento previo (sin que Astro la construya, empaquete ni toque).
- Nueva directiva `<style is:inline>`, para indicar que una etiqueta de estilo se mantenga en l√≠nea en la plantilla de p√°gina (similar al comportamiento previo de `<script>`).
- Nueva directiva `<style is:global>` para reemplazar `<style global>` en una publicaci√≥n futura.


```js del={2} ins={4}
// v0.25
<script hoist type="module">
// v0.26+
<script>
```

Lee c√≥mo usar [scripts del lado del cliente](/es/core-concepts/astro-components/#scripts-del-lado-del-cliente) en Astro detalladamente.

Lee [RFC0016](https://github.com/withastro/rfcs/blob/main/proposals/0016-style-script-defaults.md) para obtener m√°s contexto sobre estos cambios.

### Actualizaci√≥n de la API `Astro.request`


`Astro.request` ha sido cambiada desde un objeto personalizado nuestro a un objeto est√°ndar `Request`. Esto es parte de un proyecto para usar m√°s APIs est√°ndar de la web, especialmente durante la utilizaci√≥n de SSR.

Esto incluye algunos cambios de los que deber√≠as estar al tanto:

- Cambia `Astro.request` para convertirse en un objeto [Request](https://developer.mozilla.org/es/docs/Web/API/Request).
- Mueve `Astro.request.params` a `Astro.params`.
- Mueve `Astro.request.canonicalURL` a `Astro.canonicalURL`.

Lee [RFC0018](https://github.com/withastro/rfcs/blob/main/proposals/0018-astro-request.md) para obtener m√°s contexto sobre estos cambios.


### Otros cambios

- Mejoras en la API `Astro.slots` para admitir pasar argumentos a slots basados en funciones. Esto permite componentes utilitarios de mayor ergonom√≠a que pueden aceptar una funci√≥n callback como hijo.
- Actualizaciones en el formato del texto de salida en la CLI, especialmente en reportes de errores.
- Actualizaciones en `@astrojs/compiler`, arreglando algunos bugs relacionados a utilizaci√≥n de RegExp en el frontmatter.

## Migrar a v0.25

### Integraciones de Astro

¬°La configuraci√≥n de `renderers` ha sido reemplazada por un nuevo y oficial sistema de integraciones! Esto desbloquea algunas caracter√≠sticas emocionantes para Astro. Puedes leer nuestra gu√≠a [Usando Integraciones](/es/guides/integrations-guide/) para m√°s detalles sobre c√≥mo usar este nuevo sistema.

Las Integraciones reemplazan nuestro concepto original de `renderers` y trae consigo cambios no retrocompatibles y nuevas configuraciones por defecto para usuarios existentes. Veremos estos cambios a continuaci√≥n.

#### Removido: Soporte de Frameworks incorporado

Anteriormente, React, Preact, Svelte y Vue estaban incluidos con Astro por defecto. Desde la v0.25.0, Astro ya no trae ning√∫n renderer incorporado. Si no ten√≠as una configuraci√≥n `renderers` definida en tu proyecto, ahora debes instalar t√∫ mismo todos los frameworks que utilices.

Lee nuestra [gu√≠a paso a paso](/es/guides/integrations-guide/) para aprender a agregar una nueva integraci√≥n a Astro para el o los frameworks que est√©s utilizando.
#### Deprecado: Renderers

:::note
Lee esta secci√≥n si ya tienes "renderers" personalizados definidos en tu archivo de configuraci√≥n.
:::

El nuevo sistema de integraciones reemplaza al viejo sistema de `renderers`, incluyendo los paquetes `@astrojs/renderer-*` publicados en npm. De aqu√≠ en m√°s, `@astrojs/renderer-react` se convierte en `@astrojs/react`, `@astrojs/renderer-vue` se convierte en `@astrojs/vue`, etc√©tera.

**Para migrar:** actualiza Astro a `v0.25.0` y luego ejecuta `astro dev` o `astro build` con tu configuraci√≥n vieja con `"renderers"`. Ver√°s inmediatamente una noticia indic√°ndote exactamente los cambios que debes realizar en tu archivo `astro.config.mjs`, bas√°ndote en tu configuraci√≥n actual. Tambi√©n puedes actualizar los paquetes t√∫ mismo, siguiendo la tabla que veremos a continuaci√≥n.

Para una gu√≠a m√°s detallada, lee nuestra [gu√≠a paso a paso](/es/guides/integrations-guide/) para aprender c√≥mo reemplazar renderers existentes con una nueva integraci√≥n de Astro.

```shell add={3-4}
# Instala tus nuevas integraciones y frameworks:
# (Lee la gu√≠a detallada: https://docs.astro.build/es/guides/integrations-guide)
npm install @astrojs/lit lit
npm install @astrojs/react react react-dom
```

```js ins={3-4,8} del={7}
// Luego, actualiza tu archivo `astro.config.mjs`:
// (Lee la gu√≠a detallada: https://docs.astro.build/es/guides/integrations-guide)
import lit from '@astrojs/lit';
import react from '@astrojs/react';

export default {
  renderers: ['@astrojs/renderer-lit', '@astrojs/renderer-react'],
  integrations: [lit(), react()],
}
```


| Renderers Deprecados en npm | Integraciones v0.25+ en npm|
| --------------------------- | -------------------------- |
| @astrojs/renderer-react     | @astrojs/react             |
| @astrojs/renderer-preact    | @astrojs/preact            |
| @astrojs/renderer-solid     | @astrojs/solid-js          |
| @astrojs/renderer-vue       | @astrojs/vue               |
| @astrojs/renderer-svelte    | @astrojs/svelte            |

#### Manejando Dependencias Peer

:::note
Lee esta secci√≥n si no tienes instalada la v14 de Node **o** si usas un gestor de paquetes distinto a npm.
:::

Diferente a los viejos renderers, las integraciones ya no tienen los frameworks ("react", "svelte", "vue", etc.) como dependencias directas. En cambio, ahora deber√≠as instalar los paquetes de framework t√∫ mismo *adem√°s de* tus integraciones.

```shell ins="react react-dom"
# Ejemplo: Instala integraciones y frameworks en conjunto
npm install @astrojs/react react react-dom
```

Si ves una advertencia con el texto `"Cannot find package 'react'"` (o similar) cuando intentas ejecutar Astro, esto significa que debes instalar ese paquete en tu proyecto. Lee nuestra [nota sobre dependencias peer](/es/guides/troubleshooting/#cannot-find-package-x) en la gu√≠a de soluci√≥n de problemas para m√°s informaci√≥n.

Si usas `npm` y Node v16+ entonces es posible que esto sea manejado autom√°ticamente por `npm`, ya que las √∫ltimas versiones de `npm` (v7+) instala las dependencias peer por ti autom√°ticamente. En este caso, instalar un framework como "react" en tu proyecto es un paso opcional, aunque recomendado.

### Actualizaci√≥n: Resaltado de Sintaxis

Amamos encontrar configuraciones por defecto sensatas y que "simplemente funcionan" out-of-the-box. Como parte de esto, decidimos que [Shiki](https://github.com/shikijs/shiki) sea nuestro nuevo resaltador de sintaxis por defecto. Viene preconfigurado con el tema `github-dark`, proveyendo resaltado de sintaxis en tus bloques de c√≥digo sin ninguna configuraci√≥n adicional, sin clases extras de CSS, hojas de estilos, o JS del lado del cliente extra√±os.

Lee nuestros nuevos [docs de resaltado de sintaxis](/es/guides/markdown-content/#resaltado-de-sintaxis) para m√°s detalles. **Si deseas mantener Prism como tu resaltador de sintaxis,** [establece la opci√≥n `syntaxHighlight` a `'prism'`](/es/guides/markdown-content/#configuraci√≥n-de-prism) en la configuraci√≥n del markdown de tu proyecto.

#### El componente `<Prism />` tiene un nuevo hogar

Como parte de nuestra misi√≥n de mantener el n√∫cleo (core) de Astro lo m√°s peque√±o posible, hemos movido el componente incorporado `Prism` fuera de `astro/components` y dentro del paquete `@astrojs/prism`. Ahora puedes importar este componente desde `@astrojs/prism` de la siguiente manera:

```astro
---
import { Prism } from '@astrojs/prism';
---
```

¬°Como el paquete `@astrojs/prism` todav√≠a est√° empaquetado con el n√∫cleo (core) de `astro`, no necesitas instalar nada nuevo ni a√±adir Prism como integraci√≥n! Sin embargo, puedes notar que nuestro plan es extraer `@astrojs/prism` (y el resaltado de sintaxis de Prism en general) a un paquete separado e instalable en un futuro. Lee [la referencia de la API del componente `<Prism />`](/es/reference/api-reference/#prism-) para m√°s informaci√≥n.

### Actualizaci√≥n del Parser de CSS

Nuestro parser interno de CSS ha sido actualizado y provee mejor soporte para uso de sintaxis avanzada de CSS, como container queries. Este cambio ser√° invisible a la mayor√≠a de los usuarios, pero creemos que los usuarios m√°s avanzados disfrutar√°n de esta nueva caracter√≠stica.
## Migrar a v0.24

:::note
La nueva estrategia de construcci√≥n est√° activada por defecto en 0.24. Si tienes alg√∫n problema puedes continuar usando la vieja estrategia de construcci√≥n usando la flag `--legacy-build`. Por favor [abre un issue](https://github.com/withastro/astro/issues/new/choose) para que podamos resolver cualquier problema causado por la nueva estrategia de construcci√≥n.
:::

0.24 introdujo una nueva estrategia de *static build* que cambia el comportamiento de algunas caracter√≠sticas nuevas. Este comportamiento estaba disponible en versiones anteriores de Astro por medio de una flag opcional: `--experimental-static-build`.

Para migrar a la transici√≥n, ten en cuenta los siguientes cambios que ser√°n requeridos para este nuevo engine de construcci√≥n. Puedes hacer estos cambios en tu proyecto en cualquier momento para adelantar trabajo.

### Deprecado: `Astro.resolve()`

`Astro.resolve()` te permite obtener URLs resueltas a recursos que necesites referenciar en el navegador. Esto era m√°s usado com√∫nmente dentro de etiquetas `<link>` y `<img>` para cargar archivos CSS e im√°genes depende de c√≥mo sea necesario. Desafortunadamente esto no va a funcionar debido a que ahora Astro construye los recursos en *tiempo de construcci√≥n* en vez de *tiempo de renderizado*. Es mejor que actualices las referencias a tus recursos de las siguientes opciones "a prueba del futuro":

#### C√≥mo Resolver Archivos CSS

**1. Importaci√≥n ESM (Recomendado)**

**Ejemplo:** `import './style.css';`
**Cu√°ndo usar esto:** Si tu archivo CSS se encuentra dentro de la carpeta `src/` y quieres aprovechar caracter√≠sticas de construcci√≥n y optimizaci√≥n de CSS autom√°ticas.

Usa una importaci√≥n ESM para a√±adir CSS en la p√°gina. Astro detecta estas importaciones de CSS y luego construye, optimiza y a√±ade el CSS a la p√°gina autom√°ticamente. Esta es la forma m√°s f√°cil de migrar desde `Astro.resolve()` mientras mantienes la construcci√≥n/empaquetado autom√°tico que provee Astro.

```astro
---
// Ejemplo: Astro va a incluir y optimizar este CSS por ti autom√°ticamente
import './style.css';
---
<html><!-- Tu p√°gina aqu√≠ --></html>
```

Importar archivos CSS debe funcionar en cualquier lugar que las importaciones ESM sean admitidas, incluyendo:
- Archivos JavaScript
- Archivos TypeScript
- Frontmatter de componentes Astro
- Componentes no-Astro como React, Svelte y otros

Cuando se importa un archivo CSS usando ese m√©todo, cualquier declaraci√≥n de `@import` tambi√©n es resuelta y agregada en l√≠nea al archivo CSS importado. Todas las referencias de `url()` tambi√©n son resueltas de forma relativa al archivo fuente, y cualquier recurso referenciado con `url()` va a ser incluido en la construcci√≥n final de tu sitio.


**2. Path URL Absoluto**

**Ejemplo:** `<link href="/style.css">`
**Cu√°ndo usar esto:** Si tu archivo CSS se encuentra dentro de la carpeta `public/` y prefieres crear tu elemento HTML `link` por ti mismo.

Puedes referenciar cualquier archivo dentro de la carpeta `public/` usando path URL absoluto en la plantilla de tu componente. Esta es una buena opci√≥n si quieres mantener el control de la etiqueta `<link>`. Sin embargo, este enfoque saltea el procesado, empaquetado y optimizaciones de CSS provistas por Astro cuando usas el m√©todo `import` descripto anteriormente.

Recomendamos usar el enfoque de `import` sobre el de path URL absoluto ya que provee la mejor performance y mayores caracter√≠sticas de CSS por defecto.

#### C√≥mo Resolver Archivos JavaScript


**1. Path URL Absoluto**

**Ejemplo:** `<script src="/some-external-script.js" />`
**Cu√°ndo usar esto:** Si tu archivo JavaScript se encuentra dentro de la carpeta `public/`.

Puedes referenciar cualquier archivo dentro de la carpeta `public/` usando path URL absoluto en la plantilla de tu componente. Esta es una buena opci√≥n si quieres mantener el control de la etiqueta `<script>`.

Nota que este enfoque saltea el procesado, empaquetado y optimizaciones de JavaScript provistas por Astro cuando usas el m√©todo `import` descrito aqu√≠ debajo. Sin embargo, puedes preferir esto para scripts externos que hayan sido publicados y _minificados_ de forma separada a Astro. Si tu script fue descargado de una fuente externa, entonces es probable que prefieras usar este m√©todo.

**2. Importaci√≥n ESM v√≠a `<script hoist>`**

**Ejemplo:** `<script hoist>import './some-external-script.js';</script>`
**Cu√°ndo usar esto:** Si tu script externo se encuentra dentro de la carpeta `src/` _y_ soporta el tipo de m√≥dulo ESM.

Usa una importaci√≥n ESM dentro de un elemento `<script hoist>` en la plantilla de tu componente Astro y Astro incluir√° el archivo JavaScript en la construcci√≥n final. Astro detecta estas importaciones de JavaScript del lado del cliente y luego construye, optimiza y a√±ade el JavaScript a la p√°gina autom√°ticamente. Esta es la forma m√°s simple de migrar desde `Astro.resolve()` mientras mantienes la construcci√≥n/empaquetado autom√°tico que provee Astro.

```astro
<script hoist>
  import './algun-script-externo.js';
</script>
```

Nota que Astro empaquetar√° este script externo con el resto de tu JavaScript del lado del cliente y lo cargar√° en el contexto de script `type=module`. Es probable que algunos archivos de JavaScript viejos no est√©n escritos para el contexto `module`, en cuyo caso estos archivos deber√≠an ser actualizados para usar este m√©todo.

#### C√≥mo Resolver Im√°genes & Otros Recursos

**1. Path URL Absoluto (Recomendado)**

**Ejemplo:** `<img src="/penguin.png">`
**Cu√°ndo usar esto:** Si tu recurso se encuentra dentro de la carpeta `public/`.

Si colocas tus im√°genes dentro de la carpeta `public/` puedes referenciarlas con un path URL absoluto directo en la plantilla de tu componente. Esta es la forma m√°s simple de referenciar un recurso para ser utilizado y es lo recomendado para la mayor√≠a de los usuarios que reci√©n comienzan a usar Astro.

**2. Importaci√≥n ESM**

**Ejemplo:** `import imgUrl from './penguin.png'`
**Cu√°ndo usar esto:** Si tu recurso se encuentra dentro de la carpeta `src/` y quieres aprovechar caracter√≠sticas de optimizaci√≥n autom√°ticas tales como hashing en nombres de archivos.

Esto funciona dentro de cualquier componente JavaScript o Astro y retorna una URL resuelta a la imagen final. Una vez que tienes la URL resuelta, puedes usarla en cualquier lugar de la plantilla de tu componente.

```astro
---
// Ejemplo: Astro incluir√° esta imagen en el resultado final
import imgUrl from './penguin.png';
---
<img src={imgUrl} />
```

De manera similar a c√≥mo Astro maneja CSS, la importaci√≥n ESM le permite a Astro realizar algunas optimizaciones simples por ti autom√°ticamente. Por ejemplo, cualquier recurso dentro de la carpeta `src/` que sea importado por medio de una importaci√≥n ESM (ejemplo: `import imgUrl from './penguin.png'`) tendr√° su nombre _hasheado_ autom√°ticamente. Esto te permite guardar el archivo en cache en el servidor de manera m√°s agresiva, mejorando la performance para el usuario. En un futuro, Astro agregar√° m√°s optimizaciones de este estilo.

**Tip:** Si no te gustan las importaciones ESM est√°ticas, Astro tambi√©n soporta importaciones ESM din√°micas. Solamente recomendamos esta opci√≥n si prefieres este tipo de sintaxis: `<img src={(await import('./penguin.png')).default} />`.

### Deprecado: Procesamiento de `<script>` por Defecto

Anteriormente, todos los elementos `<script>` del HTML generado eran le√≠dos, procesados y empaquetados autom√°ticamente. Este comportamiento ya no es as√≠ por defecto. Desde la versi√≥n 0.24, debes optar al procesamiento de elementos `<script>` por medio del atributo `hoist`. Tambi√©n es requerido `type="module"` para m√≥dulos hoisted.

```astro
<script>
  // ¬°Va a ser renderizado en el HTML tal cual est√© escrito!
  // Las importaciones ESM no ser√°n resueltas de forma relativa al archivo.
</script>
<script type="module" hoist>
  // ¬°Procesado! ¬°Empaquetado! Las importaciones ESM funcionan, aun para paquetes npm.
</script>
```


## Migrar a v0.23

### Error: No se encuentra Sass

```
Preprocessor dependency "sass" not found. Did you install it?
```

En nuestra b√∫squeda por reducir el tama√±o de instalaci√≥n por npm, hemos movido [Sass](https://sass-lang.com/) a una dependencia externa opcional. Si usas Sass en tu proyecto, deber√≠as asegurarte de ejecutar `npm install sass --save-dev` para instalarlo como dependencia.

### Deprecado: HTML sin escapar

En Astro v0.23+, el contenido HTML sin escapar en expresiones est√° deprecado.
En publicaciones futuras, el contenido dentro de expresiones tendr√° strings escapadas para protegerlas contra inyecci√≥n de HTML inesperadas.

```astro del={1} ins={2}
<h1>{title}</h1> <!-- <h1>Hola <strong>Mundo</strong></h1> -->
<h1>{title}</h1> <!-- <h1>Hola &lt;strong&gt;Mundo&lt;/strong&gt;</h1> -->
```

Para continuar inyectando HTML sin escapar, puedes usar `set:html`.

```astro del={1} ins={2}
<h1>{title}</h1>
<h1 set:html={title} />
```

Para evitar tener un elemento envolvente, `set:html` funciona en conjunto con `<Fragment>`.

```astro del={1} ins={2}
<h1>{title}!</h1>
<h1><Fragment set:html={title}>!</h1>
```

Tambi√©n puedes protegerte de inyecciones de HTML inesperadas con `set:text`.

```astro
<h1 set:text={title} /> <!-- <h1>Hola &lt;strong&gt;Mundo&lt;/strong&gt;</h1> -->
```

## Migrar a v0.21

### Vite

Desde la v0.21, Astro es construido usando [Vite].
Como resultado de esto, las configuraciones escritas en `snowpack.config.mjs` deben ser movidas a `astro.config.mjs`.

```js
// @ts-check

/** @type {import('astro').AstroUserConfig} */
export default {
  renderers: [],
  vite: {
    plugins: [],
  },
};
```

Para aprender m√°s sobre configuraciones de Vite, por favor visita su [gu√≠a de configuraci√≥n](https://vitejs.dev/config/).

#### Plugins de Vite

En Astro v0.21+, los plugins de Vite pueden ser configurados dentro de `astro.config.mjs`.

```js ins={4-6}
import { imagetools } from 'vite-imagetools';

export default {
  vite: {
    plugins: [imagetools()],
  },
};
```

Para aprender m√°s sobre plugins de Vite, por favor visita su [gu√≠a de plugins](https://vitejs.dev/guide/using-plugins.html).

#### Cambios en Vite sobre Renderers

En Astro v0.21+, los plugins deben usar `viteConfig()`.

```js del={8-9} ins={2,10-23}
// renderer-svelte/index.js
import { svelte } from '@sveltejs/vite-plugin-svelte';

export default {
  name: '@astrojs/renderer-svelte',
  client: './client.js',
  server: './server.js',
  snowpackPlugin: '@snowpack/plugin-svelte',
  snowpackPluginOptions: { compilerOptions: { hydratable: true } },
  viteConfig() {
    return {
      optimizeDeps: {
        include: ['@astrojs/renderer-svelte/client.js', 'svelte', 'svelte/internal'],
        exclude: ['@astrojs/renderer-svelte/server.js'],
      },
      plugins: [
        svelte({
          emitCss: true,
          compilerOptions: { hydratable: true },
        }),
      ],
    };
  },
}
```

Para aprender m√°s sobre plugins de Vite, por favor visita su [gu√≠a de plugins](https://vitejs.dev/guide/using-plugins.html).

:::note
En publicaciones anteriores, los plugins eran configurados usando `snowpackPlugin` o `snowpackPluginOptions`.
:::


### Alias

En Astro v0.21+, los alias en importaciones pueden ser a√±adidos en `tsconfig.json` o `jsconfig.json`.

```json add={4-6}
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/components/*": ["src/components/*"]
    }
  }
}
```

_Estos aliases se integrar√°n autom√°ticamente en [VSCode](https://code.visualstudio.com/docs/languages/jsconfig) y otros editores._

### Extensiones de Archivos en Importaciones

En Astro v0.21+, se debe referenciar a los archivos incluyendo su extensi√≥n, tal cual como est√°n en el disco. En este ejemplo, `Div.tsx` deber√≠a ser referenciado como `Div.tsx`, y no como `Div.jsx`.

```js del={1} ins={2}
import Div from './Div.jsx' // Astro v0.20
import Div from './Div.tsx' // Astro v0.21
```

Este mismo cambio aplica a archivos que se compilan a CSS, como `Div.scss`:

```astro del={1} ins={2}
<link rel="stylesheet" href={Astro.resolve('./Div.css')}>
<link rel="stylesheet" href={Astro.resolve('./Div.scss')}>
```

### Removido: Componentes en el Frontmatter

Antes, era posible crear mini componentes de Astro dentro del Frontmatter de Astro, utilizando sintaxis JSX en vez de sintaxis de componentes de Astro. Esto siempre fue un estilo de hack pero en el nuevo compilador se volvi√≥ imposible de dar soporte. Esperamos reintroducir esta caracter√≠stica en una publicaci√≥n futura de Astro usando una API diferente, que no sea JSX.

Para migrar a v0.21+, por favor convierte todos los componentes Astro en JSX (si es que tienes componentes de Astro creados dentro del frontmatter de otro componente) a componentes separados.


### Cambios en Estilos

#### Autoprefixer

Autoprefixer ya no es ejecutado por defecto. Para habilitarlo:

1. Instala la √∫ltima versi√≥n (`npm install autoprefixer`)
2. Crea un archivo `postcss.config.cjs` en la ra√≠z de tu proyecto con el siguiente contenido:
   ```js
   module.exports = {
     plugins: {
       autoprefixer: {},
     },
   };
   ```

#### Tailwind CSS

Aseg√∫rate de tener PostCSS instalado. Esto era opcional en versiones anteriores pero ahora es un requerimiento:

1. Instala la √∫ltima versi√≥n de postcss (`npm install -D postcss`)
2. Crea un archivo `postcss.config.cjs` en la ra√≠z de tu proyecto con el siguiente contenido:
   ```js
   module.exports = {
     plugins: {
       tailwindcss: {},
     },
   };
   ```
   Para m√°s informaci√≥n, lee la [documentaci√≥n de Tailwind CSS](https://tailwindcss.com/docs/installation#add-tailwind-as-a-post-css-plugin)


### Problemas conocidos

#### Imports en la parte superior

En Astro v0.21+, se ha introducido un bug que obliga a que las importaciones tengan que estar en la parte superior del frontmatter.

```astro
---
import Componente from '../componentes/Componente.astro'
const dondeDeboImportarComponentes = "en la parte superior!"
---
```


[vite]: https://vitejs.dev
