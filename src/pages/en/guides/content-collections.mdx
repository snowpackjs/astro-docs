---
layout: ~/layouts/MainLayout.astro
title: Content Collections
description: >-
  Content collections help organize your Markdown and type-check your
  frontmatter with schemas.
i18nReady: false
---
import FileTree from '~/components/FileTree.astro'
import Since from '~/components/Since.astro'
import TypeScriptSettingTabs from '~/components/tabs/TypeScriptSettingTabs.astro'



<p>
  <Since v="2.0.0" />
</p>

**Content collections** are a feature to help manage your Markdown and MDX files in Astro. A collection will organize your content, validate your frontmatter, and provide automatic TypeScript type-safety of fetched content. 

Content collections are the best way to work with Markdown and MDX in your project. For smaller projects, you can also [save your Markdown directly inside of the `src/pages/` directory.](/en/core-concepts/astro-pages/#markdownmdx-pages)

## What are Content Collections?

A **content collection** is any directory inside the reserved `src/content` project directory, such as `src/content/newsletter` and `src/content/blog`. Only content collections are allowed inside the `src/content` directory. This directory cannot be used for anything else.

Content collections help you organize the content files in your project. A content collection can contain any number of related Markdown (`.md`) or MDX (`.mdx`) files. These files within a collection are called **content entries.**

<FileTree>
- src/content/
  - **newsletter/** 
    - week-1.md
    - week-2.md
    - week-3.md
</FileTree>

Once you have a content collection in place with at least one content entry, you can query your content using Astro's built-in APIs.

### Creating a new content collection

To create a new content collection, add a new top-level directory to the `src/content/` folder of your project. If a `src/content` directory doesn't already exist in your project, create it.

Fill your collection directory with related Markdown and/or MDX files. Content collections work best when all files in the collection follow a similar frontmatter structure. If two files represent two different kinds of content (a blog post and an author profile, for example) they most likely belong in two different collections. 

<FileTree>
- src/content/
  - **newsletter/** 
    - week-1.md
    - week-2.md
    - week-3.md
  - **authors/** diffrent content types belong in different collections
    - grace-hopper.md
    - alan-turing.md
    - batman.md
</FileTree>

If your content frontmatter varies too wildly between files in a single collection, features like frontmatter validation and automatic TypeScript typings become less powerful. You can optionally define and enforce a required [frontmatter schema](#creating-a-collection-schema) across the entire collection.

### Organizing your collections with subdirectories

A content collection is *always* a top-level folder inside of the `src/content/` directory. You cannot nest one collection inside of another. However, you can use a nested subdirectory to organize your content within a collection. 

For example, you can use the following subdirectory structure to add international translations within a collection:

<FileTree>
- src/content/
  - docs/
    - en/
    - es/
    - ...
</FileTree>

## Configuration

Astro allows you to customize and configure your project's content collections through an optional `src/content/config.ts` file (`.js` and `.mjs` extensions are also supported). 

Currently, this file supports [creating a collection schema](#creating-a-collection-schema) and [defining custom unique slugs](#defining-custom-slugs) for your collections.

### Creating a collection schema

Schemas are an optional way to enforce consistent frontmatter within a collection. Without a schema, you have no way to guarantee that a frontmatter property actually exists when you go to reference it inside a page or component template.

To create a content collection schema, first create a `src/content/config.ts` file if one does not already exist (`.js` and `.mjs` extensions are also supported). This file should:

1. Import the proper utilities from `astro:content`. 
2. Define a schema for each collection you'd like to validate.
3. Export a single `collections` object to apply your schemas.

```ts
// src/content/config.ts
// 1. Import the proper utilities from `astro:content`
import { z, defineCollection } from 'astro:content';
// 2. Define a schema for each collection you'd like to validate.
const blogCollection = defineCollection({
  schema: z.object({
    title: z.string(),
    tags: z.array(z.string()),
    image: z.string().optional(),
  }),
});
// 3. Export a single `collections` object to register your collection(s)
export const collections = {
  'blog': blogCollection,
};
```

### Defining multiple collections

Astro supports working with multiple collections in a single project. 

```ts
// src/content/config.ts
// ...

// Export multiple collections to register them
export const collections = {
  'blog': blogCollection,
  'newsletter': newsletterCollection,
  'profile': profileCollection,
};
```

As your project grows, you are free to reorganize your codebase and move your schemas and collections out of the `src/content/config.ts` file. Your collections and schemas can live anywhere in your project, as long as they are imported into your `src/content/config.ts` file and and then re-exported from the `collections` object.

```ts
// src/content/config.ts
// 1. Import your schemas and utilities
import { defineCollection } from 'astro:content';
import {blogSchema, newsletterSchema} from '../schemas';
// 2. Define your collections
const blogCollection = defineCollection({ schema: blogSchema });
const newsletterCollection = defineCollection({ schema: newsletterSchema });
// 3. Export multiple collections to register them
export const collections = {
  'blog': blogCollection,
  'newsletter': newsletterCollection,
};
```

### Using third-party collection schemas

You are free to import schemas and collections from anywhere, including external npm packages. This can be useful when working with themes and libraries that provide their own collection schemas for you to use.


```ts
// src/content/config.ts
import {blogSchema} from 'my-blog-theme';
const blogCollection = defineCollection({ schema: blogSchema });
// Export the blog collection, using an external schema from 'my-blog-theme'
export const collections = {
  'blog': blogCollection,
};
```


### Defining datatypes with Zod

Astro leverages [Zod](https://github.com/colinhacks/zod) to create frontmatter schemas in the form of [Zod objects](https://github.com/colinhacks/zod#objects). With Zod, Astro is able to validate every file's frontmatter within a collection *and* provide automatic TypeScript types when you go to query content from inside your project.

To use Zod in Astro, import the `z` utility from `"astro:content"`. This is a re-export of the Zod library, and you are able to use all Zod features inside of Astro. See [Zodâ€™s README](https://github.com/colinhacks/zod) for complete documentation on how Zod works and what features are available.


```ts
// Example: A cheatsheet of many common Zod datatypes
import { z, defineCollection } from 'astro:content';

defineCollection({
  schema: z.object({
    isDraft: z.boolean(),
    title: z.string(),
    sortOrder: z.number(),
    image: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    author: z.string().default('Anonymous'),
    language: z.enum(['en', 'es']),
    tags: z.array(z.string()),
    // An optional frontmatter property. Very common!
    footnote: z.string().optional(),
    // Convert a standard date-string into a `Date` object
    publishDate: z.string().transform(str => new Date(str)),
    // Advanced: Validate that the string is also an email
    authorContact: z.string().email(),
    // Advanced: Validate that the string is also a URL
    canonicalURL: z.string().url(),
  })
})
```

### Defining custom slugs

Astro will generate a unique `slug` value for each content entry. By default, a content entry's `slug` is based on its `id` (its filename).

To customize this value, provide a `slug()` function in `defineCollection()`. Your `slug()` function can override the default slug with a custom value of your choosing.

```ts {4-6}
// Example: Override the default entry slug with the 
// "permalink" frontmatter property, if it exists.
const blog = defineCollection({
  slug: ({ id, defaultSlug, data, body }) => {
    return data.permalink || defaultSlug;
  },
});
```


### Setting up TypeScript for content collections

To benefit from the full TypeScript and autocompletion features of [using schemas with your collections](#creating-a-collection-schema), you may need to update your `tsconfig.json` to enable `strictNullChecks`.

```json title="tsconfig.json" ins={3}
{
  "compilerOptions": {
    "strictNullChecks": true
  }
}
```

Note that if you are currently extending Astro's `strict` or `strictest` recommended settings, no changes is needed.

```json title="tsconfig.json" "strict" "strictest"
{
  // No change needed!
  "extends": "astro/tsconfigs/strict"
}
```

### The ".astro" Directory

Astro generates type information and metadata from your content collections in a new `.astro` directory. No action is needed on your part to maintain or update this directory. It is safe to ignore it in your project.

:::tip
If you're using Git for version control, we recommend ignoring this generated directory by adding `.astro` to your `.gitignore`.
:::

The `.astro` directory will be updated for you automatically anytime you run the [`astro dev`](/en/reference/cli-reference/#astro-dev), [`astro build`](/en/reference/cli-reference/#astro-build) commands. You can run [`astro sync`](/en/reference/cli-reference/#astro-sync) yourself to update `.astro` manually.


## The "src/content" Directory

Astro treats the `src/content/` directory as special. This is where **collections** (folders) of Markdown/MDX **entries** (files) can be stored, with a single configuration file to define each collection's **schema** (frontmatter data types and shape). Files other than your `.md`/`.mdx` content are not permitted inside `src/content/`.


## Querying Collections

Astro provides two functions to query a collection and return one (or more) content entries from it: [`getCollection()`](/en/reference/api-reference/#getcollection) and [`getEntryBySlug()`](/en/reference/api-reference/#getentrybyslug).

```js
import { getCollection, getEntryBySlug } from 'astro:content';
// Get all entries from a collection. Requires the name of the collection as an argument.
const allBlogPosts = await getCollection('blog');
// Get a single entry from a collection. Requires the name of the collection and the entry's slug as arguments.
const oneBlogPost = await getEntryBySlug('blog', 'enterprise');
```

#### Filtering collection queries

`getCollection` takes an optional "filter" callback that allows you to filter your query based on an entry's `id`, `slug`, or `data` (frontmatter) properties.

You can use this to filter by any content criteria you like. For example, you can filter by frontmatter properties like `draft` to prevent any draft blog posts from publishing to your blog:

```js
// Example: Filter content entries with `draft: true` frontmatter
import { getCollection } from 'astro:content';
const draftBlogEntries = await getCollection('blog', ({ data }) => {
  return data.draft !== true;
});
```

The filter argument also supports filtering by nested directories within a collection. Since the `id` includes the full nested path, you can filter by the start of each `id` to only return items from a specific nested directory:

```js
// Example: Filter entries by sub-directory in the collection
import { getCollection } from 'astro:content';
const englishDocsEntries = await getCollection('docs', ({ id }) => {
  return id.startsWith('en/');
});
```

### Using content in Astro templates

Once you have queried your collection entries, you can use those entries to render information about your content. You can access each entry directly inside of your Astro component template. This lets you to render HTML for things like links to your content (using the content `slug`) or information about your content (using the `data` property).

For information about rendering your content to HTML, see [Rendering Content to HTML](/en/guides/content-collections/#rendering-content-to-html) below.

```astro
---
// src/pages/index.astro
import { getCollection } from 'astro:content';
const blogEntries = await getCollection('blog');
---
<ul>
  {blogEntries.map(blogPostEntry => (
    <li>
      <a href={`/my-blog-url/${blogPostEntry.slug}`}>{blogPostEntry.data.title}</a>
      <time datetime={blogPostEntry.data.publishedDate.toISOString()}>
        {blogPostEntry.data.publishedDate.toDateString()}
      </time>
    </li>
  ))}
</ul>
```

### Passing content as props

A component can also pass an entire content entry as a prop. 

If you do this, you can use the `CollectionEntry` utility to correctly type your components props using TypeScript.  This utility takes a string argument that matches the name of your collection schema, and will inherit all of the properties of that collection's schema.

```astro /CollectionEntry(?:<.+>)?/
---
// src/components/BlogCard.astro
import type { CollectionEntry } from 'astro:content';
interface Props {
  post: CollectionEntry<'blog'>;
}

// `post` will match your 'blog' collection schema type
const { post } = Astro.props;
---
```

## Rendering Content to HTML

Once queried, you can render a collection entry to HTML using the entry `render()` function property. Calling this function gives you access to rendered content and metadata, including both a `<Content />` component and a list of all rendered headings.

```astro {5}
---
// src/pages/render-example.astro
import { getEntryBySlug } from 'astro:content';
const entry = await getEntryBySlug('blog', 'post-1');
const { Content, headings } = await entry.render();
---
<p>Written by: {entry.data.author}</p>
<Content />
```


### Advanced: Modifying frontmatter with remark

:::caution
Remark and rehype plugins access the _raw_ Markdown or MDX document frontmatter. This means that `remarkPluginFrontmatter` frontmatter is handled seperately from your type-safe `schema`, and will not reflect any changes or defaults applied through Astro. Use at your own risk!
:::

While not recommended, Astro allows you to [modify frontmatter directly](/en/guides/markdown-content/#modifying-frontmatter-programmatically) using remark or rehype plugins. You can access this modified frontmatter within Content Collections by using the `remarkPluginFrontmatter` property returned from `render()`:

```astro "{ remarkPluginFrontmatter }"
---
import { getEntryBySlug } from 'astro:content';
const blogPost = await getEntryBySlug('blog', 'post-1');
const { remarkPluginFrontmatter } = await blogPost.render();
---
<!-- 
  This example assumes `readingTime` was injected by a remark plugin.
  See our "reading time" example for more details:
  https://docs.astro.build/en/guides/markdown-content/#example-calculate-reading-time
-->
<p>{blogPost.data.title} â€” {remarkPluginFrontmatter.readingTime}</p>
```

<details>
<summary>**ðŸ™‹ Why don't `getCollection()` and `getEntryBySlug()` contain these values?**</summary>

The remark and rehype pipelines are only run when your content is **rendered.** This lets `render()` access anything generated by these plugins like injected frontmatter. To stay performant, `getCollection()` and `getEntryBySlug()` do not have this capability.

</details>


## Generating Routes from Content

Because content collections live outside of the `src/pages` directory, its up to you to create your [dynamic routes](/en/core-concepts/routing/#dynamic-routes) that will render your content and any collection entries to HTML.

The way that you generate routes in Astro depends on your build [`output`](/en/reference/configuration-reference/#output) mode: 'static' (the default) or 'server' (for SSR).

### Building for static output (default)

If you are building a static website (Astro's default behavior), you are expected use Astro's [`getStaticPaths()`](/en/reference/api-reference/#getstaticpaths) to create multiple routes from the same `src/pages` component at build-time.

Inside of `getStaticPaths()`, you would call [`getCollection()`](/en/reference/api-reference/#getcollection) to query your content entries and then create all of the static paths you need using the `slug` parameter for each page. 

```astro "{ slug: entry.slug }"
---
// src/pages/posts/[slug].astro
import { getCollection } from 'astro:content';
// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
  const blogEntries = await getCollection('blog');
  return blogEntries.map(entry => ({
    params: { slug: entry.slug }, props: { entry },
  }));
}
// 2. When its time to render, you can get the entry directly from the prop
const { entry } = Astro.props;
const { Content } = await entry.render();
---
<h1>{entry.data.title}</h1>
<Content />
```

This will generate a new page for every entry in the `blog` collection. For example, an entry at `src/content/blog/hello-world.md` will have a slug of `hello-world`, and therefore its final URL will be `/posts/hello-world/`.

### Building for server output (SSR)

If you are building a dynamic website (using Astro's SSR support), you are not expected to generate any paths ahead-of-time during the build. Instead, your page should examine the request (using `Astro.request` or `Astro.params`) to find the `slug` on-demand, and then fetch it using [`getEntryBySlug()`](/en/reference/api-reference/#getentrybyslug). 


```astro "{ slug: Astro.params }"
---
// src/pages/posts/[slug].astro
// NOTE: This example will only work in 
import { getEntryBySlug } from 'astro:content';
// 1. Get the slug from the request, on-demand
const { slug } = Astro.params;
// 2. Query the entry directly using its slug
const entry = await getEntryBySlug('blog', slug);
// 3. (Optional) render the entry to HTML in the template
const { Content } = await entry.render();
---
<h1>{entry.data.title}</h1>
<Content />
```
