---
layout: ~/layouts/MainLayout.astro
title: Endpunkte
description: Erfahre wie du Endpunkte erstellen kannst, die jegliche Form von Daten bereitstellen
---

Astro lässt Dich unterschiedliche projektspezifische Endpunkte erstellen, die jegliche Form von Daten bereitstellen können. Du kannst sie verwenden um Bilder zu generieren, ein RSS-Dokument bereitzustellen oder sie als API-Route verwenden um eine komplette API für Deine Seite bereitzustellen.

In statisch generierten Seiten werden die projektspezifischen Endpunkte zum Erstellungszeitpunkt abgerufen. Wenn du den [SSR](/de/guides/server-side-rendering/)-Modus verwendest, verhalten sich die projektspezifischen Endpunkte wie "echte" API-Endpunkte, die bei jedem Request ausgeführt werden. Statische und SSR-Endpunkte werden auf ähnliche Weise definiert, aber SSR-Endpunkte bieten mehr Optionen.

## Endpunkte für statische Dateien

Um einen Endpunkt zu erstellen, füge eine `.js` oder `.ts`-Datei dem `/pages`-Verzeichnis hinzu. Die Erweiterung `.js` oder `.ts` wird während des Erstellungsprozesses entfernt, so dass der Dateiname die Dateiendung der Daten, die man erzeugen möchte, enthalten sollte. So erzeugt `src/pages/data.json.ts` zum Beispiel den Endpunkt `/data.json`.

Endpunkte exportieren eine `get`-Funktion (optional auch mit `async` Auszeichnung), welche ein [Context-Objekt](/en/reference/api-reference/#endpoint-context) als Parameter übergeben bekommt. Die Inhalte sind ähnlich zu globalen `Astro`-Variable. Die Funktion gibt ein Dokument mit `body`-Objekt zurück, welches Astro zum Erstellungszeitpunkt aufruft. Die Inhalte des Dokuments werden dann zur Erstellung der Datei genutzt.

```ts
// Beispiel: src/pages/builtwith.json.ts
// Ausgabe: /builtwith.json
export async function get({params, request}) {
  return {
    body: JSON.stringify({
      name: 'Astro',
      url: 'https://astro.build/',
    }),
  };
}
```

Das Rückgabe-Objekt kann auch eine `encoding`-Eigenschaft enthalten. Es kann jede gültige [`BufferEncoding`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/bdd02508ddb5eebcf701fdb8ffd6e84eabf47885/types/node/buffer.d.ts#L169) sein, welches von der Node.js' `fs.writeFile`-Methode unterstützt wird. Um zum Beispiel ein binäres PNG-Bild zu erzeugen:


```ts title="src/pages/astro-logo.png.ts" {6}
export async function get({ params, request }) {
  const response = await fetch("https://astro.build/assets/press/full-logo-light.png");
  const buffer = Buffer.from(await response.arrayBuffer());
  return {
    body: buffer,
    encoding: 'binary',
  };
}
```

Du kannst deine Endpunkt-Funktion auch mit dem `APIRoute` Type typisieren:

```ts
import type { APIRoute } from 'astro';

export const get: APIRoute = async function get ({params, request}) {
...
```

## `params` und dynamische Routen

Endpunkte unterstützen das gleiche [dynamische Routing](/de/core-concepts/routing/#dynamic-routes) wie Seiten. Benenne deine Datei mit einem Parameternamen, eingeschlossen in eckige Klammern und exportiere eine Funktion mit dem Namem [`getStaticPaths()`](/en/reference/api-reference/#getstaticpaths). Dann kannst du auf den Parameter mittels der `params`-Eigenschaft zugreifen, die die Funktion des Endpunkts entgegennimmt:

```ts title="src/pages/[id].json.ts"
import type { APIRoute } from 'astro';

const usernames = ["Sarah", "Chris", "Dan"]

export const get: APIRoute = ({ params, request }) => {
  const id = params.id;
  return {
    body: JSON.stringify({
      name: usernames[id]
    })
  }
};

export function getStaticPaths () {
  return [ 
    { params: { id: "0"} },
    { params: { id: "1"} },
    { params: { id: "2"} },
  ]
}
```

Dies generiert drei JSON-Endpunkte zum Bereitstellungszeitpunkt: `/api/1.json`, `/api/2.json`, `/api/3.json`. Dynamisches Routing funktioniert genauso wie es bei den Seiten funktioniert, aber da der Endpunkt eine Funktion ist und keine Komponente werden [props](/de/reference/api-reference/#data-passing-with-props) nicht unterstützt.

### `request`

Alle Endpunkte nehmen eine `request`-Eigenschaft entgegen, allerdings hast du im statischen Modus nur Zugriff auf `request.url`. Diese enthält die komplette URL des aktuellen Endpunkts und funktioniert genauso wie [Astro.request.url](/de/reference/api-reference/#astrorequest) bei Seiten.

```ts title="src/pages/request-path.json.ts"
import type { APIRoute } from 'astro';

export const get: APIRoute = ({ params, request }) => {
  return {
    body: JSON.stringify({
      path: new URL(request.url).pathname
    })
  };
}
```

## Server Endpunkte (API-Routen)
Alles was bei den Endpunkten für statische Dateien beschrieben wurde, kann auch im SSR-Modus verwendet werden: Dateien können eine `get`-Funktion exportieren, die ein [Context-Objekt](/en/reference/api-reference/#endpoint-context) mit ähnlichen Eigenschaften wie die globale `Astro`-Variable entgegennimmt.

Aber wenn der `server`-Modus konfiguriert ist werden die Daten zusammengestellt, wenn sie angefragt werden, anders als im `static`-Modus. Das ermöglicht Zugriff ein paar neue Funktionen, die zum Erstellungszeitpunkt nicht verfügbar sind. Diese erlauben es dir, API-Routen zu erstellen, die auf Anfragen warten und Code in einer sicheren Server-Umgebung ausführen, wenn der Server läuft.

:::note
Stell sicher, dass du [SSR aktivierst](/de/guides/server-side-rendering/#enabling-ssr-in-your-project) bevor du diese Beispiele ausprobierst.
:::

Server-Endpunkte könenn auf `params` zugreifen ohne `getStaticPaths` zu exportieren und sie können ein [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)-Objekt zurückgeben, was es ermöglicht, Status codes und Header zu setzen.


```js title="src/pages/[id].json.js"
import { getProduct } from '../db';

export async function get({ params }) {
  const id = params.id;
  const product = await getProduct(id);

  if (!product) {
    return new Response(null, {
      status: 404,
      statusText: 'Not found'
    });
  }

  return new Response(JSON.stringify(product), {
    status: 200,
    headers: {
      "Content-Type": "application/json"
    }
  });
}
```

Das wird jede Anfrage beantworten, der die dynamische Route matcht. Wenn wir zum Beispiel zu `/helmet.json` navigieren, wird `params.id` den Wert `helmet` haben. Wenn in der Produktdatenbank `helmet` existiert, wird der der Endpunkt ein `Response`-Objekt erzeugen um mit JSON und einem erfolgreichen [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/API/Response/status) antworten. Anderenfalls wird ein `Response`-Objekt genutzt, um mit einem `404` zu antworten.

### HTTP-Methoden

Zusätzlich zu der `get`-Funktion kannst du Funktionen mit den Namen aller möglichen [HTTP-Methoden](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) exportieren. Wenn eine Anfrage ankommt, wird Astro die Methode prüfen und die entsprechende Funktion aufrufen.

Du kannst auch eine Funktion `all` exportieren, die alle Methoden abdeckt, die keine eigene Funktion haben. Wenn eine Anfrage ohne passende Methode ankommt, wird man zur [404-Seite](/de/core-concepts/astro-pages/#custom-404-error-page) weitergeleitet.

:::note
Da `delete` in JavaScript ein reserviertes Wort ist, exportiere eine `del`-Funktion um die `delete`-Methode abzubilden.
:::

```ts title="src/pages/methods.json.ts"
export const get: APIRoute = ({ params, request }) => {
  return {
    body: JSON.stringify({
      message: "Das war ein GET!"
    })
  }
};

export const post: APIRoute = ({ request }) => {
  return {
    body: JSON.stringify({
      message: "Das war ein POST!"
    })
  }
}

export const del: APIRoute = ({ request }) => {
  return {
    body: JSON.stringify({
      message: "Das war ein DELETE!"
    })
  }
}

export const all: APIRoute = ({ request }) => {
  return {
    body: JSON.stringify({
      message: `Das war ein ${request.method}!`
    })
  }
}
```

### `request`

Im `SSR`-Modus gibt die `request`-Eigenschaft ein vollwertiges [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)-Objekt zurück, welches den aktuellen Request enthält. Das erlaubt dir, Daten entgegenzunehmen und Header zu überprüfen.

```ts title="src/pages/test-post.json.ts"
export const post: APIRoute = async ({ request }) => {
  if (request.headers.get("Content-Type") === "application/json") {
    const body = await request.json();
    const name = body.name;
    return new Response(JSON.stringify({
      message: "Dein Name war: " + name
    }), {
      status: 200
    })
  }
  return new Response(null, { status: 400 });
}
```

### Umleitungen

Der Endpunkt-Kontext exportiert einen `redirect`-Helfer, ähnlich wie `Astro.redirect`:

```js title="src/pages/links/[id].js" {14}
import { getLinkUrl } from '../db';

export async function get({ params, redirect }) {
  const { id } = params;
  const link = await getLinkUrl(id);

  if (!link) {
    return new Response(null, {
      status: 404,
      statusText: 'Not found'
    });
  }

  return redirect(link, 307);
}
```


### Beispiel: Ein Captcha verifizieren

Server-Endpunkte können als REST API Endpunkte genutzt werden um Funktionen wie Authentisierung, Datenbankzugriffe oder Verifizierungen durchzuführen, ohne sensible Informationen an den Client zu übermitteln.

Im Beispiel unten wird eine API-Route genutzt, um ein Google reCAPTCHA v3 zu verifizieren, ohne das Kennwort an Clients herauszugeben.

Auf dem Server implementieren wir eine POST-Methode, die die Daten von reCAPTCHA entgegennimmt. Hier können wir sicher geschützte Passwörter definieren oder Umgebungsvariablen auslesen.

```js title="src/pages/recaptcha.js"
export async function post({ request }) {
  const data = await request.json();

  const recaptchaURL = 'https://www.google.com/recaptcha/api/siteverify';
  const requestBody = {
    secret: "YOUR_SITE_SECRET_KEY",   // Dies kann eine Umgebungsvariable sein
    response: data.recaptcha          // Dieses Token wird vom Client gesendet
  };

  const response = await fetch(recaptchaURL, {
    method: "POST",
    body: JSON.stringify(requestBody)
  });

  const responseData = await response.json();

  return new Response(JSON.stringify(responseData), { status: 200 });
}
```

Damit können wir unseren Endpunkt mittels `fetch` im Client abrufen:


```astro title="src/pages/index.astro"
<html>
  <head>
    <script src="https://www.google.com/recaptcha/api.js"></script>
  </head>

  <body>
    <button class="g-recaptcha" 
      data-sitekey="PUBLIC_SITE_KEY" 
      data-callback="onSubmit" 
      data-action="submit"> Klick mich um das Capcha zu verifizieren.
    <script is:inline>
      function onSubmit(token) {
        fetch("/recaptcha", {
          method: "POST",
          body: JSON.stringify({ recaptcha: token })
        })
        .then((response) => response.json())
        .then((gResponse) => {
          if (gResponse.success) {
            // Captcha verification was a success
          } else {
            // Captcha verification failed
          }
        })
      }
    </script>
  </body>
</html>
```
