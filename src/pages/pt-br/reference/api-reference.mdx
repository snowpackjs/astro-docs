---
layout: ~/layouts/MainLayout.astro
title: Refer√™ncia da API
i18nReady: true
---
import Since from '~/components/Since.astro';
import Tabs from '../../../components/tabs/Tabs';



## Global `Astro`

A global `Astro` est√° dispon√≠vel em todos os contextos em arquivos `.astro`. Ela tem as seguintes fun√ß√µes:

### `Astro.glob()`

`Astro.glob()` √© uma forma de carregar v√°rios arquivos locais em seu site est√°tico.

```astro
---
// ./src/components/meu-componente.astro
const postagens = await Astro.glob('../pages/postagens/*.md'); // retorna um array de postagens que est√£o em ./src/pages/postagens/*.md
---

<div>
{postagens.slice(0, 3).map((postagem) => (
  <article>
    <h1>{postagem.frontmatter.titulo}</h1>
    <p>{postagem.frontmatter.descricao}</p>
    <a href={postagem.frontmatter.url}>Leia mais</a>
  </article>
))}
</div>
```

`.glob()` recebe apenas um par√¢metro: uma URL relativa dos arquivos locais que voc√™ gostaria de importar. Ela √© ass√≠ncrona e retorna um array das exporta√ß√µes dos arquivos correspondentes.

`.glob()` n√£o pode receber vari√°veis ou strings que s√£o interpoladas j√° que n√£o s√£o estaticamente analis√°veis. (Veja [o guia de solu√ß√£o de problemas](/pt-br/guides/troubleshooting/#valores-suportados) para uma solu√ß√£o alternativa.) Isso acontece pois `Astro.glob()` √© feito em cima do [`import.meta.glob()`](https://vitejs.dev/guide/features.html#glob-import) do Vite.

:::note
Voc√™ tamb√©m pode usar `import.meta.glob()` em si em seu projeto Astro. Voc√™ pode querer fazer isso quando:
- Voc√™ precisa dessa funcionalidade em um arquivo que n√£o √© `.astro`, como uma rota de API. `Astro.glob()` √© apenas dispon√≠vel em arquivos `.astro`, enquanto `import.meta.glob()` est√° dispon√≠vel em qualquer parte do projeto.
- Voc√™ n√£o quer carregar cada arquivo imediatamente. `import.meta.glob()` pode retornar fun√ß√µes que importam o conte√∫do do arquivo, ao inv√©s de retornar o conte√∫do em si.
- Voc√™ quer acessar o caminho de cada arquivo. `import.meta.glob()` retorna um map do caminho do arquivo ao seu conte√∫do, enquanto `Astro.glob()` retorna uma lista de conte√∫do.
- Voc√™ quer passar m√∫ltiplos padr√µes; por exemplo, voc√™ quer adicionar um "padr√£o negativo" que remove certos arquivos filtrados. `import.meta.glob()` pode opcionalmente receber um array de strings blog, ao inv√©s de uma √∫nica string.

Leia mais sobre na [documenta√ß√£o do Vite](https://vitejs.dev/guide/features.html#glob-import).
:::

#### Arquivos Markdown

Arquivos Markdown tem a seguinte interface:

```ts
export interface MarkdownInstance<T extends Record<string, any>> {
  /* Quaisquer dados especificados no frontmatter YAML deste arquivo */
	frontmatter: T;
  /* O caminho do arquivo deste arquivo */
	file: string;
  /* O caminho renderizado deste arquivo */
	url: string | undefined;
  /* Componente Astro que renderiza os conte√∫dos deste arquivo */
	Content: AstroComponent;
  /* Fun√ß√£o que retorna um array de elementos h1...h6 deste arquivo */
	getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;
}
```
  
Voc√™ pode opcionalmente oferecer um tipo para a vari√°vel `frontmatter` utilizando um generic do TypeScript.

```astro
---
interface Frontmatter {
  titulo: string;
  descricao?: string;
}
const postagens = await Astro.glob<Frontmatter>('../pages/postagens/*.md');
---

<ul>
  {postagens.map(postagem => <li>{postagem.frontmatter.titulo}</li>)}
</ul>
```

### `Astro.props`

`Astro.props` √© um objeto contendo quaisquer valores que foram passados como [atributos do componente](/pt-br/core-concepts/astro-components/#props-do-componente). Componentes de Layout para arquivos `.md` e `.mdx` recebem valores frontmatter como props.

```astro {3}
---
// ./src/components/Titulo.astro
const { titulo, data } = Astro.props;
---
<div>
    <h1>{titulo}</h1>
    <p>{data}</p>
</div>
```

```astro /titulo=".+"/ /data=".+"/
---
// ./src/pages/index.astro
import Titulo from '../components/Titulo.astro';
---
<Titulo titulo="Minha Primeira Postagem" data="09 Ago 2022" />
```

üìö Aprenda mais sobre como [Layouts Markdown e MDX](/pt-br/guides/markdown-content/#frontmatter-layout) lidam com props.

üìö Aprenda mais sobre como adicionar [defini√ß√µes de tipo do TypeScript para suas props](/pt-br/guides/typescript/#props-de-componentes).

#### Arquivos Astro

Arquivos Astro tem a seguinte interface:

```ts
export interface AstroInstance {
	default: AstroComponent;
}
```

#### Outros Arquivos

Outros arquivos podem ter v√°rias diferentes interfaces, mas `Astro.glob()` aceita um generic do TypeScript se voc√™ souber exatamente o que o tipo de um arquivo desconhecido cont√©m.

```ts
---
interface DadosCustomizadosArquivo {
  default: Record<string, any>;
}
const dados = await Astro.glob<DadosCustomizadosArquivo>('../dados/**/*.js');
---
```

### `Astro.request`

`Astro.request` √© um objeto [Request](https://developer.mozilla.org/pt-BR/docs/Web/API/Request) padr√£o. Ele pode ser utilizado para obter a `url`, `headers`, `method` e at√© mesmo o body de uma requisi√ß√£o.

```astro
<p>Recebido uma requisi√ß√£o {Astro.request.method} para "{Astro.request.url}".</p>
<p>Headers da requisi√ß√£o recebidos: <code>{JSON.stringify(Object.fromEntries(Astro.request.headers))}</code>
```

Veja tamb√©m: [`Astro.url`](#astrourl)

:::note
Com a op√ß√£o padr√£o `output: 'static'`, `Astro.request.url` n√£o cont√©m par√¢metros de pesquisa, como `?foo=bar`, j√° que n√£o √© poss√≠vel determin√°-los com anteced√™ncia durante builds est√°ticas. Por√©m, no modo `output: 'server'`, `Astro.request.url` cont√©m par√¢metros de busca j√° que podem ser determinados pela requisi√ß√£o do servidor.
:::

### `Astro.response`

`Astro.response` √© um objeto [ResponseInit](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#init) padr√£o. Ele pode ser utilizado para definir o `status`, `statusText` e `headers` para a resposta de uma p√°gina.

```astro
---
if(condicao) {
  Astro.response.status = 404;
  Astro.response.statusText = 'N√£o encontrado';
}
---
```

Ou para definir um header:

```astro
---
Astro.response.headers.set('Set-Cookie', 'a=b; Path=/;');
---
```

### `Astro.canonicalURL`

:::caution[Descontinuado]
Utilize [`Astro.url`](#astrourl) para construir sua pr√≥pria URL can√¥nica.
:::

A [URL can√¥nica][canonical] da p√°gina atual.

### `Astro.url`

<Since v="1.0.0-rc" />

Um objeto [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) constru√≠do a partir do valor da string URL atual do `Astro.request.url`. √ötil para interagir com propriedades individuais da URL da requisi√ß√£o, como o nome do caminho e origem. 

Equivalente a fazer `new URL(Astro.request.url)`. 

```astro
<h1>A URL atual √©: {Astro.url}</h1>
<h1>O nome do caminho da URL atual √©: {Astro.url.pathname}</h1>
<h1>A origem da URL atual √©: {Astro.url.origin}</h1>
```

Voc√™ tamb√©m pode usar `Astro.url` para criar novas URLs a passando como um argumento em [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).

```astro
---
// Exemplo: Construa uma URL can√¥nica usando seu dom√≠nio em produ√ß√£o
const URLCanonica = new URL(Astro.url.pathname, Astro.site);
// Exemplo: Construa uma URL para tags meta SEO usando seu dom√≠nio atual
const URLImagemSocial = new URL('/imagens/preview.png', Astro.url);
---
<link rel="canonical" href={URLCanonica} />
<meta property="og:image" content={URLImagemSocial} />
```

### `Astro.clientAddress`

<Since v="1.0.0-rc" />

Especifica o [endere√ßo de IP](https://en.wikipedia.org/wiki/IP_address) da requisi√ß√£o. Esta propriedade √© apenas dispon√≠vel ao fazer build para SSR (renderiza√ß√£o no lado do servidor) e n√£o deve ser usado em sites est√°ticos.

```astro
---
const ip = Astro.clientAddress;
---
<div>Your IP address is: <span class="address">{ ip }</span></div>
```

### `Astro.site`

`Astro.site` retorna a `URL` feita a partir do `site` na sua configura√ß√£o do Astro. Se for `undefined`, isso ir√° retornar uma URL gerada a partir de `localhost`.

### `Astro.generator`

<Since v="1.0.0" />

`Astro.generator` √© uma forma conveniente de adicionar uma tag [`<meta name="generator">`](https://html.spec.whatwg.org/multipage/semantics.html#meta-generator) na sua vers√£o atual do Astro. Ela segue o formato `"Astro v1.x.x"`.

```astro mark="Astro.generator"
<html>
  <head>
    <meta name="generator" content={Astro.generator} />
  </head>
  <body>
    <footer>
      <p>Constru√≠do com <a href="https://astro.build">{Astro.generator}</a></p>
    </footer>
  </body>
</html>
```


### `Astro.slots`

`Astro.slots` cont√©m fun√ß√µes utilit√°rias para modificar os filhos em slots de um componente Astro.


| Nome           | Tipo                                              | Descri√ß√£o                                        |
| :------------- | :------------------------------------------------ | :------------------------------------------------- |
| `has`          | `(name: string) => boolean`                       | Se o conte√∫do para o slot com esse nome existe          |
| `render`       | `(name: string, args?: any[]) => Promise<string>` | Renderiza esse slot de forma ass√≠ncrona e retorna HTML   |

```astro
---
let html: string = '';
if (Astro.slots.has('default')) {
  html = await Astro.slots.render('default')
}
---
<Fragment set:html={html} />
```

### `Astro.self`

`Astro.self` permite que componentes Astro sejam recursivamente invocados. Este comportamento te permite renderizar um componente Astro em si mesmo utilizando `<Astro.self>` no template do componente. Isto pode ser √∫til para iterar sobre grandes cole√ß√µes e estruturas de dados aninhadas. 

```astro
---
// ListaAninhada.astro
const { itens } = Astro.props;
---
<ul class="lista-aninhada">
{itens.map((item) => (
    <li>
      <!-- Se houver uma estrutura de dados aninhada n√≥s renderizamos `<Astro.self>` -->
      <!-- e podemos passar props atrav√©s de uma invoca√ß√£o recursiva -->
      {Array.isArray(item) ? (
        <Astro.self items={item} />
      ) : (
        item
      )}
    </li>
  ))}
</ul>
```

Este componente pode ser utilizado assim:

```astro
---
import ListaAninhada from './ListaAninhada.astro';
---
<ListaAninhada itens={['A', ['B', 'C'], 'D']} />
```

E renderizaria HTML assim:

```html
<ul class="lista-aninhada">
  <li>A</li>
  <li>
    <ul class="lista-aninhada">
      <li>B</li>
      <li>C</li>
    </ul>
  </li>
  <li>D</li>
</ul>
```

## `getStaticPaths()`

Se uma p√°gina utiliza par√¢metros din√¢micos em seu nome de arquivo, tal componente precisar√° exportar uma fun√ß√£o `getStaticPaths()`.

Esta fun√ß√£o √© necess√°ria pois Astro √© um gerador de sites est√°ticos. Isso significa que o seu site inteiro √© constru√≠do previamente. Se Astro n√£o sabe como gerar uma p√°gina em tempo de build, seus usu√°rios n√£o o ir√£o ver quando visitarem o seu site.

```astro
---
export async function getStaticPaths() {
  return [
    { params: { /* obrigat√≥rio */ }, props: { /* opcional */ } },
    { params: { ... } },
    { params: { ... } },
    // ...
  ];
}
---
<!-- O seu template HTML aqui. -->
```

A fun√ß√£o `getStaticPaths()` deve retornar um array de objetos para determinar quais caminhos ser√£o pr√©-renderizados pelo Astro.

:::caution
A fun√ß√£o `getStaticPaths()` √© executada em seu pr√≥prio escopo isolado unicamente, antes de qualquer p√°gina carregar. Portanto voc√™ n√£o pode referenciar nada de seu escopo parente al√©m de importa√ß√µes de arquivos. O compilador ir√° te avisar se voc√™ quebrar esse requisito.
:::

### `params`

A chave `params` de todos os objetos retornados diz ao Astro quais rotas construir. Os par√¢metros retornados devem ser mapeados de volta para os par√¢metros din√¢micos e rest definidos no caminho de arquivo do seu componente.

`params` s√£o codificados na URL, ent√£o apenas strings e n√∫meros s√£o suportados como valores. O valor para cada objeto `params` deve corresponder aos par√¢metros utilizados no nome da p√°gina.

Por exemplo, suponha que voc√™ tem uma p√°gina em `src/pages/postagens/[id].astro`. Se voc√™ exportar `getStaticPaths` dessa p√°gina e retornar os seguintes caminhos:

```astro
---
export async function getStaticPaths() {
  return [
    { params: { id: '1' } },
    { params: { id: '2' } },
    { params: { id:  3 } } // Pode ser um n√∫mero tamb√©m!
  ];
}

const { id } = Astro.params;
---
<h1>{id}</h1>
```

Ent√£o Astro ir√° estaticamente gerar `postagens/1,`, `postagens/2`, e `postagens/3` em tempo de build.

### Passagem de Dados com `props`

Para passar dados adicionais para cada p√°gina gerada, voc√™ tamb√©m pode definir um valor a `props` para cada objeto de caminho retornado. Diferente de `params`, `props` n√£o s√£o codificadas na URL, ent√£o n√£o est√£o limitadas a apenas strings.

Por exemplo, supomos que voc√™ gera p√°ginas baseando-se em dados buscados a partir de uma API remota. Voc√™ pode passar o objeto inteiro dos dados para o componente da p√°gina dentro de `getStaticPaths`:

```astro
---
export async function getStaticPaths() {
  const dados = await fetch('...').then(resposta => resposta.json());

  return dados.map((postagem) => {
    return {
      params: { id: postagem.id },
      props: { postagem },
    };
  });
}

const { id } = Astro.params;
const { postagem } = Astro.props;
---
<h1>{id}: {postagem.nome}</h1>
```

Voc√™ tamb√©m pode passar um array normal, que pode ser √∫til quando for gerar ou esbo√ßar uma lista conhecida de rotas.

```astro
---
export async function getStaticPaths() {
  const postagens = [
    {id: '1', categoria: "astro", titulo: "Refer√™ncia da API"},
    {id: '2', categoria: "react", titulo: "Criando um contador com React!"}
  ];
  return postagens.map((postagem) => {
    return {
      params: { id: postagem.id },
      props: { postagem }
    };
  });
}
const {id} = Astro.params;
const {postagem} = Astro.props;
---
<body>
  <h1>{id}: {postagem.titulo}</h1>
  <h2>Categoria: {postagem.categoria}</h2>
</body>
```

Ent√£o Astro ir√° estaticamente gerar `postagens/1` e `postagens/2` em tempo de build utilizando o componente da p√°gina em `pages/postagens/[id].astro`. A p√°gina pode referenciar esses dados utilizando `Astro.props`:

### `paginate()`

Pagina√ß√£o √© um caso de uso comum para websites que Astro nativamente suporta atrav√©s da fun√ß√£o `paginate()`. `paginate()` ir√° automaticamente gerar o array para retornar de `getStaticPaths()` que cria uma URL para cada p√°gina da cole√ß√£o paginada. O n√∫mero da p√°gina ser√° passado como um par√¢metro, e os dados da p√°gina ser√£o passados como a prop `page`.

```js
export async function getStaticPaths({ paginate }) {
  // Carregue seus dados com fetch(), Astro.glob(), etc.
  const resposta = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=150`);
  const resultado = await resposta.json();
  const todosPokemons = resultado.results;

  // Retorna a cole√ß√£o paginada de caminhos para todas as postagens
  return paginate(todosPokemons, { pageSize: 10 });/*-
}

// Se configurado propriamente, a prop page agora tem tudo
// o que voc√™ precisa para renderizar uma √∫nica p√°gina (veja a pr√≥xima se√ß√£o)
const { page } = Astro.props;
```
`paginate()` assume um nome de arquivo `[page].astro` ou `[...page].astro`. O par√¢metro `page` se torna o n√∫mero da p√°gina em sua URL:

- `/postagens/[page].astro` geraria as URLs `/postagens/1`, `/postagens/2`, `/postagens/3`, etc.
- `/postagens/[...page].astro` geraria as URLs `/postagens`, `/postagens/2`, `/postagens/3`, etc.

#### A prop `page` da pagina√ß√£o

A pagina√ß√£o ir√° passar a prop `page` para cada p√°gina renderizada que representa uma √∫nica p√°gina de dados na cole√ß√£o paginada. Isso inclui dados que voc√™ paginou (`page.data`) assim como metadados para a p√°gina (`page.url`, `page.start`, `page.end`, `page.total`, etc). Estes metadados s√£o √∫teis para coisas como um bot√£o de "Pr√≥xima P√°gina" ou uma mensagem "Mostrando 1-10 de 100".

| Name               |         Type          | Descri√ß√£o                                                                                                                       |
| :----------------- | :-------------------: | :-------------------------------------------------------------------------------------------------------------------------------- |
| `page.data`        |        `Array`        | Array dos dados retornados de `data()` para a p√°gina atual.                                                                        |
| `page.start`       |       `number`        | √çndice do primeiro item na p√°gina atual, come√ßando em `0` (e.x. se `pageSize: 25`, isso seria `0` na p√°gina 1, `25` na p√°gina 2, etc.). |
| `page.end`         |       `number`        | √çndice do √∫ltimo item na p√°gina atual.                                                                                               |
| `page.size`        |       `number`        | Quantos itens h√° por p√°gina.                                                                                                          |
| `page.total`       |       `number`        | O n√∫mero total de itens em todas as p√°ginas.                                                                                       |
| `page.currentPage` |       `number`        | O n√∫mero da p√°gina atual, come√ßando por `1`.                                                                                       |
| `page.lastPage`    |       `number`        | O n√∫mero total de p√°ginas.                                                                                                        |
| `page.url.current` |       `string`        | URL da p√°gina atual (√∫til para URLs can√¥nicas)                                                                       |
| `page.url.prev`    | `string \| undefined` | URL da p√°gina anterior (ser√° `undefined` se estiver na p√°gina 1).                                                              |
| `page.url.next`    | `string \| undefined` | URL da pr√≥xima p√°gina (ser√° `undefined` se n√£o houverem mais p√°ginas).                                                              |


## `import.meta`

Todos os m√≥dulos ESM incluem a propriedade `import.meta`. Astro adiciona `import.meta.env` atrav√©s do [Vite](https://vitejs.dev/guide/env-and-mode.html).

**`import.meta.env.SSR`** pode ser utilizado para saber quando se est√° sendo renderizado no servidor. As vezes voc√™ pode querer uma l√≥gica diferente, por exemplo, para um componente que deve ser apenas renderizado no cliente:

```jsx
import { h } from 'preact';

export default function () {
  return import.meta.env.SSR ? <div class="spinner"></div> : <ComponenteComplexo />;
}
```
## Componentes Integrados

Astro inclui v√°rios componentes integrados para voc√™ utilizar em seus projetos. Todos os componentes integrados est√£o dispon√≠veis em arquivos `.astro` via `import {} from 'astro/components';`.

### `<Markdown />`

O componente Markdown n√£o √© mais incluso no Astro. Veja como [importar Markdown em seus arquivos Astro](/pt-br/guides/markdown-content/#importando-markdown) em nossa p√°gina sobre Markdown.

### `<Code />`

```astro
---
import { Code } from 'astro/components';
---
<!-- Adicione syntax highlight de algum c√≥digo JavaScript. -->
<Code code={`const foo = 'bar';`} lang="js" />
<!-- Opcional: customize seu tema. -->
<Code code={`const foo = 'bar';`} lang="js" theme="dark-plus" />
<!-- Opcional: Habilite quebra de texto. -->
<Code code={`const foo = 'bar';`} lang="js" wrap />
```

Este componente providencia syntax highlighting para blocos de c√≥digo em tempo de build (sem JavaScript no lado do cliente). O componente √© viabilizado internamente por Shiki e suporta todos os [temas](https://github.com/shikijs/shiki/blob/main/docs/themes.md) e [linguagens](https://github.com/shikijs/shiki/blob/main/docs/languages.md) populares. Al√©m disso, voc√™ pode adicionar temas e linguagens customizadas as passando para `theme` e `lang` respectivamente.

### `<Prism />`

:::note[Instala√ß√£o]

Para usar o componente highlighter `Prism`, primeiro **instale** o pacote `@astrojs/prism`:

<Tabs client:visible>
  <Fragment slot="tab.1.npm">npm</Fragment>
  <Fragment slot="tab.2.yarn">yarn</Fragment>
  <Fragment slot="tab.3.pnpm">pnpm</Fragment>
  <Fragment slot="panel.1.npm">
  ```shell
  npm i @astrojs/prism
  ```
  </Fragment>
  <Fragment slot="panel.2.yarn">
  ```shell
  yarn add @astrojs/prism
  ```
  </Fragment>
  <Fragment slot="panel.3.pnpm">
  ```shell
  pnpm i @astrojs/prism
  ```
  </Fragment>
</Tabs>
:::

```astro
---
import { Prism } from '@astrojs/prism';
---
<Prism lang="js" code={`const foo = 'bar';`} />
```

Este componente providencia syntax highlighting de linguagens espec√≠ficas para blocos de c√≥digo aplicando as classes CSS do Prism. Note que **voc√™ precisa providenciar uma folha de estilos CSS do Prism** (ou utilizar sua pr√≥pria) para aparecer o syntax highlighting! Veja a [se√ß√£o de configura√ß√£o do Prism](/pt-br/guides/markdown-content/#configura√ß√£o-do-prism) para mais detalhes.

Veja a [lista de linguagens suportadas pelo Prism](https://prismjs.com/#supported-languages) aonde voc√™ pode ver o alias correspondente de uma linguagem. E, voc√™ tamb√©m pode mostrar seus blocos de c√≥digo Astro com `lang="astro"`!

### `<Debug />`

```astro
---
import { Debug } from 'astro/components';
const objetoDoServidor = {
  a: 0,
  b: "string",
  c: {
    aninhado: "objeto"
  }
}
---
<Debug {objetoDoServidor} />
```

Este componente providencia uma forma de inspecionar valores no lado do cliente, sem utilizar JavaScript.

[canonical]: https://en.wikipedia.org/wiki/Canonical_link_element
