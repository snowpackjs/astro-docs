---
type: integration
title: '@astrojs/vercel'
description: 'Astro 프로젝트를 배포하기 위해 @astrojs/vercel SSR 어댑터를 사용하는 방법을 배우세요.'
githubIntegrationURL: 'https://github.com/withastro/astro/tree/main/packages/integrations/vercel/'
category: adapter
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro';
import Since from '~/components/Since.astro';
import ReadMore from '~/components/ReadMore.astro'

이 어댑터는 Astro가 [`하이브리드` 또는 `서버`로 렌더링 된 사이트](/ko/core-concepts/rendering-modes/#요청-시-렌더링)를 [Vercel](https://www.vercel.com/)에 배포할 수 있게 합니다.

Astro를 [정적 사이트 빌더](/ko/core-concepts/rendering-modes/#사전-렌더링)로 사용하고 있다면, 어댑터가 필요하지 않습니다.

우리의 [Vercel 배포 가이드](/ko/guides/deploy/vercel/)에서 Astro 사이트를 배포하는 방법을 배우세요.

## 왜 Astro Vercel인가?

[Vercel](https://www.vercel.com/)은 GitHub 저장소에 직접 연결하여 사이트를 호스팅할 수 있게 해주는 배포 플랫폼입니다. 이 어댑터는 Astro 빌드 과정을 향상시켜 Vercel을 통한 프로젝트 배포를 준비합니다.

## 설치

Astro는 공식 통합을 설정을 자동화하기 위한 `astro add` 명령을 포함하고 있습니다. 원한다면, [수동으로 통합 설치](#수동-설치)를 할 수 있습니다.

`astro add` 명령을 사용하여 Astro 프로젝트에서 SSR을 활성화하는 Vercel 어댑터를 추가하세요. 이것은 `@astrojs/vercel` 설치와 `astro.config.mjs` 파일에 적절한 변경을 한번에 해줍니다.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```sh
  npx astro add vercel
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```sh
  pnpm astro add vercel
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```sh
  yarn astro add vercel
  ```
  </Fragment>
</PackageManagerTabs>

### 수동 설치

먼저, 선호하는 패키지 관리자를 사용하여 프로젝트의 종속성에 `@astrojs/vercel` 어댑터를 추가합니다.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```sh
  npm install @astrojs/vercel
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```sh
  pnpm add @astrojs/vercel
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```sh
  yarn add @astrojs/vercel
  ```
  </Fragment>
</PackageManagerTabs>

그런 다음, 어댑터와 원하는 [요청 시 렌더링 모드](/ko/core-concepts/rendering-modes/#요청-시-렌더링)를 `astro.config.*` 파일에 추가하세요.

```js title="astro.config.mjs" ins={2, 6-7}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  // ...
  output: 'server',
  adapter: vercel(),
});
```

### 대상 선택하기

다양한 대상에 배포할 수 있습니다.

* `serverless`: [Node.js 함수](https://vercel.com/docs/concepts/functions/serverless-functions)내에서 SSR을 수행합니다.
* `static`: Vercel의 출력 형식, 리디렉션 등을 따르는 정적 웹사이트를 생성합니다.

대상을 변경하려면 import를 변경하세요.

```js "serverless" "static"
import vercel from '@astrojs/vercel/serverless';
import vercel from '@astrojs/vercel/static';
```

## 사용

<ReadMore>자세한 내용은 [프로젝트를 Vercel에 배포하는 방법](/ko/guides/deploy/vercel/)을 참조하세요.</ReadMore>

CLI (`vercel deploy`)를 사용하여 배포하거나, [Vercel 대시보드](https://vercel.com/)에서 새로운 레포지토리를 연결하여 배포할 수 있습니다. 또는, 로컬에서 프로덕션 빌드를 생성할 수 있습니다.

```sh
astro build
vercel deploy --prebuilt
```

## 구성

이 어댑터를 구성하려면, `astro.config.mjs`에서 `vercel()` 함수 호출에 객체를 전달하세요.

### webAnalytics

**Type:** `VercelWebAnalyticsConfig`<br/>
**Available for:** Serverless, Static<br/>
<Since v="3.8.0" pkg="@astrojs/vercel" />

`webAnalytics: { enabled: true }`를 설정하여 [Vercel 웹 분석](https://vercel.com/docs/concepts/analytics)을 활성화할 수 있습니다. 이렇게 하면 Vercel의 추적 스크립트가 모든 페이지에 삽입됩니다.

```js title="astro.config.mjs" ins={8-10}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  // ...
  output: 'server',
  adapter: vercel({
    webAnalytics: {
      enabled: true,
    },
  }),
});
```

### imagesConfig

**Type:** `VercelImageConfig`<br/>
**Available for:** Serverless, Static
<Since v="3.3.0" pkg="@astrojs/vercel" />

[Vercel의 이미지 최적화 API](https://vercel.com/docs/concepts/image-optimization)에 대한 구성 옵션입니다. 지원되는 모든 매개변수에 대해서는 [Vercel의 이미지 구성 문서](https://vercel.com/docs/build-output-api/v3/configuration#images)를 참조하세요.

`domains` 및 `remotePatterns` 속성은 자동으로 [Astro의 해당 `image` 설정](/ko/reference/configuration-reference/#image-options)을 사용하여 채워집니다.

```js title="astro.config.mjs" ins={8-10}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/static';

export default defineConfig({
  // ...
  output: 'static',
  adapter: vercel({
    imagesConfig: {
      sizes: [320, 640, 1280],
    },
  }),
});
```

### imageService

**Type:** `boolean`<br/>
**Available for:** Serverless, Static
<Since v="3.3.0" pkg="@astrojs/vercel" />

활성화되면, Vercel 이미지 최적화 API에 의해 구동되는 [이미지 서비스](/ko/reference/image-service-reference/)가 자동으로 설정되고 프로덕션에서 사용됩니다. 개발 중에는 [`devImageService`](#devimageservice)에 지정된 이미지 서비스가 대신 사용됩니다.

```js title="astro.config.mjs" ins={8}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/static';

export default defineConfig({
  // ...
  output: 'static',
  adapter: vercel({
    imageService: true,
  }),
});
```

```astro title="src/pages/index.astro"
---
import { Image } from 'astro:assets';
import astroLogo from '../assets/logo.png';
---

<!-- 이 컴포넌트 -->
<Image src={astroLogo} alt="My super logo!" />

<!-- 다음 HTML이 될 것입니다 -->
<img
  src="/_vercel/image?url=_astro/logo.hash.png&w=...&q=..."
  alt="My super logo!"
  loading="lazy"
  decoding="async"
  width="..."
  height="..."
/>
```

### devImageService

**Type:** `'sharp' | 'squoosh' | string`<br/>
**Available for:** Serverless, Static
<Since v="3.8.0" pkg="@astrojs/vercel" />
**Default**: 'sharp'

[imageService](#imageService)가 활성화된 상태에서 개발 중에 사용할 이미지 서비스를 설정할 수 있습니다. 이는 개발 기기에 Sharp의 의존성을 설치할 수 없지만 Squoosh와 같은 다른 이미지 서비스를 사용하면 개발 환경에서 이미지를 미리 볼 수 있게 하므로 유용할 수 있습니다. 빌드는 영향을 받지 않고 항상 Vercel의 이미지 최적화를 사용합니다.

Astro의 내장 이미지 서비스 대신 사용자 정의 이미지 서비스를 사용하려면 임의의 값을 설정할 수도 있습니다.

```js title="astro.config.mjs" ins={8-9}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  // ...
  output: 'server',
  adapter: vercel({
    imageService: true,
    devImageService: 'squoosh',
  }),
});
```

### includeFiles

**Type:** `string[]`<br/>
**Available for:** Serverless

이 속성을 사용하여 함수와 함께 번들링될 파일을 강제로 설정할 수 있습니다. 이는 누락된 파일을 발견했을 때 유용합니다.

```js title="astro.config.mjs" ins={8}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  // ...
  output: 'server',
  adapter: vercel({
    includeFiles: ['./my-data.json'],
  }),
});
```

### excludeFiles

**Type:** `string[]`<br/>
**Available for:** Serverless

이 속성을 사용하여 번들링 과정에서 기본적으로 포함되는 파일 중 제외할 파일을 설정할 수 있습니다.

```js title="astro.config.mjs" ins={8}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  // ...
  output: 'server',
  adapter: vercel({
    excludeFiles: ['./src/some_big_file.jpg'],
  }),
});
```

### maxDuration

**Type:** `number`<br/>
**Available for:** Serverless

이 속성을 사용하여 서버리스 함수가 타임아웃되기 전에 실행될 수 있는 최대 시간(초)을 연장하거나 제한할 수 있습니다. 계정 계획에 대한 기본값과 최대 제한에 대해서는 [Vercel 문서](https://vercel.com/docs/functions/serverless-functions/runtimes#maxduration)를 참조하세요.

```js title="astro.config.mjs" ins={8}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
// ...
  output: "server",
  adapter: vercel({
    maxDuration: 60
  }),
});
```

### 함수 번들링 설정

Vercel 어댑터는 기본적으로 모든 라우트를 단일 함수로 결합합니다.

`functionPerRoute` 옵션을 사용하여 각 라우트에 대해 별도의 함수로 빌드를 분할하는 옵션도 있습니다. 이렇게 하면 각 함수의 크기가 줄어들어 개별 함수의 크기 제한을 초과할 가능성이 줄어듭니다. 또한, 코드 시작이 더 빠릅니다.

`functionPerRoute`를 활성화하기 전에 Vercel 계획이 적절한 수의 함수를 포함하고 있는지 확인하십시오. 예를 들어, Vercel의 무료 구간은 각 배포를 12개의 함수 이하로 제한합니다. 프로젝트의 라우트 수에 비해 Vercel 플랜이 부족한 경우, 배포 중에 오류 메시지를 받게 됩니다.

```js title="astro.config.mjs" ins={8}
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  // ...
  output: 'server',
  adapter: vercel({
    functionPerRoute: true,
  }),
});
```

### Vercel Edge 미들웨어

Vercel 에지 미들웨어를 사용하여 요청을 가로채고 응답을 보내기 전에 리디렉션할 수 있습니다. Vercel 미들웨어는 Edge, SSR, 그리고 Static 배포에 대해 실행될 수 있습니다. 미들웨어에 이 패키지를 설치할 필요가 없을 수 있습니다. `@vercel/edge`는 지리적 위치 등 일부 미들웨어 기능을 사용하는 데 필요합니다. 자세한 정보는 [Vercel의 미들웨어 문서](https://vercel.com/docs/concepts/functions/edge-middleware)를 참조하세요.

1. 프로젝트의 루트에 `middleware.js` 파일을 추가하세요.

  ```js title="middleware.js"
  export const config = {
    // 미들웨어는 관리자 경로에서만 실행됩니다
    matcher: '/admin',
  };

  export default function middleware(request) {
    const url = new URL(request.url);
    // 여기서 IP 위치나 쿠키를 검색할 수 있습니다.
    if (url.pathname === '/admin') {
      url.pathname = '/';
    }
    return Response.redirect(url);
  }
  ```

2. 로컬에서 개발하는 동안, 미들웨어를 실행하기 위해 `vercel dev`를 실행할 수 있습니다. 프로덕션에서는 Vercel이 이를 처리해줍니다.



:::caution
**다시 작성하려고 하시나요?** 현재 미들웨어를 사용하여 요청을 다시 작성하는 것은 정적 파일에만 작동합니다.
:::

### Astro 미들웨어와 함께 사용하는 Vercel Edge 미들웨어

`@astrojs/vercel/serverless` 어댑터는 코드 베이스의 Astro 미들웨어에서 Vercel 에지 미들웨어를 자동으로 생성할 수 있습니다.

이는 선택적 기능이며, `edgeMiddleware` 옵션을 `true`로 설정해야 합니다.

```js title="astro.config.mjs" "edgeMiddleware: true"
import { defineConfig } from 'astro/config';
import vercel from '@astrojs/vercel/serverless';

export default defineConfig({
  // ...
  output: 'server',
  adapter: vercel({
    edgeMiddleware: true,
  }),
});
```

선택적으로, [`srcDir`](/ko/reference/configuration-reference/#srcdir) 폴더에 `vercel-edge-middleware.(js|ts)`라는 이름의 파일을 생성하여 [`Astro.locals`](/ko/reference/api-reference/#astrolocals)를 생성할 수 있습니다.

타이핑에는 [`@vercel/edge`](https://www.npmjs.com/package/@vercel/edge) 패키지가 필요합니다.

```js title="src/vercel-edge-middleware.js"
/**
 *
 * @param options.request {Request}
 * @param options.context {import("@vercel/edge").RequestContext}
 * @returns {object}
 */
export default function ({ request, context }) {
  // 요청과 컨텍스트로 무언가를 수행합니다
  return {
    title: "Spider-man's blog",
  };
}
```

TypeScript를 사용하는 경우, 다음과 같이 함수를 타입화할 수 있습니다.

```ts title="src/vercel-edge-middleware.ts"
import type { RequestContext } from '@vercel/edge';

export default function ({ request, context }: { request: Request; context: RequestContext }) {
  // 요청과 컨텍스트로 무언가를 수행합니다
  return {
    title: "Spider-man's blog",
  };
}
```

이 함수에서 반환된 데이터는 Astro 미들웨어로 전달됩니다.

이 함수는

* **default** 함수를 내보내야 합니다;
* `object`를 **retorn**해야 합니다;
* `request`와 `context` 속성을 가진 객체를 받습니다;
* `request`는 [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)로 타입이 지정됩니다;
* `context`는 [`RequestContext`](https://vercel.com/docs/concepts/functions/edge-functions/vercel-edge-package#requestcontext)로 타입이 지정됩니다;

#### 제한 사항 및 제약 조건

이 기능을 선택하면 몇 가지 제약 사항을 알아두어야 합니다:

* Vercel Edge 미들웨어는 항상 `Request`를 받는 **첫 번째** 함수이며 `Response`를 받는 마지막 함수입니다. 이는 [Vercel이 설정한 경계](https://vercel.com/docs/concepts/functions/edge-middleware)를 따르는 구조적 제약입니다.
* `Astro.locals` 객체를 생성하기 위해 `request`와 `context`만 사용할 수 있습니다. 리디렉션 등의 작업은 Astro 미들웨어에 위임해야 합니다.
* `Astro.locals`는 **직렬화 가능해야** 합니다. 그렇지 않으면 **런타임 오류**가 발생합니다. 이는 `Map`, `function`, `Set` 등의 복잡한 유형을 저장할 수 **없음**을 의미합니다.

### Node.js 버전 지원

`@astrojs/vercel` 어댑터는 Vercel에서 Astro 프로젝트를 배포하기 위한 특정 Node.js 버전을 지원합니다. Vercel에서 지원하는 Node.js 버전을 보려면 프로젝트의 설정 탭을 클릭하고 "Node.js 버전" 섹션으로 스크롤하십시오.

[Vercel 문서](https://vercel.com/docs/functions/serverless-functions/runtimes/node-js#default-and-available-versions)를 참조하여 자세히 알아보십시오.


[astro-integration]: /ko/guides/integrations-guide/
