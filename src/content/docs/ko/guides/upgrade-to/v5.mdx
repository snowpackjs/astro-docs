---
title: Astro v5로 업그레이드
description: How to upgrade your project to Astro v5.0.
sidebar:
  label: v5.0
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import { Steps } from '@astrojs/starlight/components';
import ReadMore from '~/components/ReadMore.astro'
import SourcePR from '~/components/SourcePR.astro'

이 가이드는 Astro v4에서 Astro v5로 마이그레이션하는 것을 도와줍니다.

더 오래된 프로젝트를 먼저 v4로 업그레이드해야 하나요? [이전 마이그레이션 가이드](/ko/guides/upgrade-to/v4/)를 참조하세요.

v4 문서를 보고 싶으신가요? [문서 사이트의 이전 버전(관리되지 않는 v4.16 스냅샷)](https://v4.docs.astro.build/)을 방문하세요.

## Astro 업그레이드

패키지 매니저를 사용하여 프로젝트의 Astro를 최신 버전으로 업데이트하세요:

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # Astro와 공식 통합을 함께 업그레이드
  npx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # Astro와 공식 통합을 함께 업그레이드
  pnpm dlx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # Astro와 공식 통합을 함께 업그레이드
  yarn dlx @astrojs/upgrade
  ```
  </Fragment>
</PackageManagerTabs>

필요한 경우 [Astro 통합을 수동으로 업그레이드](/ko/guides/integrations-guide/#수동-업그레이드)할 수도 있으며, 프로젝트의 다른 종속성도 업그레이드해야 할 수 있습니다.

:::note[계속 진행해야 하나요?]
Astro를 업그레이드한 후에는 프로젝트를 전혀 수정할 필요가 없을 수도 있습니다!

하지만 오류나 예상치 못한 동작이 발견되면, 아래에서 업데이트가 필요할 수 있는 변경 사항을 확인하시기 바랍니다.
:::

Astro v5.0에는 [잠재적인 주요 변경 사항](#주요-변경-사항)과 함께 일부 기능의 제거 및 사용 중단이 포함되어 있습니다.

v5.0으로 업그레이드한 후 프로젝트가 예상대로 작동하지 않는 경우, 이 가이드를 통해 모든 주요 변경 사항과 코드베이스 업데이트 방법에 대한 개요를 확인하세요.

전체 릴리스 노트는 [Astro 변경 로그](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md)를 참조하세요.

## 종속성 업그레이드

Astro의 종속성에 대한 주요 업그레이드는 프로젝트에서 주요 변경 사항을 발생시킬 수 있습니다.

### Vite 6.0

Astro v5.0은 개발 서버와 프로덕션 번들러를 Vite v6.0으로 업그레이드하였습니다.

#### 무엇을 해야 하나요?

Vite 관련 플러그인, 설정 또는 API를 사용하고 있다면, [Vite 마이그레이션 가이드](https://ko.vite.dev/guide/migration.html)에서 주요 변경 사항을 확인하고 필요에 따라 프로젝트를 업그레이드하세요.

### `@astrojs/mdx`

<SourcePR number="11741" title="Cleanup unused JSX code"/>

Astro v4.x에서는 `@astrojs/mdx` 통합을 위한 JSX 처리를 Astro 내부에서 수행했습니다.

Astro v5.0에서는 JSX와 MDX를 처리하고 렌더링하는 책임을 `@astrojs/mdx` 패키지로 직접 이동했습니다. 이는 Astro 5.0이 더 이상 이전 버전의 MDX 통합과 호환되지 않는다는 것을 의미합니다.

#### 무엇을 해야 하나요?

프로젝트에 `.mdx` 파일이 포함되어 있다면, JSX가 통합에 의해 제대로 처리될 수 있도록 `@astrojs/mdx`를 최신 버전(v4.0.0)으로 업그레이드해야 합니다.

실험적인 [Astro 컨테이너 API](/ko/reference/container-reference/)와 함께 MDX 서버 렌더러를 사용하고 있다면, 새로운 위치를 반영하도록 import를 업데이트해야 합니다:

```ts del={1} ins={2}
import mdxRenderer from "astro/jsx/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";
```

<ReadMore>[프로젝트에서 MDX를 사용](/ko/guides/integrations-guide/mdx/)하는 방법에 대해 자세히 알아보세요.</ReadMore>

## 레거시

다음 기능들은 이제 레거시로 간주됩니다. 정상적으로 작동하지만 더 이상 권장되지 않으며 유지보수 모드에 있습니다. 앞으로 개선될 예정이 없으며 문서도 업데이트되지 않을 것입니다. 이러한 기능들은 결국 더 이상 사용되지 않게 되며, 이후 완전히 제거될 것입니다.

### 레거시: v2.0 콘텐츠 컬렉션 API

Astro 4.x에서는 [Astro v2.0에서 처음 도입된 콘텐츠 컬렉션 API](https://astro.build/blog/introducing-content-collections/)를 사용하여 콘텐츠 컬렉션을 정의, 쿼리 및 렌더링했습니다.

Astro 5.0은 여러 성능 향상과 추가 기능을 제공하는 콘텐츠 레이어 API를 사용하는 새로운 버전의 콘텐츠 컬렉션을 도입합니다. 이번 릴리스에서는 이전(레거시) 컬렉션과 새로운(콘텐츠 레이어 API) 컬렉션이 함께 존재할 수 있지만, 기존 레거시 컬렉션에 잠재적인 주요 변경 사항이 있을 수 있습니다.

#### 무엇을 해야 하나요?

가능한 한 빨리 [기존 컬렉션을 새로운 콘텐츠 레이어 API로 변환](#기존-컬렉션-업데이트)하고 새로운 컬렉션을 만들 때도 콘텐츠 레이어 API를 사용하는 것을 권장합니다.

컬렉션을 변환할 수 없는 경우, [레거시 컬렉션의 주요 변경 사항](#레거시-content-및-data-컬렉션의-주요-변경-사항)을 참고하여 기존 컬렉션이 영향을 받는지, 업데이트가 필요한지 확인하시기 바랍니다.

현재 컬렉션을 변경할 수 없는 경우, [`legacy.collections` 플래그를 활성화](#legacycollections-플래그-활성화)하여 레거시 플래그가 더 이상 지원되지 않을 때까지 컬렉션을 현재 상태로 유지할 수 있습니다.

<ReadMore>업데이트된 [콘텐츠 컬렉션](/ko/guides/content-collections/)에 대해 자세히 알아보세요.</ReadMore>

##### 기존 컬렉션 업데이트

콘텐츠 레이어 API를 사용하기 위해 기존 콘텐츠 컬렉션(`type: 'content'` 또는 `type: 'data'`)을 업데이트하는 방법은 아래의 안내를 참고하세요.

<details>
<summary>컬렉션을 업데이트하는 단계별 안내</summary>

<Steps>

1. **콘텐츠 설정 파일 이동하기**. 이 파일은 더 이상 `src/content/` 폴더에 있지 않습니다. 이제 이 파일은 `src/content.config.ts`에 위치해야 합니다.

2. **컬렉션 정의 수정하기**. 업데이트된 컬렉션에는 `loader`가 필요하며, 컬렉션 `type`을 선택하는 옵션은 더 이상 사용할 수 없습니다.

    ```ts ins={3,8} del={7}
    // src/content.config.ts
    import { defineCollection, z } from 'astro:content';
    import { glob } from 'astro/loaders';

    const blog = defineCollection({
      // 콘텐츠 레이어에서는 더 이상 `type`을 정의하지 않습니다
      type: 'content',
      loader: glob({ pattern: '**\/[^_]*.md', base: "./src/data/blog" }),
      schema: z.object({
        title: z.string(),
        description: z.string(),
        pubDate: z.coerce.date(),
        updatedDate: z.coerce.date().optional(),
      }),
    });
    ```
    
3. **`slug`를 `id`로 참조 변경하기**. 콘텐츠 레이어 컬렉션에는 예약된 `slug` 필드가 없습니다. 대신, 모든 업데이트된 컬렉션은 `id`를 가지게 됩니다. 변경된 getStaticPaths() 매개변수와 일치하도록 동적 라우팅 파일 이름도 업데이트해야 할 수 있습니다:

    ```astro ins={7} del={6}
    // src/pages/[id].astro
    ---
    export async function getStaticPaths() {
      const posts = await getCollection('blog');
      return posts.map((post) => ({
        params: { slug: post.slug },
        params: { id: post.id },
        props: post,
      }));
    }
    ---
    ```

4. **새로운 `render()` 함수로 전환하기**. 이제 항목들이 직렬화 가능한 일반 객체이므로 더 이상 `render()` 메서드를 가지지 않습니다. 대신, `astro:content`에서 `render()` 함수를 가져와야 합니다.

    ```astro title="src/pages/index.astro" ins=", render" del={6} ins={7}
    ---
    import { getEntry, render } from 'astro:content';

    const post = await getEntry('blog', params.slug);

    const { Content, headings } = await post.render();
    const { Content, headings } = await render(post);
    ---
    <Content />
    ```
</Steps>

</details>

##### 레거시 `content` 및 `data` 컬렉션의 주요 변경 사항

<SourcePR number="11976" title="Implement legacy collections using glob" />

기본적으로 이전 `type` 속성(`content` 또는 `data`)을 사용하고 `loader`를 정의하지 않는 컬렉션은 이제 콘텐츠 레이어 API의 내장 `glob()` 로더를 사용하여 내부적으로 구현되며, 추가적인 하위 호환성 처리가 포함됩니다.

또한, 콘텐츠 설정 파일을 원래 위치인 `src/content/config.ts`에 유지하기 위한 임시 하위 호환성이 존재합니다.

이러한 하위 호환성 구현은 레거시 컬렉션의 대부분의 기능을 에뮬레이션할 수 있으며, 코드를 업데이트하지 않아도 많은 레거시 컬렉션이 계속 작동할 수 있게 합니다. 하지만, **기존 컬렉션에 주요 변경 사항을 발생시킬 수 있는 몇 가지 차이점과 제한 사항이 있습니다**:
    
  - 이전 Astro 버전에서는 `src/content/config.ts`에 정의되지 않았더라도 `src/content/` 내 모든 폴더에 대해 컬렉션이 생성되었습니다. 이 동작은 이제 더 이상 사용되지 않으며, 컬렉션은 항상 `src/content.config.ts`에 정의되어야 합니다. 기존 컬렉션의 경우 빈 선언(예: `const blog = defineCollection({})`)만으로도 충분하며, Astro는 새로운 로딩 동작과 호환되는 방식으로 레거시 컬렉션을 암시적으로 정의할 것입니다.
  - 특별한 `layout` 필드는 Markdown 컬렉션 항목에서 지원되지 않습니다. 이 속성은 `src/pages/`에 위치한 독립 실행형 페이지 파일에만 사용되며 컬렉션 항목에는 사용되지 않을 가능성이 높습니다. 하지만 이 속성을 사용하고 있었다면, 이제 페이지 스타일링을 포함하는 동적 경로를 생성해야 합니다.
  - 생성된 컬렉션의 정렬 순서는 비결정적이며 플랫폼에 따라 다릅니다. 즉, `getCollection()`을 호출할 때 항목이 반환되는 순서가 이전과 다를 수 있습니다. 특정 순서가 필요한 경우 컬렉션 항목을 직접 정렬해야 합니다.
  - `image().refine()`은 지원되지 않습니다. 이미지의 속성을 검증해야 하는 경우 페이지나 컴포넌트에서 런타임에 이를 수행해야 합니다.
  - `getEntry(collection, key)`의 `key` 인자는 모든 항목에 대한 타입을 가지는 대신 `string`으로 타입이 지정됩니다.
  - 이전에는 `getEntry(collection, key)`에 key를 정적 문자열로 전달하여 호출할 때 반환 타입이 널러블하지 않았습니다. 이제 타입에 `undefined`가 포함되므로 결과를 사용하기 전에 항목이 정의되었는지 확인해야 하며, 그렇지 않으면 타입 오류가 발생합니다.

##### `legacy.collections` 플래그 활성화

<SourcePR number="11976" title="Implement legacy collections using glob" />

아직 기존 컬렉션을 업데이트할 준비가 되지 않았다면, [`legacy.collections`](/ko/reference/legacy-flags/) 플래그를 활성화하여 기존 컬렉션이 이전처럼 계속 작동하도록 할 수 있습니다.

## 더 이상 사용되지 않음

다음의 더 이상 사용되지 않는 기능들은 더 이상 지원되지 않으며 문서화되지 않습니다. 이에 따라 프로젝트를 업데이트하시기 바랍니다.

일부 더 이상 사용되지 않는 기능들은 완전히 제거될 때까지 일시적으로 계속 작동할 수 있습니다. 다른 기능들은 아무 효과 없이 조용히 무시되거나, 코드 업데이트를 요구하는 오류를 발생시킬 수 있습니다.

### 더 이상 사용되지 않음: `Astro.glob()`

<SourcePR number="11826" title="Deprecate glob"/>

Astro v4.x에서는 `.astro` 컴포넌트에서 `Astro.glob()`을 사용하여 프로젝트의 여러 파일을 쿼리할 수 있었습니다. 이는 몇 가지 제한사항(사용할 수 있는 위치, 성능 등)이 있었으며, 콘텐츠 컬렉션 API의 쿼리 함수나 Vite의 `import.meta.glob()`을 사용하는 것이 더 많은 기능과 유연성을 제공했습니다.

Astro 5.0에서는 `Astro.glob()` 대신 컬렉션을 쿼리하기 위한 `getCollection()`과 프로젝트의 다른 소스 파일을 쿼리하기 위한 `import.meta.glob()`을 사용하도록 변경되었습니다.

#### 무엇을 해야 하나요?

모든 `Astro.glob()` 사용을 `import.meta.glob()`로 교체하세요. `import.meta.glob()`는 더 이상 `Promise`를 반환하지 않으므로, 이에 따라 코드를 업데이트해야 할 수 있습니다. [glob 패턴](/ko/guides/imports/#glob-패턴)은 업데이트할 필요가 없습니다.

```astro title="src/pages/blog.astro" del={2} ins={3}
---
const posts = await Astro.glob('./posts/*.md');
const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));
---

{posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
```

적절한 경우, 자체적으로 더 새롭고 성능이 좋은 쿼리 함수를 가진 [콘텐츠 컬렉션](/ko/guides/content-collections/)을 사용하여 콘텐츠를 구성하는 것을 고려해보세요.

또한 [`fast-glob`](https://www.npmjs.com/package/fast-glob)과 같은 NPM의 glob 패키지 사용을 고려해볼 수 있습니다.

<ReadMore>[`import.meta.glob`을 사용한 파일 가져오기](/ko/guides/imports/#importmetaglob)에 대해 자세히 알아보세요.</ReadMore>
 
### 더 이상 사용되지 않음: `functionPerRoute` (어댑터 API)

<SourcePR number="11714" title="Remove functionPerRoute option"/>

Astro v4.x에서는 프로젝트에 정의된 각 경로에 대해 별도의 파일을 생성하도록 선택할 수 있었으며, 이는 빌드 폴더에서 `src/pages/` 디렉터리를 미러링했습니다. 기본적으로 Astro는 각 요청에서 렌더링된 페이지를 생성하는 단일 `entry.mjs` 파일을 생성했습니다.

Astro v5.0은 기본 동작을 선택 해제하는 옵션을 제거합니다. 이 동작은 이제 표준이며 설정할 수 없습니다.

`adapterFeatures` 설정에서 `functionPerRoute` 속성을 제거하세요. 더 이상 사용할 수 없습니다.

```js title="my-adapter.mjs" del={10}
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}

```

<ReadMore>어댑터 통합을 구축하기 위한 [어댑터 API](/ko/reference/adapter-reference/)에 대해 자세히 알아보세요.</ReadMore>

### 더 이상 사용되지 않음: `astro:build:done` 훅의 `routes` (통합 API)

<SourcePR number="12329" title="feat(next): astro:routes:resolved"/>

Astro v4.x에서는 통합이 `astro:build:done` 훅에서 라우트에 접근했습니다.

Astro v5.0에서는 이 훅에 전달되는 `routes` 배열을 더 이상 사용하지 않습니다. 대신, `astro:config:done` 이전에 실행되고 개발 모드에서 라우트가 변경될 때마다 실행되는 새로운 `astro:routes:resolved` 훅을 제공합니다. 이는 빌드 중에만 사용할 수 있는 `distURL`을 제외하고 더 이상 사용되지 않는 `routes` 목록의 모든 속성을 가지고 있습니다.

#### 무엇을 해야 하나요?

`astro:build:done`에 전달된 모든 `routes` 인스턴스를 제거하고 새로운 `astro:routes:resolved` 훅으로 교체하세요. 새로 노출된 `assets` 맵에서 `distURL`에 접근하세요:

```js title="my-integration.mjs" ins={2,6-8,11,13-18} del={10}
const integration = () => {
    let routes
    return {
        name: 'my-integration',
        hooks: {
            'astro:routes:resolved': (params) => {
                routes = params.routes
            },
            'astro:build:done': ({
                routes
                assets
            }) => {
                for (const route of routes) {
                    const distURL = assets.get(route.pattern)
                    if (distURL) {
                        Object.assign(route, { distURL })
                    }
                }
                console.log(routes)
            }
        }
    }
}
```

<ReadMore>통합 구축을 위한 [통합 API `astro:routes:resolved` 훅](/ko/reference/integrations-reference/#astroroutesresolved)에 대해 자세히 알아보세요.</ReadMore>

## 제거됨

다음 기능들은 이제 코드베이스에서 완전히 제거되었으며 더 이상 사용할 수 없습니다. 이러한 기능 중 일부는 더 이상 사용되지 않게 된 후에도 프로젝트에서 계속 작동했을 수 있습니다. 다른 기능들은 아무 효과 없이 조용히 무시되었을 수 있습니다.

이제 이러한 제거된 기능이 포함된 프로젝트는 빌드할 수 없으며, 이러한 기능을 제거하라는 안내 문서도 더 이상 제공되지 않을 것입니다.

### 제거됨: Lit 통합

<SourcePR number="11680" title="Remove `@astrojs/lit`"/>

Astro v4.x에서 [Lit](https://lit.dev/)는 `@astrojs/lit` 패키지를 통해 코어에서 유지 관리하는 프레임워크 라이브러리였습니다.

Astro v5.0에서는 이 통합이 제거되었으며 5.x 이상 버전과의 호환성을 위한 추가 업데이트를 받지 않을 것입니다.

#### 무엇을 해야 하나요?

다음과 같이 클라이언트 측 스크립트 태그를 추가하여 클라이언트 컴포넌트에 계속 Lit를 사용할 수 있습니다:

```astro
<script>
  import "../components/MyTabs";
</script>

<my-tabs title="These are my tabs">...</my-tabs>
```

Lit 통합을 직접 유지 관리하는 데 관심이 있다면, [마지막으로 게시된 버전의 `@astrojs/lit`](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit)를 시작점으로 사용하고 관련 패키지를 업그레이드할 수 있습니다.

<ReadMore>[Astro의 공식 통합](/ko/guides/integrations-guide/)에 대해 자세히 알아보세요.</ReadMore>

### 제거됨: `hybrid` 렌더링 모드

<SourcePR number="11824" title="Merge output:hybrid and output:static" />

Astro v4.x에서는 세 가지 `output` 렌더링 모드를 제공했습니다: `'static'`, `'hybrid'`, 그리고 `'server'`

Astro v5.0은 `output: 'hybrid'`와 `output: 'static'` 설정을 하나의 설정(이제 `'static'`이라고 불림)으로 통합하며, 이는 이전의 hybrid 옵션과 동일한 방식으로 작동합니다.

서버 렌더링 페이지를 사용하기 위해 더 이상 Astro 설정에서 `output: 'hybrid'`를 지정할 필요가 없습니다. 새로운 `output: 'static'`에 이 기능이 포함되어 있습니다.

이제 Astro는 출력 설정을 변경하지 않고도 정적 사이트에서 사전 렌더링을 선택적으로 해제할 수 있게 합니다. 모든 페이지 경로나 엔드포인트에 `export const prerender = false`를 포함하면 사이트의 나머지 부분은 정적으로 생성되는 동안 해당 페이지는 필요할 때 서버에서 렌더링됩니다.

#### 무엇을 해야 하나요?

프로젝트에서 하이브리드 렌더링을 사용했다면, Astro 설정에서 이제 더 이상 존재하지 않는 `output: 'hybrid'` 옵션을 제거해야 합니다. 하지만 프로젝트의 다른 변경 사항은 필요하지 않으며, 주요 변경 사항도 없을 것입니다. 이전의 `'hybrid'` 동작이 이제 `'static'`이라는 새로운 이름으로 기본값이 되었습니다.

```js title="astro.config.mjs" del={4}
import { defineConfig } from "astro/config";

export default defineConfig({
  output: 'hybrid',
});
```

`output: 'static'`(기본값) 옵션을 사용하고 있었다면, 이전처럼 계속 사용할 수 있습니다. 기본적으로 모든 페이지는 계속 사전 렌더링되며 완전히 정적인 사이트를 가지게 될 것입니다. 프로젝트에 주요 변경 사항은 없을 것입니다.

프로젝트가 어떤 `output` 모드를 사용하든 서버 렌더링된 페이지가 있는 Astro 프로젝트를 배포하려면 여전히 어댑터가 필요합니다. 어댑터를 포함하지 않으면 개발 중에는 경고가, 빌드 시에는 오류가 발생합니다.

<ReadMore>[Astro의 요청 시 렌더링](/ko/guides/on-demand-rendering/)에 대해 자세히 알아보세요.</ReadMore>

### 제거됨: Squoosh 이미지 서비스

<SourcePR number="11770" title="remove the squoosh image service"/>

Astro 4.x에서는 Sharp 대신 Squoosh를 사용하여 이미지를 변환하도록 `image.service: squooshImageService()`를 구성할 수 있었습니다. 하지만 기반이 되는 라이브러리인 `libsquoosh`는 더 이상 유지 관리되지 않으며 메모리와 성능 문제가 있습니다.

Astro 5.0은 Squoosh 이미지 최적화 서비스를 완전히 제거합니다.

#### 무엇을 해야 하나요?

내장 Sharp 이미지 서비스로 전환하려면, Astro 설정에서 `squooshImageService` 가져오기를 제거하세요. 기본적으로 `astro:assets`에 Sharp를 사용하게 됩니다.

```ts title="astro.config.mjs" del={1, 5-7}
import { squooshImageService } from "astro/config";
import { defineConfig } from "astro/config";

export default defineConfig({
 image: {
   service: squooshImageService()
 }
});
```

`pnpm`과 같은 엄격한 패키지 매니저를 사용하는 경우, Sharp가 Astro에 기본적으로 내장되어 있더라도 Sharp 이미지 서비스를 사용하기 위해 `sharp` 패키지를 수동으로 설치해야 할 수 있습니다.

어댑터가 Astro의 내장 Sharp 이미지 최적화를 지원하지 않는 경우, `<Image />` 및 `<Picture />` 컴포넌트를 사용할 수 있도록 [no-op 이미지 서비스를 구성](/ko/guides/images/#무작동-패스스루-서비스-구성)할 수 있습니다.

또는 Sharp 이미지 서비스를 사용할 수 없는 경우 [커뮤니티에서 유지 관리하는 Squoosh 이미지 서비스](https://github.com/Princesseuh/astro-image-service-squoosh)를 고려해볼 수 있습니다.

##### 어댑터

이전에 어댑터에서 Squoosh와의 호환성 상태를 명시했다면, 이제 어댑터 설정에서 이 정보를 제거해야 합니다.

```js title="my-adapter.mjs" del={2-4}
supportedAstroFeatures: {
  assets: {
    isSquooshCompatible: true
  }
}
```

<ReadMore>[기본 이미지 서비스 구성](/ko/guides/images/#기본-이미지-서비스)에 대해 자세히 알아보세요.</ReadMore>

### 제거됨: 일부 공개 타입

<SourcePR number="11715" title="Refactor/types"/>

Astro v4.x에서는 `@types/astro.ts`가 여전히 활발하게 사용되고 있는지 또는 내부 사용만을 위한 것인지와 관계없이 모든 타입을 사용자에게 공개적으로 노출했습니다.

Astro v5.0은 이 파일을 리팩터링하여 오래된 타입과 내부 타입을 제거합니다. 이 리팩터링은 편집기에 개선 사항을 제공합니다(예: 더 빠른 완성, 더 낮은 메모리 사용량, 더 관련성 있는 완성 옵션). 하지만 이 리팩터링으로 인해 더 이상 공개적으로 사용할 수 없는 타입에 의존하고 있는 일부 프로젝트에서 오류가 발생할 수 있습니다.

#### 무엇을 해야 하나요?

더 이상 접근할 수 없는 타입으로 인해 프로젝트에서 오류가 발생하는 경우 해당 타입을 제거하세요. 이는 대부분 더 이상 사용되지 않고 제거된 API들이지만, 이제 내부용이 된 타입들을 포함하고 있을 수도 있습니다.

<ReadMore>[사용을 위해 공개된 타입](https://github.com/withastro/astro/tree/next/packages/astro/src/types/public)을 참조하세요.</ReadMore>

### 실험적 플래그

다음의 실험적 플래그들은 Astro v5.0에서 제거되었으며 이러한 기능들은 이제 사용할 수 있습니다:

- `env`
- `serverIslands`

또한, 다음의 실험적 플래그들은 제거되었으며 **이제 Astro v5.0에서 기본값 또는 권장되는 동작입니다**.

- `directRenderScript` ([`기본 <script>` 동작](#스크립트-태그가-선언된-그대로-직접-렌더링됨)의 주요 변경 사항을 참조하세요.)
- `globalRoutePriority` ([기본 라우트 우선순위 순서](#주입된-라우트와-리디렉션의-라우트-우선순위)에 대한 주요 변경 사항을 참조하세요.)
- `contentLayer` (새로운 콘텐츠 레이어 API로 [기존 콘텐츠 컬렉션을 업그레이드](#레거시-v20-콘텐츠-컬렉션-api)하는 방법에 대한 지침을 참조하세요.)

다음의 실험적 플래그들은 제거되었으며 **해당 기능들은 Astro v5.0의 일부가 아닙니다**.

- `contentCollectionsCache`

이전에 이러한 실험적 플래그들을 사용하고 있었다면 제거하고, `env` 설정을 Astro 설정의 루트로 이동하세요:

```js del={5-12} ins={14-16} title="astro.config.mjs"
import { defineConfig } from 'astro/config';

export default defineConfig({
  experimental: {
    directRenderScript: true,
    globalRoutePriority: true,
    contentLayer: true,
    serverIslands: true,
    contentCollectionsCache: true,
    env: {
      schema: {...}
    }
  },
  env: {
      schema: {...}
  }
})
```

These features are all available by default in Astro v5.0.

<ReadMore>Read about these exciting features and more in [the v5.0 Blog post](https://astro.build/blog/astro-5/).</ReadMore>

## Changed Defaults

Some default behavior has changed in Astro v5.0 and your project code may need updating to account for these changes.

In most cases, the only action needed is to review your existing project's deployment and ensure that it continues to function as you expect, making updates to your code as necessary. In some cases, there may be a configuration setting to allow you to continue to use the previous default behavior.

### CSRF protection is now set by default

<SourcePR number="11788" title="change default value of checkOrigin"/>

In Astro v4.x, The default value of `security.checkOrigin` was `false`. Previously, you had to explicitly set this value to `true` to enable Cross-Site Request Forgery (CSRF) protection.

Astro v5.0 changes the default value of this option to `true`, and will automatically check that the "origin" header matches the URL sent by each request in on-demand rendered pages.

#### 무엇을 해야 하나요?

If you had previously configured `security.checkOrigin: true`, you no longer need this line in your Astro config. This is now the default.

To disable this behavior, you must explicitly set  `security.checkOrigin: false`.

```js title="astro.config.mjs" ins={3-5}
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: false
  }
})
```

<ReadMore>Read more about [security configuration options](/en/reference/configuration-reference/#security)</ReadMore>

### Route priority order for injected routes and redirects

<SourcePR number="11798" title="Remove legacy route prioritization"/>

In Astro v4.x, `experimental.globalRoutePriority` was an optional flag that ensured that injected routes, file-based routes, and redirects were all prioritized using the [route priority order rules for all routes](/en/guides/routing/#route-priority-order). This allowed more control over routing in your project by not automatically prioritizing certain kinds of routes and standardizing the route priority order.

Astro v5.0 removes this experimental flag and makes this the new default behavior in Astro: redirects and injected routes are now prioritized equally alongside file-based project routes.

Note that this was already the default behavior in Starlight, and should not affect updated Starlight projects.

#### 무엇을 해야 하나요?

If your project includes injected routes or redirects, please check that your routes are building page URLs as expected. An example of the new expected behavior is shown below.

In a project containing the following routes:

- File-based route: `/blog/post/[pid]`
- File-based route: `/[page]`
- Injected route: `/blog/[...slug]`
- Redirect: `/blog/tags/[tag] -> /[tag]`
- Redirect: `/posts -> /blog`

The following URLs will be built (instead of following the route priority order of Astro v4.x):

- `/blog/tags/astro` is built by the redirect to `/tags/[tag]` (instead of the injected route `/blog/[...slug]`)
- `/blog/post/0` is built by the file-based route `/blog/post/[pid]` (instead of the injected route `/blog/[...slug]`)
- `/posts` is built by the redirect to `/blog` (instead of the file-based route `/[page]`)

In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.

<ReadMore>Read more about the [route priority order rules](/en/guides/routing/#route-priority-order).</ReadMore>

### `<script>` tags are rendered directly as declared

<SourcePR number="11791" title="Make directRenderScript the default"/>

In Astro v4.x, `experimental.directRenderScript` was an optional flag to directly render `<scripts>` as declared in `.astro` files (including existing features like TypeScript, importing `node_modules`, and deduplicating scripts). This strategy prevented scripts from being executed in places where they were not used.

Astro 5.0 removes this experimental flag and makes this the new default behavior in Astro: scripts are no longer hoisted to the `<head>`, multiple scripts on a page are no longer bundled together, and a `<script>` tag may interfere with CSS styling.

#### 무엇을 해야 하나요?

Please review your `<script>` tags and ensure they behave as desired.

<ReadMore>Read more about [using `script` tags in Astro](/en/guides/client-side-scripts/#using-script-in-astro).</ReadMore>

## Breaking Changes

The following changes are considered breaking changes in Astro v5.0. Breaking changes may or may not provide temporary backwards compatibility. If you were using these features, you may have to update your code as recommended in each entry.

{/* If you need to refer to the documentation for a v4.x project, you can browse this [(unmaintained) snapshot of the docs from before v5.0 was released](https://docs-git-v3-docs-unmaintained-astrodotbuild.vercel.app/). */}

### Renamed: `<ViewTransitions />` component

<SourcePR number="11980" title="Rename the ViewTransitions component to ClientRouter"/>

In Astro 4.x, Astro's View Transitions API included a `<ViewTransitions />` router component to enable client-side routing, page transitions, and more.

Astro 5.0 renames this component to `<ClientRouter />` to clarify the role of the component within the API. This makes it more clear that the features you get from Astro's `<ClientRouter />` routing component are slightly different from the native CSS-based MPA router.

No functionality has changed. This component has only changed its name.

#### 무엇을 해야 하나요?

Replace all occurances of the `ViewTransitions` import and component with `ClientRouter`:

```astro title="src/layouts/MyLayout.astro" del={1,7} ins={2,8}
import { ViewTransitions } from 'astro:transitions';
import { ClientRouter } from 'astro:transitions';

<html>
  <head>
    ...
   <ViewTransitions />
   <ClientRouter />
  </head>
</html>
```

<ReadMore>Read more about [view transitions and client-side routing in Astro](/en/guides/view-transitions/).</ReadMore>


### Changed: TypeScript configuration

<SourcePR number="11859" title="better tsconfig"/>

In Astro v4.x, Astro relied on a `src/env.d.ts` file for type inferencing and defining modules for features that relied on generated types.

Astro 5.0 instead uses a `.astro/types.d.ts` file for type inferencing, and now recommends setting `include` and `exclude` in `tsconfig.json` to benefit from Astro types and avoid checking built files.

Running `astro sync` no longer creates, nor updates, `src/env.d.ts` as it is not required for type-checking standard Astro projects.

#### 무엇을 해야 하나요?

To update your project to Astro's recommended TypeScript settings, add the following `include` and `exclude` properties to your existing `tsconfig.json`:

```ts ins={3,4} title="tsconfig.json"
{
  "extends": "astro/tsconfigs/base",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}
```

Note that `src/env.d.ts` is only necessary if you have added custom configurations, or if you're not using a `tsconfig.json` file.

<ReadMore>Read more about [TypeScript configuration in Astro](/en/guides/typescript/#setup).</ReadMore>

### Changed: Actions submitted by HTML forms no longer use cookie redirects

<SourcePR number="12373" title="Actions middleware"/>

In Astro 4.x, actions called from an HTML form would trigger a redirect with the result forwarded using cookies. This caused issues for large form errors and return values that exceeded the 4 KB limit of cookie-based storage.

Astro 5.0 now renders the result of an action as a POST result without any forwarding. This will introduce a "confirm form resubmission?" dialog when a user attempts to refresh the page, though it no longer imposes a 4 KB limit on action return value.

#### 무엇을 해야 하나요?

You should update handling for action results that relies on redirects, and optionally address the "confirm form resubmission?" dialog with middleware.

##### To redirect to the previous route on error

If your HTML form action is directed to a different route (i.e. `action={"/success-page" + actions.name}`), Astro will no longer redirect to the previous route on error. You can implement this behavior manually using redirects from your Astro component. This example instead redirects to a new route on success, and handles errors on the current page otherwise:

```astro title="src/pages/newsletter.astro" ins={4-9} del="'/confirmation' + "
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.newsletter);
if (!result?.error) {
  // Embed relevant result data in the URL if needed
  // example: redirect(`/confirmation?email=${result.data.email}`);
  return redirect('/confirmation');
}
---

<form method="POST" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type="email" name="email" /></label>
  <button>Sign up</button>
</form>
```

##### (Optional) To remove the confirm dialog on refresh

To address the "confirm form resubmission?" dialog on refresh, or to preserve action results across sessions, you can now [customize action result handling from middleware](/en/guides/actions/#advanced-persist-action-results-with-a-session).

We recommend using a session storage provider [as described in our Netlify Blob example](/en/guides/actions/#advanced-persist-action-results-with-a-session). However, if you prefer the cookie forwarding behavior from 4.X and accept the 4 KB size limit, you can implement the pattern as shown in this sample snippet:

```ts title="src/middleware.ts"
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  // Skip requests for prerendered pages
  if (context.isPrerendered) return next();

	const { action, setActionResult, serializeActionResult } = getActionContext(context);

	// If an action result was forwarded as a cookie, set the result
	// to be accessible from `Astro.getActionResult()`
	const payload = context.cookies.get('ACTION_PAYLOAD');
	if (payload) {
		const { actionName, actionResult } = payload.json();
		setActionResult(actionName, actionResult);
		context.cookies.delete('ACTION_PAYLOAD');
		return next();
	}

	// If an action was called from an HTML form action,
	// call the action handler and redirect with the result as a cookie.
	if (action?.calledFrom === 'form') {
		const actionResult = await action.handler();

		context.cookies.set('ACTION_PAYLOAD', {
			actionName: action.name,
			actionResult: serializeActionResult(actionResult),
		});

		if (actionResult.error) {
		// Redirect back to the previous page on error
			const referer = context.request.headers.get('Referer');
			if (!referer) {
				throw new Error('Internal: Referer unexpectedly missing from Action POST request.');
			}
			return context.redirect(referer);
		}
		// Redirect to the destination page on success
		return context.redirect(context.originPathname);
	}

	return next();
})
```

### Changed: `compiledContent()` is now an async function

<SourcePR number="11782" title="Remove TLA by making compiledContent async"/>

In Astro 4.x, top level await was included in Markdown modules. This caused some issues with custom image services and images inside Markdown, causing Node to suddenly exit with no error message.

Astro 5.0 makes the `compiledContent()` property on Markdown import an async function, requiring an `await` to resolve the content.

#### 무엇을 해야 하나요?

Update your code to use `await` when calling `compiledContent()`.

```astro title="src/pages/post.astro" del={4} ins={5}
---
import * as myPost from "../blog/post.md";

const content = myPost.compiledContent();
const content = await myPost.compiledContent();
---

<Fragment set:html={content} />
```

<ReadMore>Read more about the [`compiledContent()` function](/en/guides/markdown-content/#importing-markdown) for returning compiled Markdown.</ReadMore>

### Changed: `astro:content` can no longer be used on the client

<SourcePR number="11827" title="Prevent usage of `astro:content` in the client "/>

In Astro 4.x, it was possible to access the `astro:content` module on the client.

Astro 5.0 removes this access as it was never intentionally exposed for client use. Using `astro:content` this way had limitations and bloated client bundles.

#### 무엇을 해야 하나요?

If you are currently currently using `astro:content` in the client, pass the data you need through props to your client components instead:

```astro title="src/pages/blog.astro"
---
import { getCollection } from 'astro:content';
import ClientComponent from '../components/ClientComponent';

const posts = await getCollection('blog');
const postsData = posts.map(post => post.data);
---

<ClientComponent posts={postsData} />
```

<ReadMore>Read more about [the `astro:content` API](/en/reference/modules/astro-content/).</ReadMore>

### Renamed: Shiki `css-variables` theme color token names

<SourcePR number="11661" title="Update to new shiki token names"/>

In Astro v4.x, the Shiki `css-variables` theme used the `--astro-code-color-text` and `--astro-code-color-background` tokens for styling the foreground and background colors of code blocks respectively.

Astro v5.0 renames them to `--astro-code-foreground` and `--astro-code-background` respectively to better align with the Shiki v1 defaults.

#### 무엇을 해야 하나요?

You can perform a global find and replace in your project to migrate to the new token names.

```css title="src/styles/global.css" del={2,3} ins={4,5}
:root {
  --astro-code-color-text: #000;
  --astro-code-color-background: #fff;
  --astro-code-foreground: #000;
  --astro-code-background: #fff;
}
```

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: internal Shiki rehype plugin for highlighting code blocks

<SourcePR number="11825" title="Refactor createShikiHighlighter"/>

In Astro 4.x, Astro's internal Shiki rehype plugin highlighted code blocks as HTML.

Astro 5.0 updates this plugin to highlight code blocks as hast. This allows a more direct Markdown and MDX processing and improves the performance when building the project. However, this may cause issues with existing Shiki transformers.

#### 무엇을 해야 하나요?

If you are using Shiki transformers passed to `markdown.shikiConfig.transformers`, you must make sure they do not use the `postprocess` hook. This hook no longer runs on code blocks in `.md` and `.mdx` files. (See [the Shiki documentation on transformer hooks](https://shiki.style/guide/transformers#transformer-hooks) for more information).

Code blocks in `.mdoc` files and Astro's built-in `<Code />` component do not use the internal Shiki rehype plugin and are unaffected.

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: Automatic `charset=utf-8` behavior for Markdown and MDX pages

<SourcePR number="12231" title="Unset charset=utf-8 content-type for md/mdx pages"/>

In Astro 4.0, Markdown and MDX pages (located in `src/pages/`) automatically responded with `charset=utf-8` in the `Content-Type` header, which allowed rendering non-ASCII characters in your pages.

Astro 5.0 updates the behaviour to add the `<meta charset="utf-8">` tag instead, and only for pages that do not use Astro's special `layout` frontmatter property. Similarly for MDX pages, Astro will only add the tag if the MDX content does not import a wrapping `Layout` component.

If your Markdown or MDX pages use the `layout` frontmatter property, or if the MDX page content imports a wrapping `Layout` component, then the HTML encoding will be handled by the designated layout component instead, and the `<meta charset="utf-8">` tag will not be added to your page by default.

#### 무엇을 해야 하나요?

If you require `charset=utf-8` to render your page correctly, make sure that your layout components contain the `<meta charset="utf-8">` tag. You may need to add this if you have not already done so.

<ReadMore>Read more about [Markdown layouts](/en/basics/layouts/#markdown-layouts).</ReadMore>

### Changed: Astro-specific metadata attached in remark and rehype plugins

<SourcePR number="11861" title="Clean up Astro metadata in vfile.data"/>

In Astro 4.x, the Astro-specific metadata attached to `vfile.data` in remark and rehype plugins was attached in different locations with inconsistent names.

Astro 5 cleans up the API and the metadata is now renamed as below:

 - `vfile.data.__astroHeadings` -> `vfile.data.astro.headings`
 - `vfile.data.imagePaths` -> `vfile.data.astro.imagePaths`

The types of `imagePaths` has also been updated from `Set<string>` to `string[]`. The `vfile.data.astro.frontmatter` metadata is left unchanged.

#### 무엇을 해야 하나요?

While we don't consider these APIs public, they can be accessed by remark and rehype plugins that want to re-use Astro's metadata. If you are using these APIs, make sure to access them in the new locations.

<ReadMore>Read more about [using Markdown plugins in Astro](/en/guides/markdown-content/#markdown-plugins).</ReadMore>

### Changed: image endpoint configuration

<SourcePR number="11908" title="Allow customising the route of the image endpoint"/>

In Astro 4.x, you could set an endpoint in your `image` configuration to use for image optimization.

Astro 5.0 allows you to customize a `route` and `entrypoint` of the `image.endpoint` config. This can be useful in niche situations where the default route `/_image` conflicts with an existing route or your local server setup.

#### 무엇을 해야 하나요?

If you had previously customized `image.endpoint`, move this endpoint to the new `endpoint.entrypoint` property. Optionally, you may customize a `route`:

```js title="astro.config.mjs" del={5} ins={6-9}
import { defineConfig } from "astro/config";

defineConfig({
  image: {
    endpoint: './src/image-endpoint.ts',
    endpoint: {
      route: "/image",
      entrypoint: "./src/image_endpoint.ts"
    }
  },
})
```

<ReadMore>Read more about [setting an endpoint to use for image optimization](/en/reference/configuration-reference/#imageendpoint).</ReadMore>

### Changed: `build.client` and `build.server` resolve behavior

<SourcePR number="11916" title="Fix build.client and build.server resolve behaviour" />

In Astro v4.x, the `build.client` and `build.server` options were documented to resolve relatively from the `outDir` option, but it didn't always work as expected.

Astro 5.0 fixes the behavior to correctly resolve from the `outDir` option. For example, if `outDir` is set to `./dist/nested/`, then by default:

- `build.client` will resolve to `<root>/dist/nested/client/`
- `build.server` will resolve to `<root>/dist/nested/server/`

Previously the values were incorrectly resolved:

- `build.client` was resolved to `<root>/dist/nested/dist/client/`
- `build.server` was resolved to `<root>/dist/nested/dist/server/`

#### 무엇을 해야 하나요?

If you were relying on the previous build paths, make sure that your project code is updated to the new build paths.

<ReadMore>Read more about [`build` configuration options in Astro](/en/reference/configuration-reference/#build-options).</ReadMore>

### Changed: JS dependencies in config file are no longer processed by Vite

<SourcePR number="11819" title="Set external: true when loading astro config"/>

In Astro 4.x, locally-linked JS dependencies (e.g. `npm link`, in a monorepo, etc) were able to use Vite features like `import.meta.glob` when imported by the Astro config file.

Astro 5 updates the Astro config loading flow to ignore processing locally-linked JS dependencies with Vite. Dependencies exporting raw TypeScript files are unaffected. Instead, these JS dependencies will be normally imported by the Node.js runtime the same way as other dependencies from `node_modules`.

This change was made as the previous behavior caused confusion among integration authors who tested against a package that worked locally, but not when published. It also restricted using CJS-only dependencies because Vite required the code to be ESM. While this change only affects JS dependencies, it's also recommended for packages to export JavaScript instead of raw TypeScript where possible to prevent accidental Vite-specific usage as it's an implementation detail of Astro's config loading flow.

#### 무엇을 해야 하나요?

Make sure your locally-linked JS dependencies are built before running your Astro project. Then, the config loading should work as before.

<ReadMore>Read more about [Vite configuration settings in Astro](/en/reference/configuration-reference/#vite).</ReadMore>

### Changed: URLs returned by `paginate()`

<SourcePR number="11253" title="Add base to paginate"/>

In Astro v4.x, the URL returned by `paginate()` (e.g. `page.url.next`, `page.url.first`, etc.) did not include the value set for `base` in your Astro config. You had to manually prepend your configured value for `base` to the URL path.

Astro 5.0 automatically includes the `base` value in `page.url`.

#### 무엇을 해야 하나요?

If you are using the `paginate()` function for these URLs, remove any existing `base` value as it is now added for you:

```astro del={16} ins={17}
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  return paginate(astronautPages, { pageSize: 1 });
}
const { page } = Astro.props;
// `base: /'docs'` configured in `astro.config.mjs`
const prev = "/docs" + page.url.prev;
const prev = page.url.prev;
---
<a id="prev" href={prev}>Back</a>
```

<ReadMore>Read more about [pagination in Astro](/en/guides/routing/#pagination).</ReadMore>

### Changed: non-boolean HTML attribute values

<SourcePR number="11660" title="Fix attribute rendering for boolean values (take 2)"/>

In Astro v4.x, non-[boolean HTML attributes](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML) may not have included their values when rendered to HTML.

Astro v5.0 renders the values explicitly as `="true"` or `="false"`, matching proper attribute handling in browsers.

In the following `.astro` examples, only `allowfullscreen` is a boolean attribute:

```astro
<!-- src/pages/index.astro -->
<!-- `allowfullscreen` is a boolean attribute -->
<p allowfullscreen={true}></p>
<p allowfullscreen={false}></p>
<!-- `inherit` is *not* a boolean attribute -->
<p inherit={true}></p>
<p inherit={false}></p>
<!-- `data-*` attributes are not boolean attributes -->
<p data-light={true}></p>
<p data-light={false}></p>
```

Astro v5.0 now preserves the full data attribute with its value when rendering the HTML of non-boolean attributes:

```astro del={5,8,10} ins={6,9,11}
<p allowfullscreen></p>
<p></p>

<p inherit="true"></p>
<p inherit></p>
<p inherit="false"></p>

<p data-light></p>
<p data-light="true"></p>
<p></p>
<p data-light="false"></p>
```

#### 무엇을 해야 하나요?

If you rely on attribute values, for example, to locate elements or to conditionally render, update your code to match the new non-boolean attribute values:

```js del={1,4} ins={2,5}
el.getAttribute('inherit') === ''
el.getAttribute('inherit') === 'false'

el.hasAttribute('data-light')
el.dataset.light === 'true'
```

<ReadMore>Read more about [using HTML attributes in Astro](/en/reference/astro-syntax/#dynamic-attributes).</ReadMore>

### Changed: adding values to `context.locals`

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, it was possible to completely replace the entire `locals` object in middleware, API endpoints, and pages when adding new values.

Astro 5.0 requires you to append values to the existing `locals` object without deleting it. Locals in middleware, API endpoints, and pages, can no longer be completely overridden.

#### 무엇을 해야 하나요?

Where you previously were overwriting the object, you must now instead assign values to it:

```js title="src/middleware.js" del={1,5} ins={2,6}
ctx.locals = {
Object.assign(ctx.locals, {
  one: 1,
  two: 2
}
})
```
<ReadMore>See more about [storing data in `context.locals`](/en/guides/middleware/#storing-data-in-contextlocals).</ReadMore>

### Changed: `params` no longer decoded

<SourcePR number="12079" title="decode pathname early, don't decode params"/>

In Astro v4.x, `params` passed to `getStaticPath()` were automatically decoded using `decodeURIComponent`.

Astro v5.0 no longer decodes the value of `params` passed to `getStaticPaths`. You must manually decode them yourself if needed.

#### 무엇을 해야 하나요?

If you were previously relying on the automatic decoding, use `decodeURI` when passing `params`.


```astro title="src/pages/[id].astro" del={4} ins={5}
---
export function getStaticPaths() {
  return [
    { params: { id: "%5Bpage%5D" } },
    { params: { id: decodeURI("%5Bpage%5D") } },
  ]
}

const { id } = Astro.params;
---
```

Note that the use of [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent)) is discouraged for `getStaticPaths` because it decodes more characters than it should, for example `/`, `?`, `#` and more.

<ReadMore>Read more about [creating dynamic routes with `params`](/en/guides/routing/#static-ssg-mode).</ReadMore>

### Changed: `RouteData` type replaced by `IntegrationsRouteData` (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, the `entryPoints` type inside the `astro:build:ssr` and `astro:build:done` hooks was `RouteData`.

Astro v5.0 the `entryPoints` type is now `IntegrationRouteData`, which contains a subset of the `RouteData` type. The fields `isIndex` and `fallbackRoutes` were removed.

#### 무엇을 해야 하나요?

Update your adapter to change the type of `entryPoints` from `RouteData` to `IntegrationRouteData`.

```js del={1,4} ins={2,5}
import type {RouteData} from 'astro';
import type {IntegrationRouteData} from "astro"

function useRoute(route: RouteData) {
function useRoute(route: IntegrationRouteData) {
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: `distURL` is now an array (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, `RouteData.distURL` was `undefined` or a `URL`

Astro v5.0 updates the shape of `IntegrationRouteData.distURL` to be `undefined` or an array of `URL`s. This fixes a previous error because a route can generate multiple files on disk, especially when using dynamic routes such as `[slug]` or `[...slug]`.

#### 무엇을 해야 하나요?

Update your code to handle `IntegrationRouteData.distURL` as an array.

```js del={2-4} ins={5-9}
if (route.distURL) {
  if (route.distURL.endsWith('index.html')) {
    // do something
  }
  for (const url of route.distURL) {
    if (url.endsWith('index.html')) {
      // do something
    }
  }
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: Arguments passed to `app.render()` (Adapter API)

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, The Adapter API method `app.render()` could receive three arguments: a mandatory `request`, an object of options or a `routeData` object, and `locals`.

Astro 5.0 combines these last two arguments into a single options argument named `renderOptions`.

#### 무엇을 해야 하나요?

Pass an object as the second argument to `app.render()`, which can include `routeData` and `locals` as properties.

```js del={1} ins={2}
const response = await app.render(request, routeData, locals);
const response = await app.render(request, {routeData, locals});
```

<ReadMore>See the [Adapter API reference for `renderOptions`](/en/reference/adapter-reference/#renderoptions).</ReadMore>

### Changed: Properties on `supportedAstroFeatures` (Adapter API)

<SourcePR number="11806" title="rework supportedAstroFeatures"/>

In Astro 4.x, `supportedAstroFeatures`, which allows adapter authors to specify which features their integration supports, included an `assets` property to specify which of Astro's image services were supported.

Astro 5.0 replaces this property with a dedicated `sharpImageService` property, used to determine whether the adapter is compatible with the built-in sharp image service.

v5.0 also adds a new `limited` value for the different properties of `supportedAstroFeatures` for adapters, which indicates that the adapter is compatible with the feature, but with some limitations. This is useful for adapters that support a feature, but not in all cases or with all options.

Additionally, the value of the different properties on `supportedAstroFeatures` for adapters can now be objects, with `support` and `message` properties. The content of the `message` property will show a helpful message in the Astro CLI when the adapter is not compatible with a feature. This is notably useful with the new `limited` value, to explain to the user why support is limited.

#### 무엇을 해야 하나요?

If you were using the `assets` property, remove this as it is no longer available. To specify that your adapter supports the built-in sharp image service, replace this with `sharpImageService`.

You may also wish to update your supported features with the new `limited` option and include a message about your adapter's support.

```ts title="my-adapter.mjs" del={2-6} ins={7-10}
supportedAstroFeatures: {
  assets: {
    supportKind: "stable",
    isSharpCompatible: true,
    isSquooshCompatible: true,
  },
  sharpImageService: {
    support: "limited",
    message: 'This adapter supports the built-in sharp image service, but with some limitations.'
  }
}
```

<ReadMore>Read more about [specifying supported Astro features in an adapter](/en/reference/adapter-reference/#astro-features).</ReadMore>

### 제거됨: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)

<SourcePR number="11987" title="Remove deprecated dev toolbar app shape"/>

In Astro 4.x, when building a dev toolbar app, it was still possible to use the previously deprecated `addDevToolbarApp(string);` signature. The `id`, `title`, and `icon` properties to define the app were then made available through the default export of the app's `entrypoint`.

Astro 5.0 completely removes this option entirely in favor of the current object shape when defining a dev toolbar app in an integration that's more intuitive and allows Astro to provide better errors when toolbar apps fail to load correctly.

#### 무엇을 해야 하나요?

If you were using the deprecated shape, update your dev toolbar app to use the new shape:

```js title="my-integration.mjs" del={1-2} ins={4-10}
// Old shape
addDevToolbarApp("./my-app.js");

// New shape
addDevToolbarApp({
  id: "my-app",
  name: "My App",
  icon: "<svg>...</svg>",
  entrypoint: "./my-app.js",
});
```

```js title="my-dev-toolbar-app.mjs" del={2-4}
export default {
  id: 'my-dev-toolbar-app',
  title: 'My Dev Toolbar App',
  icon: '🚀',
  init() {
    // ...
  }
}
```

<ReadMore>Read more about [developing a dev toolbar app for Astro using the Dev Toolbar API](/en/reference/dev-toolbar-app-reference/).</ReadMore>

### 제거됨: configuring Typescript during `create-astro`

<SourcePR number="12083" title="create-astro updates"/>

In Astro v4.x, it was possible to choose between Astro's three TypeScript settings when creating a new project using `create astro`, either by answering a question or by passing an associated `--typescript` flag with the desired TypeScript setting. 

Astro 5.0 updates the `create astro` CLI command to remove the TypeScript question and its associated `--typescript` flag. The "strict" preset is now the default for all new projects created with the command line and it is no longer possible to customize this at that time. However, the TypeScript template can still be changed manually in `tsconfig.json`.

#### 무엇을 해야 하나요?

If you were using the `--typescript` flag with `create-astro`, remove it from your command.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```diff lang=shell
  -npm create astro@latest -- --template <example-name> --typescript strict
  +npm create astro@latest -- --template <example-name>
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```diff lang=shell
  -pnpm create astro@latest --template <example-name> --typescript strict
  +pnpm create astro@latest --template <example-name>
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```diff lang=shell
  -yarn create astro --template <example-name> --typescript strict
  +yarn create astro --template <example-name>
  ```
  </Fragment>
</PackageManagerTabs>

<ReadMore>See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md)</ReadMore>

## Community Resources

Know a good resource for Astro v5.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v5.mdx) and add a link below!

## Known Issues

Please check [Astro's issues on GitHub](https://github.com/withastro/astro/issues/) for any reported issues, or to file an issue yourself.
