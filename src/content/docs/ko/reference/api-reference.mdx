---
title: Astro 렌더링 컨텍스트
sidebar:
  label: 렌더링 컨텍스트
i18nReady: true
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 4
---
import Since from '~/components/Since.astro';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import ReadMore from '~/components/ReadMore.astro';

페이지를 렌더링할 때 Astro는 현재 렌더링에 특정한 런타임 API를 제공합니다. 여기에는 현재 페이지 URL과 같은 유용한 정보와 다른 페이지로 리디렉션하는 등의 작업을 수행하는 API가 포함됩니다.

`.astro` 컴포넌트에서 이 컨텍스트는 `Astro` 전역 객체에서 사용할 수 있습니다. 엔드포인트 함수도 이 동일한 컨텍스트 객체를 첫 번째 인수로 사용하여 호출되며, 그 속성은 Astro 전역 속성을 반영합니다.

일부 속성은 요청 시 렌더링되는 경로에서만 사용할 수 있거나 미리 렌더링된 페이지에서 기능이 제한될 수 있습니다.

`Astro` 전역 객체는 모든 `.astro` 파일에서 사용할 수 있습니다. 정적 또는 라이브 서버 엔드포인트를 제공하려면 [엔드포인트 함수](/ko/guides/endpoints/)에서, 페이지 또는 엔드포인트가 렌더링될 때 동작을 삽입하려면 [미들웨어](/ko/guides/middleware/)에서 `context` 객체를 사용합니다.

## 컨텍스트 객체

다음 프로퍼티는 `Astro` 전역(예: `Astro.props`, `Astro.redirect()`)에서 사용할 수 있으며 엔드포인트 함수 및 미들웨어에 전달되는 컨텍스트 객체(예: `context.props`, `context.redirect()`)에서도 사용할 수 있습니다.

### `props`

`props`는 [컴포넌트 속성](/ko/basics/astro-components/#컴포넌트-props)으로 전달된 값을 포함하는 객체입니다.

```astro {3}
---
// src/components/Heading.astro
const { title, date } = Astro.props;
---
<div>
  <h1>{title}</h1>
  <p>{date}</p>
</div>
```

```astro "title=" "date="
---
// src/pages/index.astro
import Heading from '../components/Heading.astro';
---
<Heading title="My First Post" date="09 Aug 2022" />
```

<ReadMore>[Markdown 및 MDX 레이아웃](/ko/guides/markdown-content/#프런트매터-레이아웃-속성)이 props를 처리하는 방법에 대해 자세히 알아보세요.</ReadMore>

`props` 객체에는 정적 경로를 렌더링할 때 `getStaticPaths()`에서 전달된 모든 `props`도 포함됩니다.

<Tabs>
  <TabItem label="Astro.props">
    ```astro title="src/pages/posts/[id].astro" "props:" {11}
    ---
    export function getStaticPaths() {
      return [
        { params: { id: '1' }, props: { author: 'Blu' } },
        { params: { id: '2' }, props: { author: 'Erika' } },
        { params: { id: '3' }, props: { author: 'Matthew' } }
      ];
    }

    const { id } = Astro.params;
    const { author } = Astro.props;
    ---
    ```
  </TabItem>
  <TabItem label="context.props">
    ```ts title="src/pages/posts/[id].json.ts" "props:" {11-15}
    import type { APIContext } from 'astro';

    export function getStaticPaths() {
      return [
        { params: { id: '1' }, props: { author: 'Blu' } },
        { params: { id: '2' }, props: { author: 'Erika' } },
        { params: { id: '3' }, props: { author: 'Matthew' } }
      ];
    }

    export function GET({ props }: APIContext) {
      return new Response(
        JSON.stringify({ author: props.author }),
      );
    }
    ```
  </TabItem>

</Tabs>
더 보기: [`props`로 데이터 전달](/ko/reference/routing-reference/#props로-데이터-전달)

### `params`

`params`는 요청과 일치하는 동적 경로 세그먼트의 값을 포함하는 객체입니다. 해당 키는 페이지 또는 엔드포인트 파일 경로의 [매개변수](/ko/guides/routing/#동적-경로)와 일치해야 합니다.

정적 빌드에서는 [동적 경로](/ko/guides/routing/#동적-경로)를 미리 렌더링하는데 사용되는 `getStaticPaths()`가 반환하는 `params`가 됩니다.

<Tabs>
  <TabItem label="Astro.params">
    ```astro title="src/pages/posts/[id].astro" {9} "params:"
    ---
    export function getStaticPaths() {
      return [
        { params: { id: '1' } },
        { params: { id: '2' } },
        { params: { id: '3' } }
      ];
    }
    const { id } = Astro.params;
    ---
    <h1>{id}</h1>
    ```
  </TabItem>
  <TabItem label="context.params">
    ```ts title="src/pages/posts/[id].json.ts" "params:" {11-15}
    import type { APIContext } from 'astro';

    export function getStaticPaths() {
      return [
        { params: { id: '1' } },
        { params: { id: '2' } },
        { params: { id: '3' } }
      ];
    }

    export function GET({ params }: APIContext) {
      return new Response(
        JSON.stringify({ id: params.id }),
      );
    }
    ```
  </TabItem>
</Tabs>

경로가 요청 시 렌더링될 때 `params`는 동적 경로 패턴의 경로 세그먼트와 일치하는 임의의 값일 수 있습니다.

```astro title="src/pages/posts/[id].astro" "Astro.params"
---
import { getPost } from '../api';

const post = await getPost(Astro.params.id);

// ID로 게시물을 찾을 수 없는 경우
if (!post) {
  return Astro.redirect("/404")
}
---
<html>
  <h1>{post.name}</h1>
</html>
```

더 보기: [`params`](/ko/reference/routing-reference/#params)

### `url`

<p>

**타입:** `URL`<br />
<Since v="1.0.0" />
</p>

`url`은 현재 `request.url` 값으로 구성된 [URL](https://developer.mozilla.org/ko/docs/Web/API/URL) 객체입니다. pathname 및 origin과 같은 요청 URL의 개별 속성과 상호 작용할 때 유용합니다. 

`Astro.url`은 `new URL(Astro.request.url)`을 수행하는 것과 동일합니다.

개발 모드에서 `url`은 `localhost` URL이 됩니다. 사이트를 빌드할 때 미리 렌더링된 경로는 [`site`](/ko/reference/configuration-reference/#site) 및 [`base`](/ko/reference/configuration-reference/#base) 옵션에 기반한 URL을 받게 됩니다. `site`가 구성되지 않은 경우 미리 렌더링된 페이지도 빌드 중에 `localhost` URL을 받게 됩니다.

```astro title="src/pages/index.astro" "Astro.url"
<h1>The current URL is: {Astro.url}</h1>
<h1>The current URL pathname is: {Astro.url.pathname}</h1>
<h1>The current URL origin is: {Astro.url.origin}</h1>
```

`url`을 [`new URL()`](https://developer.mozilla.org/ko/docs/Web/API/URL/URL)의 인자로 전달하여 새 URL을 만들 수도 있습니다.

```astro title="src/pages/index.astro" "Astro.url"
---
// 예시: 프로덕션 도메인을 사용하여 canonical URL 생성
const canonicalURL = new URL(Astro.url.pathname, Astro.site);
// 예시: 현재 도메인을 사용하여 SEO 메타 태그의 URL 생성
const socialImageURL = new URL('/images/preview.png', Astro.url);
---
<link rel="canonical" href={canonicalURL} />
<meta property="og:image" content={socialImageURL} />
```

### `site`

<p>

**타입:** `URL | undefined`
</p>

`site`는 Astro 구성의 `site`에서 만든 `URL`을 반환합니다. Astro 구성에서 [`site`](/ko/reference/configuration-reference/#site)에 대한 값을 설정하지 않은 경우 `undefined`를 반환합니다.

```astro title="src/pages/index.astro" "Astro.site"
<link
    rel="alternate"
    type="application/rss+xml"
    title="Your Site's Title"
    href={new URL("rss.xml", Astro.site)}
/>
```

### `clientAddress`

<p>

**타입:** `string`<br />
<Since v="1.0.0" />
</p>

`clientAddress`는 요청의 [IP 주소](https://en.wikipedia.org/wiki/IP_address)를 지정합니다. 이 속성은 요청 시 렌더링되는 경로에만 사용할 수 있으며 미리 렌더링된 페이지에는 사용할 수 없습니다.

<Tabs>
  <TabItem label="Astro.clientAddress">
    ```astro title="src/pages/ip-address.astro" "Astro.clientAddress"
    ---
    export const prerender = false; // 'server' 모드에서는 필요하지 않음
    ---

    <div>Your IP address is: <span class="address">{Astro.clientAddress}</span></div>
    ```
  </TabItem>
  <TabItem label="context.clientAddress">
    ```ts title="src/pages/ip-address.ts" "clientAddress"
    export const prerender = false; // 'server' 모드에서는 필요하지 않음
    import type { APIContext } from 'astro';

    export function GET({ clientAddress }: APIContext) {
      return new Response(`Your IP address is: ${clientAddress}`);
    }
    ```
  </TabItem>
</Tabs>

### `isPrerendered`

<p>

**타입**: `boolean`<br />
<Since v="5.0.0" />
</p>

현재 페이지가 미리 렌더링된 페이지인지 여부를 나타내는 부울입니다.

이 속성을 사용하여 미들웨어에서 조건부 로직을 실행할 수 있습니다(예: 미리 렌더링된 페이지의 헤더에 액세스하지 않도록 하기 위해).

### `generator`

<p>

**타입:** `string`<br />
<Since v="1.0.0" />
</p>

`generator`는 프로젝트가 실행 중인 Astro의 현재 버전을 제공합니다. 현재 사용 중인 Astro 버전과 함께 [`<meta name="generator">`](https://html.spec.whatwg.org/multipage/semantics.html#meta-generator) 태그를 추가하는 편리한 방법입니다. 이 태그는 `"Astro v5.x.x"` 형식을 따릅니다.

<Tabs>
  <TabItem label="Astro.generator">
    ```astro title="src/pages/site-info.astro" "Astro.generator"
    <html>
      <head>
        <meta name="generator" content={Astro.generator} />
      </head>
      <body>
        <footer>
          <p>Built with <a href="https://astro.build">{Astro.generator}</a></p>
        </footer>
      </body>
    </html>
    ```
  </TabItem>
  <TabItem label="context.generator">
    ```ts title="src/pages/site-info.json.ts" "generator"
    import type { APIContext } from 'astro';

    export function GET({ generator, site }: APIContext) {
      const body = JSON.stringify({ generator, site });
      return new Response(body);
    }
    ```
  </TabItem>
</Tabs>

### `request`

<p>

**타입:** `Request`
</p>

`request`는 표준 [Request](https://developer.mozilla.org/ko/docs/Web/API/Request) 객체입니다. 요청의 `url`, `headers`, `method`, 본문을 가져오는 데 사용할 수 있습니다. 

<Tabs>
  <TabItem label="Astro.request">
    ```astro wrap title="src/pages/index.astro" "Astro.request"
    <p>Received a {Astro.request.method} request to "{Astro.request.url}".</p>
    <p>Received request headers:</p>
    <p><code>{JSON.stringify(Object.fromEntries(Astro.request.headers))}</code></p>
    ```
  </TabItem>
  <TabItem label="context.request">
    ```ts "request"
    import type { APIContext } from 'astro';

    export function GET({ request }: APIContext) {
      return new Response(`Hello ${request.url}`);
    }
    ```
  </TabItem>
</Tabs>

:::note
미리 렌더링된 페이지에서는 `request.url`에 `?type=new`와 같은 검색 매개변수가 포함되지 않습니다. 정적 빌드 중에 값을 미리 결정할 수 없기 때문입니다. 그러나 요청 시 렌더링되는 페이지에서는 `request.url`에 검색 매개변수가 포함됩니다. 서버 요청으로부터 값을 결정할 수 있기 때문입니다.
:::

### `response`

<p>

**타입:** `ResponseInit & { readonly headers: Headers }`
</p>

`response`는 표준 `ResponseInit` 객체입니다. 다음과 같은 구조를 가집니다. 

 - `status`: 응답의 숫자 상태 코드(예: `200`).
 - `statusText`: 상태 코드와 연관된 상태 메시지(예: `'OK'`).
 - `headers`: 응답의 HTTP 헤더를 설정하는 데 사용할 수 있는 [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) 인스턴스.

`Astro.response`는 페이지의 응답의 `status`, `statusText`, `headers`를 설정하는 데 사용됩니다.

```astro "Astro.response"
---
if (condition) {
  Astro.response.status = 404;
  Astro.response.statusText = 'Not found';
}
---
```

헤더를 설정할 수도 있습니다:

```astro "Astro.response"
---
Astro.response.headers.set('Set-Cookie', 'a=b; Path=/;');
---
```

### `redirect()`

<p>

**타입:** `(path: string, status?: number) => Response`
<Since v="1.5.0" />
</p>

`redirect()`는 다른 페이지로 리디렉션할 수 있는 [Response](https://developer.mozilla.org/ko/docs/Web/API/Response) 객체를 반환하며, 선택적으로 [HTTP 응답 상태 코드](https://developer.mozilla.org/ko/docs/Web/HTTP/Status#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98_%EB%A9%94%EC%8B%9C%EC%A7%80)를 두 번째 파라미터로 제공합니다.

리디렉션이 발생하려면 하위 컴포넌트가 아닌 페이지가 `Astro.redirect()`의 결과를 `반환`해야 합니다.

정적으로 생성된 경로에서는 [`<meta http-equiv="refresh">` 태그](https://developer.mozilla.org/ko/docs/Web/HTML/Element/meta#http-equiv)를 사용하여 클라이언트 리디렉션을 생성하며 상태 코드는 지원하지 않습니다.

요청 시 렌더링되는 경로에서는 리디렉션 시 사용자 지정 상태 코드를 설정하는 것이 지원됩니다. 지정하지 않으면 리디렉션은 `302` 상태 코드와 함께 제공됩니다.

다음 예시는 사용자를 로그인 페이지로 리디렉션합니다:

<Tabs>
  <TabItem label="Astro.redirect()">
    ```astro title="src/pages/account.astro" {8} "Astro.redirect"
    ---
    import { isLoggedIn } from '../utils';

    const cookie = Astro.request.headers.get('cookie');

    // 사용자가 로그인하지 않았다면 로그인 페이지로 리디렉션합니다.
    if (!isLoggedIn(cookie)) {
      return Astro.redirect('/login');
    }
    ---
    
    <p>User information</p>
    ```
  </TabItem>
  <TabItem label="context.redirect()">
    ```ts "redirect"
    import type { APIContext } from 'astro';

    export function GET({ redirect, request }: APIContext) {
      const cookie = request.headers.get('cookie');
      if (!isLoggedIn(cookie)) {
        return redirect('/login', 302);
      } else {
        // 사용자의 정보를 반환합니다.
      }
    }
    ```
  </TabItem>
</Tabs>

### `rewrite()`

<p>

**타입:** `(rewritePayload: string | URL | Request) => Promise<Response>`<br />
<Since v="4.13.0" />
</p>

`rewrite()`를 사용하면 브라우저를 새 페이지로 리디렉션하지 않고 다른 URL 또는 경로의 콘텐츠를 제공할 수 있습니다. 

이 메서드는 경로 위치에 대한 문자열, `URL` 또는 `Request`를 받습니다.

명시적 경로를 제공하려면 문자열을 사용합니다:

<Tabs syncKey="rewrite">
  <TabItem label="Astro.rewrite()">
    ```astro title="src/pages/index.astro" "Astro.rewrite"
    ---
    return Astro.rewrite("/login")
    ---
    ```
  </TabItem>
  <TabItem label="context.rewrite()">
    ```ts "rewrite"
    import type { APIContext } from 'astro';

    export function GET({ rewrite }: APIContext) {
      return rewrite('/login');
    }
    ```
  </TabItem>
</Tabs>

리라이트를 위한 URL 경로를 구성해야 한다면 `URL` 타입을 사용합니다. 다음 예시는 상대 `"../"` 경로에서 새 URL을 생성하여 페이지의 상위 경로를 렌더링합니다:

<Tabs syncKey="rewrite">
  <TabItem label="Astro.rewrite()">
    ```astro title="src/pages/blog/index.astro"
    ---
    return Astro.rewrite(new URL("../", Astro.url))
    ---
    ```
  </TabItem>
  <TabItem label="context.rewrite()">
    ```ts
    import type { APIContext } from 'astro';

    export function GET({ rewrite }: APIContext) {
      return rewrite(new URL("../", Astro.url));
    }
    ```
  </TabItem>
</Tabs>

새 경로에 대해 서버로 전송되는 `Request`를 완벽하게 제어하려면 `Request` 타입을 사용합니다. 다음 예시는 상위 페이지를 렌더링하는 요청에 헤더를 포함하여 전송합니다:

<Tabs syncKey="rewrite">
  <TabItem label="Astro.rewrite()">
    ```astro title="src/pages/blog/index.astro"
    ---
    return Astro.rewrite(new Request(new URL("../", Astro.url), {
      headers: {
        "x-custom-header": JSON.stringify(Astro.locals.someValue)
      }
    }))
    ---
    ```
  </TabItem>
  <TabItem label="context.rewrite()">
    ```ts
    import type { APIContext } from 'astro';

    export function GET({ rewrite }: APIContext) {
      return rewrite(new Request(new URL("../", Astro.url), {
        headers: {
          "x-custom-header": JSON.stringify(Astro.locals.someValue)
        }
      }));
    }
    ```
  </TabItem>
</Tabs>

### `locals`

<p>

<Since v="2.4.0" />
</p>

`locals`는 요청의 수명 주기 동안 임의의 정보를 저장하고 액세스하는 데 사용되는 객체입니다. `Astro.locals`는 미들웨어가 설정한 `context.locals` 객체의 모든 값을 포함하는 객체입니다. 이를 사용하여 `.astro` 파일에서 미들웨어가 반환한 데이터에 액세스할 수 있습니다.

미들웨어 함수는 `context.locals`의 값을 읽고 쓸 수 있습니다:

```ts title="src/middleware.ts" "locals"
import type { MiddlewareHandler } from 'astro';

export const onRequest: MiddlewareHandler = ({ locals }, next) => {
  if (!locals.title) {
    locals.title = "Default Title";
  }
  return next();
}
```

Astro 컴포넌트와 API 엔드포인트는 렌더링할 때 `locals`에서 값을 읽을 수 있습니다:

<Tabs>
  <TabItem label="Astro.locals">
    ```astro title="src/pages/Orders.astro" "Astro.locals"
    ---
    const title = Astro.locals.title;
    ---
    <h1>{title}</h1>
    ```
  </TabItem>
  <TabItem label="context.locals">
    ```ts title="src/pages/hello.ts" "locals"
    import type { APIContext } from 'astro';

    export function GET({ locals }: APIContext) {
      return new Response(locals.title); // "Default Title"
    }
    ```
  </TabItem>
</Tabs>

### `preferredLocale`

<p>

**타입:** `string | undefined`<br />
<Since v="3.5.0" />
</p>

`preferredLocale`은 방문자의 브라우저 언어 기본 설정과 사이트에서 지원하는 로케일 간에 가장 잘 일치하는 것을 찾기 위해 계산된 값입니다.

이 값은 [`i18n.locales`](/ko/reference/configuration-reference/#i18nlocales) 배열에 구성된 로케일과 `Accept-Language` 헤더를 통해 사용자의 브라우저에서 지원하는 로케일을 확인하여 계산됩니다. 일치하는 항목이 없으면 이 값은 `undefined`입니다.

이 속성은 요청 시 렌더링되는 경로에서만 사용할 수 있으며 미리 렌더링된 정적 페이지에는 사용할 수 없습니다.

### `preferredLocaleList`

<p>

**타입:** `string[] | undefined`<br />
<Since v="3.5.0" />
</p>

`preferredLocaleList`는 브라우저에서 요청하고 웹사이트에서 지원하는 모든 로케일의 배열을 나타냅니다. 이렇게 하면 사이트와 방문자 간에 호환되는 모든 언어의 목록이 생성됩니다. 

브라우저에서 요청한 언어가 로케일 배열에 없으면 값은 `[]`가 됩니다. 이는 방문자가 선호하는 로케일을 지원하지 않을 때 발생합니다.

브라우저에 기본 설정 언어가 지정되지 않은 경우 이 값은 [`i18n.locales`](/ko/reference/configuration-reference/#i18nlocales)가 되며, 기본 설정이 없는 방문자에게는 지원되는 모든 로케일이 동일하게 기본 설정된 것으로 간주됩니다. 

이 속성은 요청 시 렌더링되는 경로에서만 사용할 수 있으며 미리 렌더링된 정적 페이지에는 사용할 수 없습니다.

### `currentLocale`

<p>

**타입:** `string | undefined`<br />
<Since v="3.5.6" />
</p>

<!-- TODO: 번역 이어서 -->
The locale computed from the current URL, using the syntax specified in your `locales` configuration. If the URL does not contain a `/[locale]/` prefix, then the value will default to [`i18n.defaultLocale`](/en/reference/configuration-reference/#i18ndefaultlocale).

### `getActionResult()`

<p>
**타입:** `(action: TAction) => ActionReturnType<TAction> | undefined`<br />
<Since v="4.15.0" />
</p>

`getActionResult()` is a function that returns the result of an [Action](/en/guides/actions/) submission. This accepts an action function as an argument (e.g. `actions.logout`) and returns a `data` or `error` object when a submission is received. Otherwise, it will return `undefined`.

```astro title="src/pages/index.astro" "Astro.getActionResult"
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.logout);
---

<form action={actions.logout}>
  <button type="submit">Log out</button>
</form>
{result?.error && <p>Failed to log out. Please try again.</p>}
```

### `callAction()`

<p>
<Since v="4.15.0" />
</p>

`callAction()` is a function used to call an Action handler directly from your Astro component. This function accepts an Action function as the first argument (e.g. `actions.logout`) and any input that action receives as the second argument. It returns the result of the action as a promise.

```astro title="src/pages/index.astro" "Astro.callAction"
---
import { actions } from 'astro:actions';

const { data, error } = await Astro.callAction(actions.logout, { userId: '123' });
---
```

### `routePattern`

<p>

**타입**: `string`<br />
<Since v="5.0.0" />
</p>

The route pattern responsible for generating the current page or route. In file-based routing, this resembles the file path in your project used to create the route. When integrations create routes for your project, `context.routePattern` is identical to the value for `injectRoute.pattern`.

The value will start with a leading slash and look similar to the path of a page component relative to your `srcDir/pages/` folder without a file extension.

For example, the file `src/pages/en/blog/[slug].astro` will return `/en/blog/[slug]` for `routePattern`. Every page on your site generated by that file (e.g. `/en/blog/post-1/`, `/en/blog/post-2/`, etc.) shares the same value for `routePattern`. In the case of `index.*` routes, the route pattern will not include the word "index." For example, `src/pages/index.astro` will return `/`.

You can use this property to understand which route is rendering your component. This allows you to target or analyze similarly-generated page URLs together. For example, you can use it to conditionally render certain information, or collect metrics about which routes are slower.

### `cookies`

<p>

**타입:** `AstroCookies`<br />
<Since v="1.4.0" />
</p>

`cookies` contains utilities for reading and manipulating cookies for [routes rendered on demand](/en/guides/on-demand-rendering/).

#### Cookie utilities

##### `cookies.get()`

<p>

**타입:** <code>(key: string, options?: <a href="#astrocookiegetoptions">AstroCookieGetOptions</a>) => <a href="#astrocookie-type">AstroCookie</a> | undefined</code>
</p>

Gets the cookie as an [`AstroCookie`](#astrocookie-type) object, which contains the `value` and utility functions for converting the cookie to non-string types.

##### `cookies.has()`

<p>

**타입:** <code>(key: string, options?: <a href="#astrocookiegetoptions">AstroCookieGetOptions</a>) => boolean</code>
</p>

Whether this cookie exists. If the cookie has been set via `Astro.cookies.set()` this will return true, otherwise, it will check cookies in the `Astro.request`.

##### `cookies.set()`

<p>

**타입:** <code>(key: string, value: string | object, options?: <a href="#astrocookiesetoptions">AstroCookieSetOptions</a>) => void</code>
</p>

Sets the cookie `key` to the given value. This will attempt to convert the cookie value to a string. Options provide ways to set [cookie features](https://www.npmjs.com/package/cookie#options-1), such as the `maxAge` or `httpOnly`.

##### `cookies.delete()`

<p>

**타입:** `(key: string, options?: AstroCookieDeleteOptions) => void`
</p>

Invalidates a cookie by setting the expiration date in the past (0 in Unix time).

Once a cookie is "deleted" (expired), `Astro.cookies.has()` will return `false` and `Astro.cookies.get()` will return an [`AstroCookie`](#astrocookie-type) with a `value` of `undefined`. Options available when deleting a cookie are: `domain`, `path`, `httpOnly`, `sameSite`, and `secure`.

##### `cookies.merge()`

<p>

**타입:** `(cookies: AstroCookies) => void`
</p>

Merges a new `AstroCookies` instance into the current instance. Any new cookies will be added to the current instance and any cookies with the same name will overwrite existing values.

##### `cookies.headers()`

<p>

**타입:** `() => Iterator<string>`
</p>

Gets the header values for `Set-Cookie` that will be sent out with the response.

#### `AstroCookie` Type

The type returned from getting a cookie via `Astro.cookies.get()`. It has the following properties:

##### `value`

<p>

**타입:** `string`
</p>

The raw string value of the cookie.

##### `json`

<p>

**타입:** `() => Record<string, any>`
</p>

Parses the cookie value via `JSON.parse()`, returning an object. Throws if the cookie value is not valid JSON.

##### `number`

<p>

**타입:** `() => number`
</p>

Parses the cookie value as a Number. Returns NaN if not a valid number.

##### `boolean`

<p>

**타입:** `() => boolean`
</p>

Converts the cookie value to a boolean.

#### `AstroCookieGetOptions`

<p><Since v="4.1.0"/></p>

The `AstroCookieGetOption` interface allows you to specify options when you get a cookie.

##### `decode`

<p>
**타입:** `(value: string) => string`
</p>

Allows customization of how a cookie is deserialized into a value.

#### `AstroCookieSetOptions`

<p><Since v="4.1.0"/></p>

`AstroCookieSetOptions` is an object that can be passed to `Astro.cookies.set()` when setting a cookie to customize how the cookie is serialized.

##### `domain`

<p>

**타입:** `string`
</p>

Specifies the domain. If no domain is set, most clients will interpret to apply to the current domain.

##### `expires`

<p>

**타입:** `Date`
</p>

Specifies the date on which the cookie will expire.

##### `httpOnly`

<p>

**타입:** `boolean`
</p>

If true, the cookie will not be accessible client-side.

##### `maxAge`

<p>

**타입:** `number`
</p>

Specifies a number, in seconds, for which the cookie is valid.

##### `path`

<p>

**타입:** `string`
</p>

Specifies a subpath of the domain in which the cookie is applied.

##### `sameSite`

<p>

**타입:** `boolean | 'lax' | 'none' | 'strict'`
</p>

Specifies the value of the [SameSite](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7) cookie header.

##### `secure`

<p>

**타입:** `boolean`
</p>

If true, the cookie is only set on https sites.

##### `encode`

<p>

**타입:** `(value: string) => string`
</p>

Allows customizing how the cookie is serialized.


### Deprecated object properties

#### `Astro.glob()`

:::caution[Deprecated in v5.0]
Use [Vite's `import.meta.glob`](https://vite.dev/guide/features.html#glob-import) to query project files. 

`Astro.glob('../pages/post/*.md')` can be replaced with:

`Object.values(await import.meta.glob('../pages/post/*.md', { eager: true }));`

See the [imports guide](/en/guides/imports/#importmetaglob) for more information and usage.
:::

`Astro.glob()` is a way to load many local files into your static site setup.

```astro
---
// src/components/my-component.astro
const posts = await Astro.glob('../pages/post/*.md'); // returns an array of posts that live at ./src/pages/post/*.md
---

<div>
{posts.slice(0, 3).map((post) => (
  <article>
    <h2>{post.frontmatter.title}</h2>
    <p>{post.frontmatter.description}</p>
    <a href={post.url}>Read more</a>
  </article>
))}
</div>
```

`.glob()` only takes one parameter: a relative URL glob of which local files you'd like to import. It’s asynchronous and returns an array of the exports from matching files.

`.glob()` can't take variables or strings that interpolate them, as they aren't statically analyzable. (See [the imports guide](/en/guides/imports/#supported-values) for a workaround.) This is because `Astro.glob()` is a wrapper of Vite's [`import.meta.glob()`](https://vite.dev/guide/features.html#glob-import).

:::note
You can also use `import.meta.glob()` itself in your Astro project. You may want to do this when:
- You need this feature in a file that isn't `.astro`, like an API route. `Astro.glob()` is only available in `.astro` files, while `import.meta.glob()` is available anywhere in the project.
- You don't want to load each file immediately. `import.meta.glob()` can return functions that import the file content, rather than returning the content itself. Note that this import includes all styles and scripts for any imported files. These will be bundled and added to the page whether or not a file is actually used, as this is decided by static analysis, not at runtime.
- You want access to each file's path. `import.meta.glob()` returns a map of a file's path to its content, while `Astro.glob()` returns a list of content.
- You want to pass multiple patterns; for example, you want to add a "negative pattern" that filters out certain files. `import.meta.glob()` can optionally take an array of glob strings, rather than a single string.

Read more in the [Vite documentation](https://vite.dev/guide/features.html#glob-import).
:::

##### Markdown Files

Markdown files loaded with `Astro.glob()` return the following `MarkdownInstance` interface:

```ts
export interface MarkdownInstance<T extends Record<string, any>> {
  /* Any data specified in this file's YAML frontmatter */
	frontmatter: T;
  /* The absolute file path of this file */
	file: string;
  /* The rendered path of this file */
	url: string | undefined;
  /* Astro Component that renders the contents of this file */
	Content: AstroComponentFactory;
  /** (Markdown only) Raw Markdown file content, excluding layout HTML and YAML frontmatter */
	rawContent(): string;
  /** (Markdown only) Markdown file compiled to HTML, excluding layout HTML */
	compiledContent(): string;
  /* Function that returns an array of the h1...h6 elements in this file */
	getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;
	default: AstroComponentFactory;
}
```

You can optionally provide a type for the `frontmatter` variable using a TypeScript generic.

```astro
---
interface Frontmatter {
  title: string;
  description?: string;
}
const posts = await Astro.glob<Frontmatter>('../pages/post/*.md');
---

<ul>
  {posts.map(post => <li>{post.frontmatter.title}</li>)}
</ul>
```

##### Astro Files

Astro files have the following interface:

```ts
export interface AstroInstance {
  /* The file path of this file */
  file: string;
  /* The URL for this file (if it is in the pages directory) */
	url: string | undefined;
	default: AstroComponentFactory;
}
```

##### Other Files

Other files may have various different interfaces, but `Astro.glob()` accepts a TypeScript generic if you know exactly what an unrecognized file type contains.

```ts
---
interface CustomDataFile {
  default: Record<string, any>;
}
const data = await Astro.glob<CustomDataFile>('../data/**/*.js');
---
```
