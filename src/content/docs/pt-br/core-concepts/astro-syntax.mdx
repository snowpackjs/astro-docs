---
title: Sintaxe do Astro
description: Uma introdução à sintaxe de componente .astro .
i18nReady: true
---

**Se você conhece HTML, você já sabe o suficiente para escrever seu primeiro componente Astro.**

A sintaxe de componente Astro é um superconjunto do HTML. A sintaxe foi [projetada para sentir familiar a qualquer um com experiência em escrever HTML ou JSX](#diferenças-entre-astro-e-jsx) e adiciona suporte para incluir componentes e expressões do JavaScript.


## Expressões parecidas com JSX

Você pode definir variáveis do JavaScript locais dentro do script do frontmatter do componente entre as duas cercas de código (`---`) de um componente Astro. você pode então injetar essas variáveis no template HTML do componente usando expressões parecidas com JSX.

:::note[dinâmico vs reativo]
Usando essa abordagem, você pode incluir valores **dinâmicos** que são calculados no frontmatter. Mas uma vez incluídos, esses valores não são **reativos** e nunca mudarão. Os componentes Astro são modelos que só executam uma vez, durante a etapa de renderização.

Veja abaixo mais exemplos de [diferenças entre Astro e JSX](#diferenças-entre-astro-e-jsx).
:::

### Variáveis

Variáveis locais podem ser adicionadas ao HTML usando a sintaxe de chaves:

```astro title="src/components/Variaveis.astro" "{nome}"
---
const nome = "Astro";
---
<div>
  <h1>Olá {nome}!</h1>  <!-- Produz <h1>Olá Astro!</h1> -->
</div>
```

### Atributos Dinâmicos

Variáveis locais podem ser usadas em chaves para passar valores de atributos tanto para elementos HTML como para componentes:

```astro title="src/components/AtributosDinamicos.astro" "{nome}" "${nome}"
---
const nome = "Astro";
---
<h1 class={nome}>Expressões de atributo são suportadas</h1>

<MeuComponente nomeAtributoTemplateString={`MeuNomeE${nome}`} />
```

:::caution
Atributos HTML vão ser convertidos para string, então não é possível passar funções e objetos para elementos HTML.
Por exemplo, você não pode atribuir um manipulador de eventos a um elemento HTML em um componente Astro:

```astro
---
// nao-faca-isso.astro
function tratarClique () {
    console.log("botão clicado!");
}
---
<!-- ❌ Isso não funciona! ❌ -->
<button onClick={tratarClique}>Nada vai acontecer quando você me clicar!</button>
```

Ao invés disso, use um script do lado do cliente para adicionar o manipulador de evento, como você faria no JavaScript vanilla:

```astro
---
// do-this-instead.astro
---
<button id="button">Click Me</button>
<script>
  function handleClick () {
    console.log("button clicked!");
  }
  document.getElementById("button").addEventListener("click", handleClick);
</script>
```
:::

### HTML Dinâmico

Local variables can be used in JSX-like functions to produce dynamically-generated HTML elements:

```astro title="src/components/DynamicHtml.astro" "{item}"
---
const items = ["Dog", "Cat", "Platypus"];
---
<ul>
  {items.map((item) => (
    <li>{item}</li>
  ))}
</ul>
```

Astro can conditionally display HTML using JSX logical operators and ternary expressions.

```astro title="src/components/ConditionalHtml.astro" "visible"
---
const visible = true;
---
{visible && <p>Show me!</p>}

{visible ? <p>Show me!</p> : <p>Else show me!</p>}
```

### Tags Dinâmicas

You can also use dynamic tags by setting a variable to an HTML tag name or a component import:

```astro title="src/components/DynamicTags.astro" /Element|(?<!My)Component/
---
import MyComponent from "./MyComponent.astro";
const Element = 'div'
const Component = MyComponent;
---
<Element>Hello!</Element> <!-- renders as <div>Hello!</div> -->
<Component /> <!-- renders as <MyComponent /> -->
```

When using dynamic tags:

- **Variable names must be capitalized.** For example, use `Element`, not `element`. Otherwise, Astro will try to render your variable name as a literal HTML tag.

- **Hydration directives are not supported.** When using [`client:*` hydration directives](/pt-br/core-concepts/framework-components/#hidratando-componentes-interativos), Astro needs to know which components to bundle for production, and the dynamic tag pattern prevents this from working.

### Fragmentos

Astro supports using either `<Fragment> </Fragment>` or the shorthand `<> </>`.

Fragments can be useful to avoid wrapper elements when adding [`set:*` directives](/pt-br/reference/directives-reference/#sethtml), as in the following example:

```astro title="src/components/SetHtml.astro" "Fragment"
---
const htmlString = '<p>Raw HTML content</p>';
---
<Fragment set:html={htmlString} />
```

### Diferenças entre Astro e JSX

Astro component syntax is a superset of HTML. It was designed to feel familiar to anyone with HTML or JSX experience, but there are a couple of key differences between `.astro` files and JSX.

#### Atributos

In Astro, you use the standard `kebab-case` format for all HTML attributes instead of the `camelCase` used in JSX. This even works for `class`, which is not supported by React.

```jsx del={1} ins={2} title="example.astro"
<div className="box" dataValue="3" />
<div class="box" data-value="3" />
```

#### Múltiplos elementos

An Astro component template can render multiple elements with no need to wrap everything in a single `<div>` or `<>`, unlike JavaScript or JSX.

```astro title="src/components/RootElements.astro"
---
// Template with multiple elements
---
<p>No need to wrap elements in a single containing element.</p>
<p>Astro supports multiple root elements in a template.</p>
```

#### Comentários

In Astro, you can use standard HTML comments or JavaScript-style comments.

```astro title="example.astro"
---
---
<!-- HTML comment syntax is valid in .astro files -->
{/* JS comment syntax is also valid */}
```

:::caution
HTML-style comments will be included in browser DOM, while JS ones will be skipped. To leave TODO messages or other development-only explanations, you may wish to use JavaScript-style comments instead.
:::


