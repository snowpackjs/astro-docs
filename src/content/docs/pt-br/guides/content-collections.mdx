---
title: Coleções de Conteúdo
description: >-
  Coleções de Conteúdo ajudam a organizar seu Markdown e checar os tipos do seu frontmatter com esquemas.
  frontmatter with schemas.
i18nReady: true
---
import FileTree from '~/components/FileTree.astro'
import Since from '~/components/Since.astro'
import TypeScriptSettingTabs from '~/components/tabs/TypeScriptSettingTabs.astro'



<p>
  <Since v="2.0.0" />
</p>

**Coleções de conteúdo** são a melhor forma de gerenciar a autorar conteúdo em qualquer projeto com Astro. Coleções ajudam a organizar seu documentos, validar seu frontmatter, e fornece checagem automática de tipos do TypeScript para todo seu conteúdo.

## O que são Coleções de Conteúdo?

Uma **coleção de conteúdo** é qualquer pasta de nível superior dentro da pasta do projeto reservada `src/content`, como `src/content/jornal` e `src/content/autores`. Apenas coleções de conteúdo são permitidas dentro da pasta `src/content`. Essa pasta não pode ser usada para nada além disso.

Uma **entrada da coleção** é qualquer peça de conteúdo armazenada dentro da sua pasta da coleção de conteúdo. Entradas podem usar formatos de autoria de conteúdo incluindo Markdown (`.md`) e MDX (`.mdx` usando a [integração do MDX](/pt-br/guides/integrations-guide/mdx/)) ou como formatos de dados incluindo YAML (`.yaml`) e JSON (`.json`). Nós recomendamos usar um esquema de nomenclatura consistente (minúsculas, traços ao invés de espaços) para seus arquivos para tornar fácil de encontrar e organizar seu conteúdo, mas isso não é exigido. Você também pode [excluir entradas de serem incluídas no build](/pt-br/core-concepts/routing/#excluindo-páginas) ao prefixar o nome do arquivo com um sublinhado (_).

<FileTree>
- src/content/
  - **jornal/** a coleção "jornal"
    - semana-1.md uma entrada da coleção
    - semana-2.md uma entrada da coleção
    - semana-3.md uma entrada da coleção
</FileTree>

Tendo a coleção, você pode começar a [consultar seu conteúdo](#consultando-coleções) usando as APIs de conteúdo integradas no Astro.

### A Pasta ".astro"

O Astro armazena metadados importantes para coleções de conteúdo em uma pasta `.astro` no seu projeto. Nenhuma ação é necessária da sua parte para manter ou atualizar essa pasta. Você é encorajado a ignorá-lo completamente enquanto estiver trabalhando no seu projeto.

A pasta `.astro` vai ser atualizada para você automaticamente sempre que você executa os comandos [`astro dev`](/pt-br/reference/cli-reference/#astro-dev) e [`astro build`](/pt-br/reference/cli-reference/#astro-build). Você pode executar [`astro sync`](/pt-br/reference/cli-reference/#astro-sync) a qualquer momento para atualizar a pasta `.astro` manualmente.

:::tip
Se você está usando Git para controle de versão, nós recomendamos ignorar a pasta `.astro` adicionando `.astro` no seu `.gitignore`. Isso diz ao Git ignorar essa pasta e quaisquer arquivos dentro dela.

```bash
echo "\n.astro" >> .gitignore
```
:::



### Organizando com múltiplas coleções

Se dois arquivos representam diferentes tipos de conteúdo (e.x. uma postagem de blog e um perfil de autor), eles provavelmente pertencem a coleções diferentes. Isso é importante por que muitas funcionalidades (validação do frontmatter, segurança automática de tipo do TypeScript) requerem que todas as entradas em uma coleção compartilhem uma estrutura similar.

Se você se encontrar trabalhando com diferentes tipos de conteúdo, você deve criar múltiplas coleções para representar cada tipo. Você pode criar quantas coleções diferentes você quiser no seu projeto.

<FileTree>
- src/content/
  - **jornal/** 
    - semana-1.md
    - semana-2.md
  - **blog/**
    - postagem-1.md
    - postagem-2.md
  - **autores/**
    - grace-hopper.json
    - alan-turing.json
</FileTree>


### Organizando com subpastas

Uma coleção de conteúdo é sempre uma pasta no nível superior dentro da pasta `src/content/`. Você não pode aninhar uma coleção dentro da outra. Entretanto, você pode usar subpastas para organizar seu conteúdo dentro de uma coleção.

Por exemplo, você pode usar a seguinte estrutura de pasta para organizar traduções dentro de uma única coleção `docs`. Quando você consultar essa coleção, você vai ser capaz de filtrar o resultado pelo idioma usando o caminho do arquivo.

<FileTree>
- src/content/
  - docs/ essa coleção usa subpastas para organizar por idioma
    - **en/**
    - **es/**
    - **de/**
</FileTree>

## Definindo Coleções

:::note
O arquivo `src/content/config.ts` é opcional. Entretanto, escolher não definir suas coleções vai desabilitar algumas das suas melhores funcionalidades como validação do esquema do frontmatter ou tipagem automática do TypeScript.
:::

Para obter o máximo de suas coleções de conteúdo, crie um arquivo `src/content/config.ts` no seu projeto (extensões `.js` e `.mjs` também são suportadas). Esse é um arquivo espacial que o Astro vai automaticamente carregar e usar para configurar suas coleções de conteúdo.


```ts
// src/content/config.ts
// 1. Importe utilitários do `astro:content`
import { defineCollection } from 'astro:content';
// 2. Defina sua(s) coleção(ões)
const colecaoBlog = defineCollection({ /* ... */ });
// 3. Exporte um único objeto `collections` para registrar sua coleção(ões)
//    Essa chave deve corresponder com o nome da pasta da coleção em "src/content"
export const collections = {
  'blog': colecaoBlog,
};
```


### Configurando o TypeScript

Se você ainda **não** estende as configurações recomendadas de TypeScript `strict` ou `strictest` do Astro no seu arquivo `tsconfig.json`, talvez você precise atualizar seu `tsconfig.json` para habilitar `strictNullChecks`.

```json title="tsconfig.json" ins={5}
{
  // Nota: Nenhuma alteração necessária se você usa "astro/tsconfigs/strict" ou "astro/tsconfigs/strictest"
  "extends": "astro/tsconfigs/base",
  "compilerOptions": {
    "strictNullChecks": true
  }
}
```

Se você use arquivos `.js` ou `.mjs` em um projeto Astro, você pode habilitar o IntelliSense e checagem de tipo no seu editor ao habilitar `allowJs` no seu `tsconfig.json`:
```json title="tsconfig.json" ins={6}
{
  // Nota: Nenhuma alteração necessária se você usa "astro/tsconfigs/strict" ou "astro/tsconfigs/strictest"
  "extends": "astro/tsconfigs/base",
  "compilerOptions": {
    "strictNullChecks": true,
    "allowJs": true
  }
}
```

### Definindo um esquema de coleção

Esquemas reforçam o frontmatter ou dados da entrada dentro de uma coleção. Um esquema **garante** que esse dado existe em um formato previsível quando você precisa referenciar ou consultar ele. Se qualquer arquivo viola o esquema de sua coleção, o Astro vai fornecer um erro útil para informá-lo.

Os esquemas também compõe a tipagem automática de TypeScript do Astro para seu conteúdo. Quando você define um esquema para sua coleção, o Astro vai automaticamente gerar e aplicar uma interface do TypeScript para ela. O resultado é um suporte a TypeScript completo quando você consulta sua coleção, incluindo conclusão automática de propriedades e checagem de tipo.

Para definir sua primeira coleção, crie um arquivo `src/content/config.ts` se um ainda não existir (extensões `.js` e `.mjs` também são suportadas). Esse arquivo deve:

1. **Importar os utilitários adequados** de `astro:content`.
2. **Definir cada coleção que você gostaria de validar**. Isso inclui um `typo` (introduzido no Astro v2.5.0) especificando se a coleção contém formatos de autoria de conteúdo como Markdown (`type: 'content'`) ou formatos de dados como JSON ou YAML (`type: 'data'`). Isso também inclui um `schema` que define o formato do seu frontmatter ou entrada de dados.
3. **Exportar um único objeto `collections`** para registrar suas coleções.

```ts
// src/content/config.ts
// 1. Importe utilitários do `astro:content`
import { z, defineCollection } from 'astro:content';

// 2. Defina um `type` e um `schema` para cada coleção
const colecaoBlog = defineCollection({
  type: 'content', // v2.5.0 e posterior
  schema: z.object({
    titulo: z.string(),
    tags: z.array(z.string()),
    imagem: z.string().optional(),
  }),
});

// 3. Exporte um único objeto `collections` para registrar sua(s) coleção(ões)
export const collections = {
  'blog': colecaoBlog,
};
```

### Definindo múltiplas coleções

Você pode usar `defineCollection()` quantas vezes você quiser para criar vários esquemas. Todas as coleções devem ser exportadas de dentro de um único objeto `collections`.

```ts
// src/content/config.ts
const colecaoBlog = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const jornal = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const autores = defineCollection({
  type: 'data',
  schema: z.object({ /* ... */ })
});

export const collections = {
  'blog': colecaoBlog,
  'jornal': jornal,
  'autores': autores,
};
```

Conforme seu projeto cresce, você também é libre para reorganizar sua base de código e mover a lógica do arquivo `src/content/config.ts`. Definir seus esquemas separadamente pode ser útil para reutilizar esquemas através de múltiplas coleções e compartilhar esquemas com outras partes do seu projeto.

```ts
// src/content/config.ts
// 1. Importe seus utilitários e esquemas
import { defineCollection } from 'astro:content';
import { esquemaBlog, esquemaAutor } from '../schemas';

// 2. Defina suas coleções
const colecaoBlog = defineCollection({
  type: 'content',
  schema: esquemaBlog,
});
const colecaoAutor = defineCollection({
  type: 'data',
  schema: esquemaAutor,
});

// 3. Export várias coleções para registrá-las
export const collections = {
  'blog': colecaoBlog,
  'authors': colecaoAutor,
};
```

### Usando esquemas de coleção de terceiros

Você pode importar esquemas de coleção de qualquer lugar, incluindo pacotes npm externos. Isso pode ser útil ao trabalhar com temas e bibliotecas que fornecem seus próprios esquemas de coleção para você usar.


```ts
// src/content/config.ts
import { esquemaBlog } from 'meu-tema-de-blog';
const colecaoBlog = defineCollection({ type: 'content', schema: esquemaBlog });

// Exporte a coleção do blog, usando um esquema externo do 'meu-tema-de-blog'
export const collections = {
  'blog': colecaoBlog,
};
```


### Definindo tipos de dados com Zod

O Astro usa [Zod](https://github.com/colinhacks/zod) para alimentar sues esquemas de conteúdo. Com Zod, o Astro é capaz de validar cada frontmatter dos arquivos dentro de uma coleção *e* fornecer tipos do TypeScript automaticamente quando você vai consultar conteúdo de dentro do seu projeto.

Para usar Zod no Astro, importe o utilitário `z` do `"astro:content"`. Esse é uma reexportação da biblioteca Zod, e ele suporta todas as funcionalidades do Zod. Veja o [README do Zod](https://github.com/colinhacks/zod) para a documentação completa de como o Zod funciona e quais funcionalidades estão disponíveis.


```ts
// Exemplo: Uma cheatsheet de muitos tipos de dados comuns com Zod
import { z, defineCollection } from 'astro:content';

defineCollection({
  schema: z.object({
    isRascunho: z.boolean(),
    titulo: z.string(),
    ordenacao: z.number(),
    imagem: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    autor: z.string().default('Anonymous'),
    idioma: z.enum(['en', 'es']),
    tags: z.array(z.string()),
    // Uma propriedade opcional do frontmatter. Muito comum!
    notaRodape: z.string().optional(),
    // No frontmatter, datas escritas sem aspas envolta delas são interpretadas como objetos Date
    dataPublicacao: z.date(),
    // Você também pode transformar uma string de data (e.x. "2022-07-08") para um objeto Date
    // dataPublicacao: z.string().transform((str) => new Date(str)),
    // Avançado: Validar que a string também é um email
    contatoAutor: z.string().email(),
    // Avançado: Validar que a string também é uma URL
    URLCanonica: z.string().url(),
  })
})
```

### Definindo referências de coleção

Entradas de coleções também podem "referenciar" outras entradas relacionadas.

Com a função `reference()` da API de Coleções, você pode definir uma propriedade de um esquema de coleção como uma entrada de outra coleção. Por exemplo, você pode exigir que todas as entradas `nave-espacial` incluam uma propriedade `piloto` que usa o esquema da coleção `piloto` para checagem de tipo, conclusão automática e validação.

Um exemplo comum é uma postagem de blog que referencia perfis de autor reutilizáveis armazenados como JSON, ou URLs de postagens relacionadas armazenadas na mesma coleção:

```ts
import { defineCollection, reference, z } from 'astro:content';

const blog = defineCollection({
  type: 'content',
  schema: z.object({
    titulo: z.string(),
    // Referencia um único autor da coleção `autores` pelo `id`
    autor: reference('autores'),
    // Referencia um array de postagens relacionadas da coleção `blog` pelo `slug`
    postagensRelacionadas: z.array(reference('blog')),
  })
});

const autores = defineCollection({
  type: 'data',
  schema: z.object({
    nome: z.string(),
    portfolio: z.string().url(),
  })
});

export const collections = { blog, autores };
```

Este exemplo de postagem de blog especifica os `slug`s de postagens relacionadas e o `id` do autor da postagem:
This example blog post specifies the `slug`s of related posts and the `id` of the post author:

```yaml title="src/content/blog/bem-vindo.md"
---
titulo: "Bem-vindo ao meu blog"
autor: ben-holmes # referencia `src/content/autores/ben-holmes.json`
postagensRelacionadas:
- sobre-mim # referencia `src/content/blog/some-mim.md`
- minha-retrospectiva # references `src/content/blog/minha-retrospectiva.md`
---
```

### Definindo slugs customizados

Ao usar `type: 'content'`, toda entrada de conteúdo gera uma propriedade `slug` amigável para URL a partir do seu [`id` do arquivo](/pt-br/reference/api-reference/#id). O slug é usado para consultar a entrada diretamente da sua coleção. Ela também é útil ao criar novas páginas e URLs do seu conteúdo.

Você pode sobrescrever a slug gerada para a entrada ao adicionar seu própria propriedade `slug` ao frontmatter do arquivo. Isso é similar à funcionalidade `permalink` de outros frameworks web. `"slug` é um nome de propriedade especial e reservada que não é permitida no seu `schema` customizado da coleção e não vai aparecer na propriedade `data` da sua entrada.

```md {3}
---
title: Minha Postagem de Blog
slug: minha-slug-customizada/suporta/barras
---
Seu conteúdo da postagem do blog vem aqui.
```

## Consultando Coleções

O Astro fornece duas funções para consultar uma coleção e retornar um (ou mais) entradas de conteúdo: [`getCollection()`](/pt-br/reference/api-reference/#getcollection) e [`getEntry()`](/pt-br/reference/api-reference/#getentry).

```js
import { getCollection, getEntry } from 'astro:content';

// Obtém todas as entradas de uma coleção.
// Requer o nome da coleção como um argumento.
// Exemplo: recuperar `src/content/blog/**`
const todasPostagensDoBlog = await getCollection('blog');

// Obtém uma única entrada de uma coleção.
// Requires the name of the collection and either
// Requer o nome da coleção e ou o `slug` da
// entrada (coleções de conteúdo) ou o `id` (coleções de dados)
// Exemplo: recuperar `src/content/autores/grace-hopper.json`
const graceHopperPerfil = await getEntry('autores', 'grace-hopper');
```

Ambas as funções retornam entradas de conteúdo definidas pelo tipo [`CollectionEntry`](/pt-br/reference/api-reference/#tipo-da-entrada-da-coleção).

### Acessando dados referenciados

Any [references defined in your schema](#definindo-referências-de-coleção) must be queried separately after first querying your collection entry. You can use the `getEntry()` function again, or `getEntries()`, to retrieve the referenced entry from the returned `data` object. 

```astro title="src/pages/blog/welcome.astro"
---
import { getEntry, getEntries } from 'astro:content';

const blogPost = await getEntry('blog', 'welcome');

// Resolve a singular reference
const author = await getEntry(blogPost.data.author);
// Resolve an array of references
const relatedPosts = await getEntries(blogPost.data.relatedPosts);
---

<h1>{blogPost.data.title}</h1>
<p>Author: {author.data.name}</p>

<!-- ... -->

<h2>You might also like:</h2>
{relatedPosts.map(p => (
  <a href={p.slug}>{p.data.title}</a>
))}
```

### Filtrando consultas de coleção

`getCollection()` takes an optional "filter" callback that allows you to filter your query based on an entry's `id` or `data` (frontmatter) properties. For collections of `type: content`, you can also filter based on `slug`.

:::note
The `slug` property is specific to content collections, and will not be available when filtering collections of JSON or YAML.
:::

You can use this to filter by any content criteria you like. For example, you can filter by properties like `draft` to prevent any draft blog posts from publishing to your blog:

```js
// Example: Filter out content entries with `draft: true`
import { getCollection } from 'astro:content';
const publishedBlogEntries = await getCollection('blog', ({ data }) => {
  return data.draft !== true;
});
```

The filter argument also supports filtering by nested directories within a collection. Since the `id` includes the full nested path, you can filter by the start of each `id` to only return items from a specific nested directory:

```js
// Example: Filter entries by sub-directory in the collection
import { getCollection } from 'astro:content';
const englishDocsEntries = await getCollection('docs', ({ id }) => {
  return id.startsWith('en/');
});
```

### Usando conteúdo em modelos do Astro

Once you have queried your collection entries, you can access each entry directly inside of your Astro component template. This lets you to render HTML for things like links to your content (using the content `slug`) or information about your content (using the `data` property).

For information about rendering your content to HTML, see [Rendering Content to HTML](/pt-br/guides/content-collections/#renderizando-conteúdo-para-html) below.

```astro
---
// src/pages/index.astro
import { getCollection } from 'astro:content';
const blogEntries = await getCollection('blog');
---
<ul>
  {blogEntries.map(blogPostEntry => (
    <li>
      <a href={`/my-blog-url/${blogPostEntry.slug}`}>{blogPostEntry.data.title}</a>
      <time datetime={blogPostEntry.data.publishedDate.toISOString()}>
        {blogPostEntry.data.publishedDate.toDateString()}
      </time>
    </li>
  ))}
</ul>
```

### Passando conteúdo como props

A component can also pass an entire content entry as a prop. 

If you do this, you can use the [`CollectionEntry`](/pt-br/reference/api-reference/#tipo-da-entrada-da-coleção) utility to correctly type your components props using TypeScript.  This utility takes a string argument that matches the name of your collection schema, and will inherit all of the properties of that collection's schema.

```astro /CollectionEntry(?:<.+>)?/
---
// src/components/BlogCard.astro
import type { CollectionEntry } from 'astro:content';
interface Props {
  post: CollectionEntry<'blog'>;
}

// `post` will match your 'blog' collection schema type
const { post } = Astro.props;
---
```

### Renderizando conteúdo para HTML

Once queried, you can render Markdown and MDX entries to HTML using the entry `render()` function property. Calling this function gives you access to rendered content and metadata, including both a `<Content />` component and a list of all rendered headings.

```astro {5}
---
// src/pages/render-example.astro
import { getEntry } from 'astro:content';
const entry = await getEntry('blog', 'post-1');
const { Content, headings } = await entry.render();
---
<p>Published on: {entry.data.published.toDateString()}</p>
<Content />
```


## Gerando Rotas a partir do Conteúdo

Content collections are stored outside of the `src/pages/` directory. This means that no routes are generated for your collection items by default. You will need to manually create a new [dynamic route](/pt-br/core-concepts/routing/#rotas-dinâmicas) to generate HTML pages from your collection entries. Your dynamic route will map the incoming request param (ex: `Astro.params.slug` in `src/pages/blog/[...slug].astro`) to fetch the correct entry inside a collection.

The exact method for generating routes will depend on your build [`output`](/pt-br/reference/configuration-reference/#output) mode: 'static' (the default) or 'server' (for SSR).

### Fazendo a build para saída estática (padrão)

If you are building a static website (Astro's default behavior), you would use the [`getStaticPaths()`](/pt-br/reference/api-reference/#getstaticpaths) function to create multiple pages from a single `src/pages/` component during your build.

Call [`getCollection()`](/pt-br/reference/api-reference/#getcollection) inside of `getStaticPaths()` to query your content. Then, create your new URL paths using the `slug` property of each content entry.

```astro "{ slug: entry.slug }"
---
// src/pages/posts/[...slug].astro
import { getCollection } from 'astro:content';
// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
  const blogEntries = await getCollection('blog');
  return blogEntries.map(entry => ({
    params: { slug: entry.slug }, props: { entry },
  }));
}
// 2. When it's time to render, you can get the entry directly from the prop
const { entry } = Astro.props;
const { Content } = await entry.render();
---
<h1>{entry.data.title}</h1>
<Content />
```

This will generate a new page for every entry in the `blog` collection. For example, an entry at `src/content/blog/hello-world.md` will have a slug of `hello-world`, and therefore its final URL will be `/posts/hello-world/`.

:::note
If your custom slugs contain the `/` character to produce URLs with multiple path segments, you must use a [rest parameter (`[...path]`)](/pt-br/core-concepts/routing/#parâmetros-rest) in the `.astro` filename for this dynamic routing page.
:::

### Fazendo a build para saída de servidor (SSR)

If you are building a dynamic website (using Astro's SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using `Astro.request` or `Astro.params`) to find the `slug` on-demand, and then fetch it using [`getEntry()`](/pt-br/reference/api-reference/#getentry).


```astro
---
// src/pages/posts/[...slug].astro
import { getEntry } from "astro:content";
// 1. Get the slug from the incoming server request
const { slug } = Astro.params;
if (slug === undefined) {
	throw new Error("Slug is required");
}
// 2. Query for the entry directly using the request slug
const entry = await getEntry("blog", slug);
// 3. Redirect if the entry does not exist
if (entry === undefined) {
	return Astro.redirect("/404");
}
// 4. (Optional) Render the entry to HTML in the template
const { Content } = await entry.render();
---
```

## Migrando do Roteamento Baseado em Arquivos
This guide shows you how to convert an existing Astro project with Markdown files in the `src/pages/` folder to content collections. It uses the [Build a Blog tutorial's finished project](https://github.com/withastro/blog-tutorial-demo) as an example.

1. [Upgrade](/pt-br/guides/upgrade-to/v2/) to Astro v2.0 or later, and upgrade all integrations to their latest versions. 

2. [Set up TypeScript](/pt-br/guides/content-collections/#configurando-o-typescript) for content collections.
3. Create at least one collection (folder in `src/content/`) and move your Markdown and MDX pages from `src/pages/` into these subdirectories of `src/content/`. Collections work best when all files in the same collection have similar frontmatter properties. So, choose your new folder structure to reflect similar types of pages.

    For example, to migrate the [blog posts in the tutorial](/pt-br/tutorial/2-pages/2/), move the contents of `src/pages/posts/` to `src/content/posts/`. 

4. Create a `src/content/config.ts` file and [define a schema](/pt-br/guides/content-collections/#definindo-um-esquema-de-coleção) for each content type. For the blog, we only have one content type, `posts`:

    ```ts title="src/content/config.ts"
    // Import utilities from `astro:content`
    import { z, defineCollection } from "astro:content";
    // Define a `type` and `schema` for each collection
    const postsCollection = defineCollection({
        type: 'content',
        schema: z.object({
          title: z.string(),
          pubDate: z.date(),
          description: z.string(),
          author: z.string(),
          image: z.object({
            url: z.string(),
            alt: z.string()
          }),
          tags: z.array(z.string())
        })
    });
    // Export a single `collections` object to register your collection(s)
    export const collections = {
      posts: postsCollection,
    };
    ```

    :::tip
    If your editor doesn't recognize `astro:content`, make sure you're on the latest version of Astro and try restarting the dev server. 
    :::


5. [Generate routes from your collections](/pt-br/guides/content-collections/#gerando-rotas-a-partir-do-conteúdo). Inside a collection, Markdown and MDX files no longer automatically become pages using Astro's [file-based routing](/pt-br/guides/markdown-content/#roteamento-baseado-em-arquivos), so you must generate the pages yourself.

    For the tutorial, create a `src/pages/posts/[...slug].astro`. This page will use [dynamic routing](/pt-br/core-concepts/routing/#rotas-dinâmicas) to generate a page for each collection entry. 

    This page will also need to [query your collection](#consultando-coleções) to fetch page slugs and make the page content available to each route.

    Render your post `<Content />` within the layout for your Markdown or MDX pages. This allows you to specify a common layout for all of your posts.

    ```astro title="src/pages/posts/[...slug].astro"
    ---
    import { getCollection } from 'astro:content';
    import MarkdownPostLayout from '../../layouts/MarkdownPostLayout.astro';

    export async function getStaticPaths() {
      const blogEntries = await getCollection('posts');
      return blogEntries.map(entry => ({
        params: { slug: entry.slug }, props: { entry },
      }));
    }

    const { entry } = Astro.props;
    const { Content } = await entry.render();
    ---
    <MarkdownPostLayout frontmatter={entry.data}>
      <Content />
    </MarkdownPostLayout>
    ```

6. Remove the `layout` definition in each individual post's frontmatter. Your content is now wrapped in a layout when rendered, and this property is no longer needed.

    ```md title="src/content/post-1.md" del={2}
    ---
    layout: ../../layouts/MarkdownPostLayout.astro
    title: 'My First Blog Post'
    pubDate: 2022-07-01
    ...
    ---
    ```

7. Replace `Astro.glob()` with [`getCollection()`](/pt-br/reference/api-reference/#getcollection) to fetch content and metadata from your Markdown files. You will also need to update references to the returned post object, since you will now find your frontmatter values on the `data` property.

    The blog index page in the tutorial lists a card for each post. This becomes:

    ```astro title="src/pages/blog.astro" "post.data" "getCollection(\"posts\")" "'/posts/' + post.slug"
    ---
    import { getCollection } from "astro:content";
    import BaseLayout from "../layouts/BaseLayout.astro";
    import BlogPost from "../components/BlogPost.astro";

    const pageTitle = "My Astro Learning Blog";
    const allPosts = await getCollection("posts");
    ---

    <BaseLayout pageTitle={pageTitle}>
      <p>This is where I will post about my journey learning Astro.</p>
      <ul>
        {
          allPosts.map((post) => (
            <BlogPost url={'/posts/' + post.slug} title={post.data.title} />
          ))
        }
      </ul>
    </BaseLayout> 
    ```

    The tutorial blog project also dynamically generates a page for each tag. This page now becomes:

    ```astro title="src/pages/tags/[tag].astro" "post.data" "getCollection(\"posts\")" "post.data.title" "'/posts/' + post.slug"
    ---
    import { getCollection } from "astro:content";
    import BaseLayout from "../../layouts/BaseLayout.astro";
    import BlogPost from "../../components/BlogPost.astro";

    export async function getStaticPaths() {
      const allPosts = await getCollection("posts");
      const uniqueTags = [...new Set(allPosts.map((post) => post.data.tags).flat())];

      return uniqueTags.map((tag) => {
        const filteredPosts = allPosts.filter((post) =>
          post.data.tags.includes(tag)
        );
        return {
          params: { tag },
          props: { posts: filteredPosts },
        };
      });
    }
    
    const { tag } = Astro.params;
    const { posts } = Astro.props;
    ---

    <BaseLayout pageTitle={tag}>
        <p>Posts tagged with {tag}</p>
        <ul>
            { posts.map((post) => <BlogPost url={'/posts/' + post.slug} title={post.data.title} />) }
        </ul>
    </BaseLayout>
    ```

    The same logic appears in the tag index page, which becomes:
    
    ```astro title="src/pages/tags/index.astro" "post.data" "getCollection(\"posts\")"
    ---
    import { getCollection } from "astro:content";
    import BaseLayout from "../../layouts/BaseLayout.astro";
    const allPosts = await getCollection("posts");
    const tags = [...new Set(allPosts.map((post) => post.data.tags).flat())];
    const pageTitle = "Tag Index";
    ---
    ...
    ```

    :::note
    Any individual Markdown or MDX file imports should be replaced by [`getEntry()`](/pt-br/reference/api-reference/#getentry).
    :::
    
8. Update the code that uses the publish date in the `layouts/MarkdownPostLayout.astro` file.

    Previously, `pubDate` was a string. Now, after introducing types for your posts' frontmatter, `pubDate` is a `Date`.
    To render the date, convert it to a string:

    ```astro title="src/layouts/MarkdownPostLayout.astro" "frontmatter.pubDate.toDateString()"
    ...
    <BaseLayout pageTitle={frontmatter.title}>
      <p>{frontmatter.pubDate.toDateString()}</p>
      <p><em>{frontmatter.description}</em></p>
      <p>Written by: {frontmatter.author}</p>
      <img src={frontmatter.image.url} width="300" alt={frontmatter.image.alt} />
    ...
    ```
    

    Lastly, the tutorial blog project includes an RSS feed. This function must also use `getCollection` and the `data` object, and be converted to an async function to do so:

    ```js title="src/pages/rss.xml.js" {4-5, 10-15} 
    import rss from "@astrojs/rss";
    import { getCollection } from "astro:content";

    export async function get() {
      const posts = await getCollection('posts');
      return rss({
        title: 'Astro Learner | Blog',
        description: 'My journey learning Astro',
        site: 'https://my-blog-site.netlify.app',
        items: posts.map((post) => ({
          title: post.data.title,
          pubDate: post.data.pubDate,
          description: post.data.description,
          link: `/posts/${post.slug}/`,
        })),
        customData: `<language>en-us</language>`,
      });
    }
    ```

For the full example of the blog tutorial using content collections, see the [Content Collections branch](https://github.com/withastro/blog-tutorial-demo/tree/content-collections) of the tutorial repo.


## Modificando o Frontmatter com Remark

:::caution
**Not recommended.** Remark and rehype plugins access the _raw_ Markdown or MDX document frontmatter. This means that `remarkPluginFrontmatter` frontmatter is handled separately from your type-safe `schema`, and will not reflect any changes or defaults applied through Astro. Use at your own risk!
:::

Astro supports remark or rehype plugins that [modify your frontmatter directly](/pt-br/guides/markdown-content/#modificando-frontmatter-programaticamente). You can access this modified frontmatter inside of a content entry by using the `remarkPluginFrontmatter` property returned from `render()`:

```astro "{ remarkPluginFrontmatter }"
---
import { getEntry } from 'astro:content';
const blogPost = await getEntry('blog', 'post-1');
const { remarkPluginFrontmatter } = await blogPost.render();
---
<!-- 
  This example assumes `readingTime` was injected by a remark plugin.
  See our "reading time" example for more details:
  https://docs.astro.build/en/guides/markdown-content/#example-calculate-reading-time
-->
<p>{blogPost.data.title} — {remarkPluginFrontmatter.readingTime}</p>
```

The remark and rehype pipelines only run when your content is rendered, which explains why `remarkPluginFrontmatter` is only available after you call `render()` on your content entry. In contrast, `getCollection()` and `getEntry()` cannot return these values directly because they do not render your content.

