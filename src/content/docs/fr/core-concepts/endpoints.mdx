---
title: Points de terminaison
description: Apprenez à créer des points de terminaison qui servent tout type de données.
i18nReady: true
---
import RecipeLinks from "~/components/RecipeLinks.astro";

Astro vous autorise à créer des points de terminaison (ou endpoint) personnalisés pour servir tout type de données. Vous pouvez les utiliser pour générer des images, exposer un document RSS ou les utiliser comme routes d'API pour construire une API complète pour votre site.

Pour les sites générés statiquement, vos endpoints personnalisés sont appelés au moment de la construction de votre site, afin de produire des fichiers statiques. Si vous optez pour le mode de rendu [SSR](/fr/guides/server-side-rendering/), les endpoints personnalisés se transforment en endpoints de serveur en direct qui sont appelés à chaque requête. Les endpoints statiques et SSR sont définis de manière similaire, mais les endpoints SSR prennent en charge des fonctionnalités supplémentaires.

## Points de terminaison des fichiers statiques

Pour créer des endpoint personnalisés, ajoutez un fichier `.js` ou `.ts` à votre dossier `/pages`. L'extension `.js` ou `.ts` sera supprimée pendant le processus de construction, donc le nom du fichier doit inclure l'extension des données que vous souhaitez créer. Par exemple, `src/pages/data.json.ts` générera un endpoint `/data.json`.

Les points de terminaison exportent une fonction `GET` (optionnellement `async`) qui reçoit un [objet de contexte](/fr/reference/api-reference/#endpoint-context) avec des propriétés similaires à celles de l'objet global `Astro`. Ici, elle retourne un objet Response avec un champ `name` et `url`, et Astro l'appellera au moment de la construction et utilisera le contenu du body pour générer le fichier.

```ts
// Exemple : src/pages/builtwith.json.ts
// Sortie : /builtwith.json
export async function GET({params, request}) {
  return new Response(
    JSON.stringify({
      name: 'Astro',
      url: 'https://astro.build/'
    })
  )
}
```

Depuis Astro v3.0, l'objet `Response` retourné n'a plus besoin d'inclure la propriété `encoding`. Par exemple, pour produire une image png binaire :

```ts title="src/pages/astro-logo.png.ts" {3}
export async function GET({ params, request }) {
  const response = await fetch("https://docs.astro.build/assets/full-logo-light.png");
  return new Response(await response.arrayBuffer());
}
```

Vous pouvez aussi typer vos fonctions d'endpoints en utilisant le type `APIRoute` :

```ts
import type { APIRoute } from 'astro';

export const GET: APIRoute = async ({ params, request }) => {...}
```

### `params` et routage dynamique

Les endpoints supportent les même fonctions de [routage dynamique](/fr/core-concepts/routing/#routes-dynamiques) que celles des pages. Nommez votre fichier avec un nom de paramètre entre crochets et exportez une fonction [`getStaticPaths()`](/fr/reference/api-reference/#getstaticpaths). Vous pouvez ensuite accéder au paramètre en utilisant la propriété `params` passée à la fonction de l'endpoint :

```ts title="src/pages/api/[id].json.ts"
import type { APIRoute } from 'astro';

const usernames = ["Sarah", "Chris", "Yan", "Elian"]

export const GET: APIRoute = ({ params, request }) => {
  const id = params.id;
  return new Response(
    JSON.stringify({
      name: usernames[id]
    })
  )
}

export function getStaticPaths() {
  return [ 
    { params: { id: "0"} },
    { params: { id: "1"} },
    { params: { id: "2"} },
    { params: { id: "3"} }
  ]
}
```

Cela va générer 4 points de terminaison JSON au moment du build : `/api/0.json`, `/api/1.json`, `/api/2.json` et `/api/3.json`. Le routage dynamique avec les endpoints fonctionne de la même manière qu'avec les pages, mais parce que l'endpoint est une fonction et non un composant, les [props](/fr/reference/api-reference/#data-passing-with-props) ne sont pas supportées.

### `request`

Tous les endpoints reçoivent une propriété `request`, mais dans le mode statique, vous n'avez accès qu'à `request.url`. Cela renvoie l'URL complète du point de terminaison actuel et fonctionne de la même manière que [Astro.request.url](/fr/reference/api-reference/#astrorequest) pour les pages.

```ts title="src/pages/request-path.json.ts"
import type { APIRoute } from 'astro';

export const GET: APIRoute = ({ params, request }) => {
  return new Response(JSON.stringify({
      path: new URL(request.url).pathname
    })
  )
}
```

## Endpoints du serveur (Routes API)

Tout ce qui est décrit dans la section sur les endpoints des fichiers statiques peut également être utilisé en mode SSR : les fichiers peuvent exporter une fonction `GET` qui reçoit un [objet de contexte](/fr/reference/api-reference/#endpoint-context) avec des propriétés similaires à celles de l'objet global `Astro`.

Mais, contrairement au mode `static`, lorsque vous configurez le mode `server`, les endpoints seront construits lorsqu'ils seront demandés. Cela débloque de nouvelles fonctionnalités qui ne sont pas disponibles au moment de la construction, et vous permet de construire des routes d'API qui écoutent les requêtes et exécutent du code de manière sécurisée sur le serveur au moment de l'exécution.

<RecipeLinks slugs={["fr/recipes/call-endpoints" ]}/>

:::note
Veillez à [activer le SSR](/fr/guides/server-side-rendering/#enabling-ssr-in-your-project) avant d'essayer ces exemples.
:::

Les endpoints du serveur peuvent accéder à `params` sans exporter `getStaticPaths`, et ils peuvent retourner un objet [`Response`](https://developer.mozilla.org/fr-FR/docs/Web/API/Response), vous permettant de définir les codes d'état et les en-têtes :
```js title="src/pages/[id].json.js"
import { getProduct } from '../db';

export async function GET({ params }) {
  const id = params.id;
  const product = await getProduct(id);

  if (!product) {
    return new Response(null, {
      status: 404,
      statusText: 'Not found'
    });
  }

  return new Response(
    JSON.stringify(product), {
      status: 200,
      headers: {
        "Content-Type": "application/json"
      }
    }
  );
}
```

This will respond to any request that matches the dynamic route. For example, if we navigate to `/helmet.json`, `params.id` will be set to `helmet`. If `helmet` exists in the mock product database, the endpoint will use create a `Response` object to respond with JSON and return a successful [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/API/Response/status). If not, it will use a `Response` object to respond with a `404`.

In SSR mode, certain providers require the `Content-Type` header to return an image. In this case, use a `Response` object to specify a `headers` property. For example, to produce a binary `.png` image:

```ts title="src/pages/astro-logo.png.ts"
export async function GET({ params, request }) {
  const response = await fetch("https://docs.astro.build/assets/full-logo-light.png");
  const buffer = Buffer.from(await response.arrayBuffer());
  return new Response(buffer, {
    headers: { "Content-Type": "image/png" },
  });
}
```

### HTTP methods

In addition to the `GET` function, you can export a function with the name of any [HTTP method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). When a request comes in, Astro will check the method and call the corresponding function.

You can also export an `ALL` function to match any method that doesn't have a corresponding exported function. If there is a request with no matching method, it will redirect to your site's [404 page](/en/core-concepts/astro-pages/#custom-404-error-page).

```ts title="src/pages/methods.json.ts"
export const GET: APIRoute = ({ params, request }) => {
  return new Response(JSON.stringify({
      message: "This was a GET!"
    })
  )
}

export const POST: APIRoute = ({ request }) => {
  return new Response(JSON.stringify({
      message: "This was a POST!"
    })
  )
}

export const DELETE: APIRoute = ({ request }) => {
  return new Response(JSON.stringify({
      message: "This was a DELETE!"
    })
  )
}

export const ALL: APIRoute = ({ request }) => {
  return new Response(JSON.stringify({
      message: `This was a ${request.method}!`
    })
  )
}
```

<RecipeLinks slugs={["en/recipes/captcha", "en/recipes/build-forms-api" ]}/>

### `request`

In SSR mode, the `request` property returns a fully usable [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object that refers to the current request. This allows you to accept data and check headers:

```ts title="src/pages/test-post.json.ts"
export const POST: APIRoute = async ({ request }) => {
  if (request.headers.get("Content-Type") === "application/json") {
    const body = await request.json();
    const name = body.name;
    return new Response(JSON.stringify({
      message: "Your name was: " + name
    }), {
      status: 200
    })
  }
  return new Response(null, { status: 400 });
}
```

### Redirects

The endpoint context exports a `redirect()` utility similar to `Astro.redirect`:

```js title="src/pages/links/[id].js" {14}
import { getLinkUrl } from '../db';

export async function GET({ params, redirect }) {
  const { id } = params;
  const link = await getLinkUrl(id);

  if (!link) {
    return new Response(null, {
      status: 404,
      statusText: 'Not found'
    });
  }

  return redirect(link, 307);
}
```
