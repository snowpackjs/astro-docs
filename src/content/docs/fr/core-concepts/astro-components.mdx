---
title: Composants
description: Une introduction à la syntaxe des composants en .astro.
i18nReady: true
---

**Les composants Astro** sont les blocs de base de tout projet Astro. Ce sont des composants de modélisation HTML uniquement, sans exécution côté client. Vous pouvez repérer un composant Astro par son extension de fichier : `.astro`.

Les composants Astro sont extrêment flexibles. Souvent, un composant Astro contiendra une **interface utilisateur réutilisable sur la page**, comme un en-tête ou une carte de profil. À d'autres moments, un composant Astro peut contenir un petit extrait de HTML, comme une collection de balises `<meta>` courantes qui facilitent le travail avec le référencement. Les composants Astro peuvent même contenir une mise en page de page entière.

La chose la plus importante à savoir sur les composants Astro est qu'ils **ne rendent pas sur le client**. Ils rendent en HTML soit au moment de la construction ou à la demande en utilisant le [rendu côté serveur (SSR)](/fr/guides/server-side-rendering/). Vous pouvez inclure du code JavaScript dans votre frontmatter de composant, et tout sera supprimé de la page finale envoyée aux navigateurs de vos utilisateurs. Le résultat est un site plus rapide, avec une empreinte JavaScript nulle ajoutée par défaut.

Quand votre composant Astro a besoin d'interactivité côté client, vous pouvez ajouter [des balises HTML `<script>` standard](/fr/guides/client-side-scripts/) ou [composants de framework d'interface utilisateur réutilisable](/fr/core-concepts/framework-components/#hydratation-des-composants-interactifs).


## Structure du composant

Un composant Astro est composé de deux parties principales : le **Script du composant** et le **Template du composant**. Chaque de ces parties s'occupe de faire une tâche différente, mais ensemble ils fournissent un cadre qui es à la fois facile à utiliser et assez expressif pour gérer tout ce que vous pourriez vouloir construire.

```astro title="src/components/EmptyComponent.astro"
---
// Script du composant (JavaScript)
---
<!-- Template du composant (HTML + Expressions JS) -->
```

### Le Script du composant

Astro utilise des barres de code (`---`) pour identifier le script du composant dans votre composant Astro. Si vous avez déjà écrit du Markdown avant, vour pourriez être déjà familier avec un concept similaire appelé *frontmatter.* L'idée d'un script de composant d'Astro a été directement inspirée par ce concept.

Vous pouvez utiliser le script du composant pour écrire du code JavaScript qui vous aidera à construire votre template. Cela peut inclure :

- Importer d'autres composants Astro
- Importer des composants de Framework, comme React
- Importer des données, como un fichier JSON
- Récupérer le contenu d'une API ou une base de données
- Créer des variables que vous voulez référencer dans votre template


```astro title="src/components/MyComponent.astro"
---
import SomeAstroComponent from '../components/SomeAstroComponent.astro';
import SomeReactComponent from '../components/SomeReactComponent.jsx';
import someData from '../data/pokemon.json';

// Accéder aux propriétés passées dans le composant, comme `<X title="Hello, World" />`
const {title} = Astro.props;
// Récupérer des données externes, même depuis une API privée ou une base de données
const data = await fetch('SOME_SECRET_API_URL/users').then(r => r.json());
---
<!-- Votre template ici ! -->
```

Les barres de code sont conçues pour garantir que le code JavaScript que vous écrivez à l'intérieur est "clôturé." Il ne s'échappera pas dans votre application frontend, ou ne tombera pas entre les mains de vos utilisateurs. Vous pouvez écrire en toute sécurité du code ici qui est coûteux ou sensible (comme un appel à votre base de données privée) sans vous soucier de le voir un jour dans le navigateur de vos utilisateurs. 

:::tip
Vous pouvez même écrire du TypeScript dans votre script de composant !
:::

### Le Template du composant

Le template du composant est en dessous de la barre de code et détermine la sortie HTML de votre composant.

Si vous écrivez du HTML simple ici, votre composant rendra cet HTML dans n'importe quelle page Astro où il est importé et utilisé.

De plus, [la syntaxe du template du composant Astro](/fr/core-concepts/astro-syntax/) prend également en charge les **expressions JavaScript**, les balise d'Astro [`<style>`](/fr/guides/styling/#stylisation-dans-Astro) et [`<script>`](/fr/guides/client-side-scripts/#utilisation-du-script-en-astro), les **composants importés** et les [**directives Astro spéciales**](/fr/reference/directives-reference/). Les données et les valeurs définies dans le script du composant peuvent être utilisées dans le template du composant pour produire du HTML créé dynamiquement.

```astro title="src/components/MyComponent.astro"

```astro title="src/components/MyFavoritePokemon.astro"
---
// Votre script du composant ici !
import Banner from '../components/Banner.astro';
import ReactPokemonComponent from '../components/ReactPokemonComponent.jsx';
const myFavoritePokemon = [/* ... */];
const { title } = Astro.props;
---
<!-- les commentaires HTML sont supportés ! -->
{/* JS comment syntax is also valid! */}

<Banner />
<h1>Hello, world!</h1>

<!-- Utilisez les propriétés et autres variables du script du composant : -->
<p>{title}</p>

<!-- Incluez d'autres composants avec une directive `client:` pour l'hydrater : -->
<ReactPokemonComponent client:visible />

<!-- Mixez du HTML avec des expressions JavaScript, similaire au JSX : -->
<ul>
  {myFavoritePokemon.map((data) => <li>{data.name}</li>)}
</ul>

<!-- Utilisez une directive de template pour créer des classes à partir de plusieurs chaînes ou même d'objets ! -->
<p class:list={["add", "dynamic", {classNames: true}]} />
```

## Conception à base de composants

Composants sont conçus pour être **réutilisables** et **composables**. Vous pouvez utiliser des composants à l'intérieur d'autres composants pour construire une interface utilisateur de plus en plus avancée. Par exemple, un composant `Button` pourrait être utilisé pour créer un composant `ButtonGroup` :

```astro title="src/components/ButtonGroup.astro"
---
import Button from './Button.astro';
---
<div>
  <Button title="Button 1" />
  <Button title="Button 2" />
  <Button title="Button 3" />
</div>
```


## Props de composant

Un composant Astro peut définir et accepter des props. Ces props deviennent ensuite disponibles pour le template du composant pour le rendu HTML. Les props sont disponibles sur le global `Astro.props` dans votre script de frontmatter.

Voici un exemple de composant qui reçoit un prop nommé `greeting` et un prop nommé `name`. Notez que les props à recevoir sont déstructurés de l'objet global `Astro.props`.

```astro "Astro.props"
---
// src/components/GreetingHeadline.astro
// Utilisation: <GreetingHeadline greeting="Comment ça va" name="Partenaire" />
const { greeting, name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
```

Ce composant, lorsqu'il est importé et utilisé dans d'autres composants standards, Composants Layout ou pages Astro, peut recevoir ces props sous forme d'attributs :

```astro /(\w+)=\S+/
---
// src/components/GreetingCard.astro
import GreetingHeadline from './GreetingHeadline.astro';
const name = "Astro"
---
<h1>Carte de bienvenue</h1>
<GreetingHeadline greeting="Salut" name={name} />
<p>J'espère que vous passez une merveilleuse journée !</p>
```

You can also define your props with TypeScript with a `Props` type interface. Astro will automatically pick up the `Props` interface in your frontmatter and give type warnings/errors. These props can also be given default values when destructured from `Astro.props`.
Vous pouvez également définir le type de vos props avec TypeScript en créant une interface nommée `Props`. Astro sélectionnera automatiquement l'interface `Props` dans le Script du Composant et donnera des avertissements/erreurs de type. Ces props peuvent également recevoir des valeurs par défaut lorsqu'ils sont déstructurés à partir d' `Astro.props`.

```astro ins={3-6}
---
// src/components/GreetingHeadline.astro
interface Props {
  name: string;
  greeting?: string;
}

const { greeting = "Hello", name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
```

Component props can be given default values to use when none are provided.

```astro ins="= \"Hello\"" ins="= \"Astronaut\""
---
// src/components/GreetingHeadline.astro
const { greeting = "Hello", name = "Astronaut" } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
```

## Slots

The `<slot />` element is a placeholder for external HTML content, allowing you to inject (or "slot") child elements from other files into your component template.

By default, all child elements passed to a component will be rendered in its `<slot />`

:::note
Unlike _props_, which are attributes passed to an Astro component available for use throughout your component with `Astro.props`, _slots_ render child HTML elements where they are written.
:::

```astro "<slot />"
---
// src/components/Wrapper.astro
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';

const { title } = Astro.props
---
<div id="content-wrapper">
  <Header />
  <Logo />
  <h1>{title}</h1>
  <slot />  <!-- children will go here -->
  <Footer />
</div>
```

```astro {6-7}
---
// src/pages/fred.astro
import Wrapper from '../components/Wrapper.astro';
---
<Wrapper title="Fred's Page">
  <h2>All about Fred</h2>
  <p>Here is some stuff about Fred.</p>
</Wrapper>
```

This pattern is the basis of an [Astro layout component](/en/core-concepts/layouts/): an entire page of HTML content can be “wrapped” with `<SomeLayoutComponent></SomeLayoutComponent>` tags and sent to the component to render inside of common page elements defined there.



### Named Slots

An Astro component can also have named slots. This allows you to pass only HTML elements with the corresponding slot name into a slot's location.

Slots are named using the `name` attribute:

```astro /<slot .*?/>/
---
// src/components/Wrapper.astro
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';

const { title } = Astro.props
---
<div id="content-wrapper">
  <Header />
  <slot name="after-header"/>  <!--  children with the `slot="after-header"` attribute will go here -->
  <Logo />
  <h1>{title}</h1>
  <slot />  <!--  children without a `slot`, or with `slot="default"` attribute will go here -->
  <Footer />
  <slot name="after-footer"/>  <!--  children with the `slot="after-footer"` attribute will go here -->
</div>
```

To inject HTML content into a particular slot, use the `slot` attribute on any child element to specify the name of the slot. All other child elements of the component will be injected into the default (unnamed) `<slot />`.


```astro /slot=".*?"/
---
// src/pages/fred.astro
import Wrapper from '../components/Wrapper.astro';
---
<Wrapper title="Fred's Page">
  <img src="https://my.photo/fred.jpg" slot="after-header">
  <h2>All about Fred</h2>
  <p>Here is some stuff about Fred.</p>
  <p slot="after-footer">Copyright 2022</p>
</Wrapper>
```


Use a `slot="my-slot"` attribute on the child element that you want to pass through to a matching `<slot name="my-slot" />` placeholder in your component.

:::tip
Named slots can also be passed to [UI framework components](/en/core-concepts/framework-components/)!
:::


### Fallback Content for Slots
Slots can also render **fallback content**. When there are no matching children passed to a slot, a `<slot />` element will render its own placeholder children.

```astro {14}
---
// src/components/Wrapper.astro
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';

const { title } = Astro.props
---
<div id="content-wrapper">
  <Header />
  <Logo />
  <h1>{title}</h1>
  <slot>
    <p>This is my fallback content, if there is no child passed into slot</p>
  </slot>
  <Footer />
</div>
```


## HTML Components

Astro supports importing and using `.html` files as components or placing these files within the `src/pages/` subdirectory as pages. You may want to use HTML components if you're reusing code from an existing site built without a framework, or if you want to ensure that your component has no dynamic features.

HTML components must contain only valid HTML, and therefore lack key Astro component features:
- They don't support frontmatter, server-side imports, or dynamic expressions.
- Any `<script>` tags are left unbundled, treated as if they had `is:inline`. 
- They can only [reference assets that are in the `public/` folder](/en/guides/images/#public).

:::note
A [`<slot />` element](/en/core-concepts/astro-components/#slots) inside an HTML component will work as it would in an Astro component. In order to use the [HTML Web Component Slot](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot) element instead, add `is:inline` to your `<slot>` element.
:::

## Next Steps

📚 Learn about using [UI framework components](/en/core-concepts/framework-components/) in your Astro project.

**Les composants Astro** sont les blocs de base de tout projet Astro. Ce sont des composants avec seulement du HTML, sans exécution côté client.

**Si vous connaissez le HTML, vous en savez déjà assez pour écrire votre premier composant Astro.**

La syntaxe du composant Astro est un sur-ensemble de HTML. La syntaxe a été [conçue pour être familière à toute personne ayant de l'expérience dans l'écriture de HTML ou JSX](#différences-entre-astro-et-jsx), et ajoute la prise en charge de l'inclusion de composants et d'expressions JavaScript. Vous pouvez repérer un composant Astro par son extension de fichier : `.astro`.

Les composants Astro sont extrêmement flexibles. Souvent, un composant Astro contiendra une **interface utilisateur réutilisable sur la page**, comme un en-tête ou une carte de profil. À d'autres moments, un composant Astro peut contenir un petit extrait de code HTML, comme une collection de balises `<meta>` courantes qui facilitent le travail avec le référencement. Les composants Astro peuvent même contenir la mise en page entière d'une page.

La chose la plus importante à savoir sur les composants Astro est qu'ils **produisent du HTML lors de la compilation.** Même si vous exécutez du code JavaScript à l'intérieur de vos composants, tout s'exécutera à l'avance, supprimé de la page finale que vous envoyez à vos utilisateurs. Le résultat est un site plus rapide, avec une empreinte JavaScript nulle ajoutée par défaut.

## Structure du composant

Un composant Astro est composé de deux parties principales : le **Script du composant** et le **Template du composant**. Chacune de ces parties s'occupe de faire une tâche différente, mais ensemble, constituent un cadre facile d'utilisation et assez expressif pour gérer tout ce que vous voulez construire.

```astro title="src/components/EmptyComponent.astro"
---
// Script du composant (JavaScript)
---
<!-- Template du composant (HTML + Expressions JS) -->
```

Vous pouvez utiliser des composants à l'intérieur d'autres composants pour créer une interface utilisateur de plus en plus complexe. Par exemple, un composant `Button` pourrait être utilisé pour créer un composant `ButtonGroup` comme ceci :

```astro title="src/components/ButtonGroup.astro"
---
import Button from './Button.astro';
---
<div>
  <Button title="Button 1" />
  <Button title="Button 2" />
  <Button title="Button 3" />
</div>
```

### Le Script du composant

Astro utilise des barres de code (`---`) pour identifier le script du composant dans votre composant Astro. Si vous avez déjà écrit du Markdown avant, vous pourriez être déjà familier avec un concept similaire appelé *frontmatter.* Astro est directement inspiré de cela.

Vous pouvez utiliser le script du composant pour écrire du code JavaScript qui vous aidera à construire votre template. Cela peut inclure :

- Importer d'autres composants Astro
- Importer des composants de Framework, comme React
- Importer des données, comme un fichier JSON
- Récupérer le contenu d'une API ou une base de données
- Créer des variables que vous voulez référencer dans votre template

```astro title="src/components/MyComponent.astro"
---
import SomeAstroComponent from '../components/SomeAstroComponent.astro';
import SomeReactComponent from '../components/SomeReactComponent.jsx';
import someData from '../data/pokemon.json';

// Accéder aux propriétés passées dans le composant, comme `<X title="Hello, World" />`
const {title} = Astro.props;
// Récupérer des données externes, même depuis une API privée ou une base de données
const data = await fetch('SOME_SECRET_API_URL/users').then(r => r.json());
---
<!-- Votre template ici ! -->
```

Les barres de code sont conçues pour garantir que le code JavaScript que vous écrivez à l'intérieur "ne puisse pas s'échapper". Ce code n'apparaîtra pas dans le code final de votre page et ne sera pas visible à vos utilisateur. Vous pouvez écrire du code JavaScript coûteux (en terme de performance) ou sensible (comme un appel à votre base de données privée) sans vous soucier qu'il se retrouve dans le navigateur l'utilisateur.

:::tip
Vous pouvez même écrire du TypeScript dans votre script de composant !
:::

### Le Template du composant

En dessous du script du composant se trouve le template du composant. Le template du composant détermine le HTML résultant de votre composant.

Si vous écrivez du HTML simple ici, votre composant affichera cet HTML dans toutes les pages où il est importé et utilisé.

De plus, la syntaxe du template du composant Astro prend également en charge les **expressions JavaScript**, les **composants importés** et les [**directives spéciales Astro**](/fr/reference/directives-reference/). Les données et les valeurs définies (à la compilation) dans le script du composant peuvent être utilisées dans le template du composant pour produire du HTML dynamiquement créé.

```astro title="src/components/MyFavoritePokemon.astro"
---
// Votre script du composant ici !
import ReactPokemonComponent from '../components/ReactPokemonComponent.jsx';
const myFavoritePokemon = [/*... */];
---
<!-- les commentaires HTML sont supportés ! -->

<h1>Hello, world!</h1>

<!-- Utilisez les propriétés et autres variables du script du composant : -->
<p>Mon pokemon favori est : {Astro.props.title}</p>

<!-- Incluez d'autres composants avec une directive `client:` pour l'hydrater : -->
<ReactPokemonComponent client:visible />

<!-- Mixez du HTML avec des expressions JavaScript, similaire au JSX : -->
<ul>
  {myFavoritePokemon.map((data) => <li>{data.name}</li>)}
<ul>

<!-- Utilisez une directive de template pour créer des classes à partir de plusieurs chaînes ou même d'objets ! -->
<p class:list={["add", "dynamic", {classNames : true}]} />
```

## Expressions JSX

Vous pouvez définir des variables JavaScript locales dans le script du composant Astro. Vous pouvez ensuite injecter ces variables dans le template HTML du composant à en utilisant des expressions de type JSX !

:::note[dynamique vs réactif]
En utilisant cette approche, vous pouvez inclure des valeurs **dynamiques** qui sont calculées dans le frontmatter. Mais une fois incluses, ces valeurs ne sont pas **réactives** et ne changeront jamais. Les composants Astro sont des templates qui ne s'exécutent qu'une seule fois, au moment de la compilation.

Voir ci-dessous pour plus d'exemples de [différences entre Astro et JSX](#différences-entre-astro-et-jsx).
:::

### Variables

Des variables locales peuvent être ajoutées dans le HTML en utilisant la syntaxe des accolades :

```astro title="src/components/Variables.astro" "{name}"
---
const name = "Astro";
---
<div>
  <h1>Hello {name}!</h1>  <!-- Affichera <h1>Hello Astro!</h1> -->
</div>
```

### Attributs dynamiques

Les variables locales peuvent être utilisées entre accolades pour transmettre des valeurs d'attribut aux éléments HTML et aux composants :

```astro title="src/components/DynamicAttributes.astro" "{name}" "${name}"
---
const name = "Astro";
---
<h1 class={name}>Les expressions d'attributs sont prises en charge</h1>

<MyComponent templateLiteralNameAttribute={`MonNomEst${name}`} />
```

:::caution
Les attributs HTML seront convertis en chaînes, il n'est donc pas possible de passer des fonctions et des objets aux éléments HTML. Par exemple, vous ne pouvez pas affecter un gestionnaire d'événements à un élément HTML dans un composant Astro :

```astro
---
// dont-do-this.astro
function handleClick () {
  console.log("boutton cliqué!");
}
---
<!-- ❌ Cela ne marche pas! ❌ -->
<button onClick={handleClick}>Rien ne se passera lorsque vous cliquez sur moi!</button>
```

Au lieu de cela, utilisez un script côté client pour ajouter le gestionnaire d'événements, comme vous le feriez en JavaScipt pure :

```astro
---
// do-this-instead.astro
---

<button id="button">Click Me</button>
<script>
  function handleClick () {
    console.log("button clicked!");
  }
  document.getElementById("button").addEventListener("click", handleClick);
</script>
```
:::

### HTML dynamique

Les variables locales peuvent être utilisées dans des fonctions de type JSX pour produire des éléments HTML générés dynamiquement :

```astro title="src/components/DynamicHtml.astro" "{item}"
---
const items = ["Chien", "Chat", "Ornithorynque"];
---
<ul>
  {items.map((item) => (
    <li>{item}</li>
  ))}
</ul>
```

Astro peut afficher conditionnellement du HTML à l'aide d'opérateurs logiques JSX et d'expressions ternaires.

```astro title="src/components/ConditionalHtml.astro" "visible"
---
const visible = true;
---
{visible && <p>Montre moi!</p>}

{visible ? <p>Montre moi!</p> : <p>Sinon montre moi!</p>}
```

### Balises dynamiques

Vous pouvez également utiliser des balises dynamiques en définissant une variable affectée d'un nom de balise HTML ou d'un composant importé :

```astro title="src/components/DynamicTags.astro" /Element|(?<!My)Component/
---
import MyComponent from "./MyComponent.astro";
const Element = 'div'
const Component = MyComponent;
---

<Element>Salut!</Element> <!-- s'affiche comme <div>Salut!</div> -->
<Component /> <!-- s'affiche comme <MyComponent /> -->
```

Lors de l'utilisation de balises dynamiques :

- **Les noms de variables doivent commencer par une lettre majuscules.** Par exemple, utilisez `Element`, et non `element`. Sinon, Astro essaiera de restituer le nom de votre variable sous la forme d'une balise HTML littéralement.

- **Les directives d'hydratation ne sont pas prises en charge.** Lorsque vous utilisez [les directives d'hydratation `client:*`](/fr/core-concepts/framework-components/#hydratation-des-composants-interactifs), Astro doit savoir quels composants regrouper pour la production, et le modèle de balise dynamique empêche cela de fonctionner.

### Fragments et éléments multiples

Un template de composant Astro peut restituer plusieurs éléments sans avoir besoin de tout envelopper dans un seul `<div>` ou `<>`, contrairement à JavaScript ou JSX.

```astro title="src/components/RootElements.astro"
---
// Template with multiple elements
---
<p>Pas besoin d'envelopper les éléments dans un seul élément conteneur.</p>
<p>Astro prend en charge plusieurs éléments à la racine du template</p>
```

Cependant, lorsque vous utilisez une expression pour créer dynamiquement plusieurs éléments, vous devez entourer ces éléments dans un **fragment** comme vous le feriez dans du JavaScript ou du JSX. Astro prend en charge l'utilisation de `<Fragment> </Fragment>` ou de la syntaxe abrégée `<> </>`.

```astro title="src/components/FragmentWrapper.astro" "<>" "</>"
---
const items = ["Chien", "Chat", "Ornithorynque"];
---
<ul>
  {items.map((item) => (
    <>
      <li>Rouge {item}</li>
      <li>Bleu {item}</li>
      <li>Vert {item}</li>
    </>
  ))}
</ul>
```

Les Fragments peuvent aussi être utiles pour éviter d'utiliser des éléments conteneurs lors de l'ajout de [directives `set:*`](/fr/reference/directives-reference/#sethtml), comme dans l'exemple suivant :

```astro title="src/components/SetHtml.astro" "Fragment"
---
const htmlString = '<p>Contenu HTML brut</p>';
---
<Fragment set:html={htmlString} />
```

### Différences entre Astro et JSX

La syntaxe du composant Astro est un sur-ensemble de HTML. Il a été conçu pour être familier à toute personne ayant une expérience HTML ou JSX, mais il existe quelques différences clés entre les fichiers `.astro` et JSX.

#### Les attributs

Dans Astro, vous utilisez le format standard `kebab-case` pour tous les attributs HTML au lieu du `camelCase` utilisé dans JSX. Cela fonctionne même pour `class`, qui n'est pas pris en charge par React.

```jsx
<div className="box" dataValue="3" />
<div class="box" data-value="3" />
```

#### Les commentaires

Dans Astro, vous pouvez utiliser des commentaires HTML standard ou des commentaires de style JavaScript.

```astro title="example.astro"
---
---
<!-- La syntaxe de commentaire HTML est valide dans les fichiers.astro -->
{/* La syntaxe des commentaires JS est également valide */}
```

:::caution
Les commentaires de style HTML seront inclus dans le DOM du navigateur, tandis que ceux en JS seront ignorés. Pour laisser des messages TODO ou d'autres explications réservées au développement, vous pouvez utiliser des commentaires de style JavaScript à la place.
:::

## Props de composant

Un composant Astro peut définir et accepter des "props". Ces props deviennent alors accessible dans le template du composant pour le rendu du HTML. Les props sont disponibles sur la variable globale `Astro.props` entre les barres de codes.

Voici un exemple de composant qui reçoit un prop nommé `greeting` et un prop nommé `name`. Notez que les props à recevoir sont déstructurés de l'objet global `Astro.props`.

```astro "Astro.props"
---
// src/components/GreetingHeadline.astro
// Utilisation: <GreetingHeadline greeting="Comment ça va" name="Partenaire" />
const { greeting, name } = Astro.props;
---
<h2>{greeting}, {name} !</h2>
```

Ce composant, lorsqu'il est importé et utilisé dans d'autres composants standards, Composants Layout ou pages Astro, peut recevoir ces props sous forme d'attributs :

```astro /(\w+)=\S+/
---
// src/components/GreetingCard.astro
import GreetingHeadline from './GreetingHeadline.astro';
const name = "Astro"
---
<h1>Carte de bienvenue</h1>
<GreetingHeadline greeting="Salut" name={name} />
<p>J'espère que vous passez une merveilleuse journée !</p>
```

Vous pouvez également définir le type de vos props avec TypeScript en créant une interface nommée `Props`. Astro sélectionnera automatiquement l'interface `Props` dans le Script du Composant et donnera des avertissements/erreurs de type. Ces props peuvent également recevoir des valeurs par défaut lorsqu'ils sont déstructurés à partir d' `Astro.props`.

```astro ins={3-6}
---
// Votre script du composant ici !
---
<style>
  /* restreint au composant, les autres balises H1 sur la page restent les mêmes */
  h1 { color: red };
</style>

<h1>Hello, world!</h1>
```

Les props de composant peuvent recevoir des valeurs par défaut à utiliser lorsqu'aucune n'est fournie

```astro ins="= \"Hello\"" ins="= \"Astronaut\""
---
// src/components/GreetingHeadline.astro
const { greeting = "Salut", name = "Astronaute" } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
```

## Les emplacements (slots)

L'élément `<slot />` est un emplacement réservé pour du contenu HTML externe, vous permettant d'injecter des éléments enfants depuis d'autres fichiers, dans le template de votre composant.

Par défaut, tous les éléments enfants passés à un composant seront rendus dans son `<slot />`

:::note
Contrairement aux *props*, qui sont des attributs passés à un composant Astro disponibles pour une utilisation dans votre composant avec `Astro.props`, *les emplacements* restituent les éléments HTML enfants là où ils sont placés.
:::

```astro "<slot />"
---
// src/components/Wrapper.astro
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';

const { title } = Astro.props
---
<div id="content-wrapper">
  <Header />
  <Logo />
  <h1>{title}</h1>
  <slot /> <!-- les élement enfants seront insérés ici -->
  <Footer />
</div>
```

```astro {6-7}
---
// src/pages/fred.astro
import Wrapper from '../components/Wrapper.astro';
---

<Wrapper title="Page de Fred">
  <img src="https://my.photo/fred.jpg" slot="after-header">
  <h2>Tout ce qui est a savoir sur Fred</h2>
  <p>Voici quelques truc à propos de Fred.</p>
</Wrapper>
```

Ce modèle est la base d'un Composant Layout dans Astro : une page entière de contenu HTML peut être "enveloppée" avec des balises `<Layout></Layout>` et envoyée à au Composant Layout pour être rendu à l'intérieur des éléments de page communs.

### Les emplacements nommés

Un composant Astro peut aussi avoir des emplacements nommés. Cela vous permet de ne faire passer que des éléments HTML avec le nom d'emplacement (slot) correspondant, au niveau de l'emplacement.

```astro /<slot.*?/>/
---
// src/components/Wrapper.astro
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';

const { title } = Astro.props
---
<div id="content-wrapper">
<Header />
<slot name="after-header"/> <!-- les enfants avec l'attribut `slot="after-header" iront ici  -->
<Logo />
<h1>{title}</h1>
<slot /> <!-- les enfants sans `slot` ou avec l'attribut `slot="default"`iront ici -->
<Footer />
<slot name="after-footer"/> <!-- les enfants avec l'attribut `slot="after-footer"` iront ici -->
</div>
```

```astro /slot=".*?"/
---
// src/pages/fred.astro
import Wrapper from '../components/Wrapper.astro';
---

<Wrapper title="Page de Fred">
  <img src="https://my.photo/fred.jpg" slot="after-header">
  <h2>Tout ce qui est a savoir sur Fred</h2>
  <p>Voici quelques truc à propos de Fred.</p>
  <p slot="after-footer">Copyright 2022</p>
</Wrapper>
```

Utilisez un attribut `slot="my-slot"` sur l'élément enfant que vous voulez passer à un emplacement correspondant `<slot name="my-slot" />` dans votre composant.

:::tip
Les emplacements nommés peuvent aussi être passés aux [composants de framework](/fr/core-concepts/framework-components/) !
:::

### Contenu par defaut pour les emplacement

Les emplacements peuvent également restituer **du contenu par defaut**. Lorsqu'il n'y a pas d'enfants correspondants passés à un emplacement, un élément `<slot />` affichera ses propres enfants.

```astro {14}
---
// src/components/Wrapper.astro
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';

const { title } = Astro.props
---
<div id="content-wrapper">
  <Header />
  <Logo />
  <h1>{title}</h1>
  <slot>
    <p>Ceci est mon contenu par defaut, s'il n'y a pas d'enfants passés à l'emplacement</p>
  </slot>
  <Footer />
</div>
```

## Styles CSS

Les balises CSS `<style>` sont également permises dans le template du composant.

Elles peuvent être utilisées pour donner du style à vos composants, et toutes les règles de style sont automatiquement limitées à la portée du composant lui-même pour éviter les conflits CSS dans les applications volumineuses.

```astro title="src/components/StyledHeading.astro"
---
// Le script du composant ici !
---
<style>
  /* restreint au composant, les autres balises H1 de la page resteront inchangés */
  h1 { color: red }
</style>

<h1>Hello, world!</h1>
```

:::caution
Les styles définis ici s'appliquent uniquement au contenu écrit directement dans le template du composant lui-même. Les enfants et tous les composants importés ne seront **pas** stylisés par défaut.
:::

📚 Allez voir notre [Guide des styles](/fr/core-concepts/framework-components/) pour plus d'informations sur l'application de styles.

## Scripts côté client

Les composants Astro prennent en charge l'ajout d'interactivité côté client à l'aide de balises HTML `<script>` standard.

Les scripts peuvent être utilisés pour ajouter des écouteurs d'événements, envoyer des données d'analyse, jouer des animations et tout ce que JavaScript peut faire sur le Web.

```astro
// src/components/ConfettiButton.astro
<button data-confetti-button>Célébrez !</button>

<script>
  // Importe des modules npm.
  import confetti from 'canvas-confetti';

  // Trouve des éléments du DOM sur la page.
  const buttons = document.querySelectorAll('[data-confetti-button]');

  // Ajoute des écouteurs d'événements pour déclencher des confettis lorsqu'un bouton est cliqué
  buttons.forEach((button) => {
    button.addEventListener('click', () => confetti());
  });
</script>
```

Par défaut, les balises `<script>` sont optimisées par Astro, ajoutant la prise en charge de l'importation de modules npm, de l'écriture de TypeScript, etc.

📚 Consultez notre [guide sur les scripts](/fr/guides/client-side-scripts/) pour plus de détails.

## Composants HTML

Astro prend en charge l'importation et l'utilisation de fichiers `.html` en tant que composants ou le placement de ces fichiers dans le sous-répertoire `src/pages` en tant que pages. Vous souhaiterez peut-être utiliser des composants HTML si vous réutilisez le code d'un site existant construit sans framework, ou si vous voulez vous assurer que votre composant n'ai pas de fonctionnalités dynamiques.

Les composants HTML ne doivent contenir que du code HTML valide et ne disposent donc pas des fonctionnalités clés des composants Astro :

- Ils ne prennent pas en charge de Script de Composant, les importations côté serveur ou les expressions dynamiques.
- Toutes les balises `<script>` sont laissées non regroupées, traitées comme si elles avaient `is:inline`.
- Ils ne peuvent [référencer que les assets qui se trouvent dans le dossier `public/`](/fr/guides/images/#public).

:::note
Un [élément `<slot />`](#les-emplacements-slots) à l'intérieur d'un composant HTML fonctionnera comme il le ferait dans un composant Astro. Pour utiliser l'élément [Slot des Web Components (composants web)](https://developer.mozilla.org/fr/docs/Web/HTML/Element/slot)  à la place, ajoutez `is:inline` à votre élément `<slot>`.
:::

## Étapes suivantes

📚 En savoir plus sur les [composants intégrés d'Astro](/fr/reference/api-reference/#built-in-components).

📚 Apprendre comment utiliser les [composants de framework JavaScript](/fr/core-concepts/framework-components/) dans votre projet Astro.
