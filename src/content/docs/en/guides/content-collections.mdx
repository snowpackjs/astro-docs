---
title: Collections
description: >-
  Learn about Astro's content collections.
i18nReady: true
---
import { FileTree, CardGrid, LinkCard, Steps } from '@astrojs/starlight/components';
import Since from '~/components/Since.astro'
import RecipeLinks from "~/components/RecipeLinks.astro"
import Badge from "~/components/Badge.astro"

<p><Since v="2.0.0" /></p>

**Content collections** are the best way to manage sets of content in any Astro project. Collections help to organize and query your documents, enable Intellisense and type checking in your editor, and provide automatic TypeScript type-safety for all of your content.

Astro v5.0 introduced the Content Layer API for defining and querying content collections. This performant, scalable API provides built-in content loaders for your local collections. For remote content, you can use third-party and community-built loaders or create your own custom loader and pull in your data from any source.

:::note
Projects may continue using the legacy Content Collections API introduced in Astro v2.0. However, we encourage you to [update any existing collections](#updating-existing-collections) when you are able.
:::

## Get started with content collections

Explore the guides below to set up your first collection:

<CardGrid>
  <LinkCard
    title="Defining collections"
    description="See how to use `defineCollection()` to define a content schema and how to load your content."
    href="/en/guides/defining-collections/"
  />
  <LinkCard
    title="Using data stored as collections"
    description="Explore the helper functions to query and render data from your collections, create page routes, and more."
    href="/en/guides/working-with-collections/"
  />
  {/* <LinkCard
    title="Migrate from file-based routing"
    description="Follow a short tutorial to convert an existing blog with Markdown files in `src/pages/posts/` to a `blog` collection."
    href="/en/tutorials/add-content-collections/"
  /> */}
</CardGrid>


<LinkCard
    title="Tutorial: Migrate from file-based routing"
    description="Follow a short tutorial to convert a basic blog example with Markdown files in `src/pages/posts/` to a `blog` collection using the codebase from the Build a Blog tutorial."
    href="/en/tutorials/add-content-collections/"
  />

## What are Content Collections?

You can define a **collection** from a set of data that is structurally similar. This can be a directory of blog posts, a JSON file of product items, or any data that represents multiple items of the same shape.

Collections stored locally in your project or on your filesystem can have entries of Markdown, MDX, Markdoc, or JSON files:

<FileTree>
- src/
- **newsletter/** the "newsletter" collection
  - week-1.md a collection entry
  - week-2.md a collection entry
  - week-3.md a collection entry
- **authors/** the "author" collection
  - authors.json a single file containing all collection entries
</FileTree>

With an appropriate collection loader, you can fetch remote data from any external source, such as a CMS, database, or headless payment system.

## TypeScript configuration for collections

Content collections rely on TypeScript to provide Zod validation, Intellisense and type checking in your editor. If you are not extending one of Astro's  `strict` or `strictest` TypeScript settings, you will need to ensure the following `compilerOptions` are set in your `tsconfig.json`:

```json title="tsconfig.json" ins={5} {6}
{
  // Included with "astro/tsconfigs/strict" or "astro/tsconfigs/strictest"
  "extends": "astro/tsconfigs/base",
  "compilerOptions": {
    "strictNullChecks": true, // add if using `base` template
    "allowJs": true // required, and included with all Astro templates
  }
}
```

## When to create a collection

You can [create a collection](/en/guides/defining-collections/) any time you have a group of related data or content that shares a common structure.

Much of the benefit of using collections comes from:

- Defining a common data shape to validate that an individual entry is "correct" or "complete", avoiding errors in production.
- Content-focused APIs designed to make querying intuitive (e.g. `getCollection()` instead of `import.meta.glob()`) when importing and rendering content on your pages.
- A [Loader API](/en/reference/loader-reference/) for retrieving your content that provides both built-in loaders and access to the low-level API. There are several third-party and community-built loaders available, and you can build your own custom loader to fetch data from anywhere.
- Performance and scalability. The Content Layer API allows data to be cached between builds and is suitable for tens of thousands of content entries.

[Define your data](/en/guides/defining-collections/) as a collection when:

- You have multiple files or data to organize that share the same overall structure (e.g. blog posts written in Markdown which all have the same frontmatter properties).
- You have existing content stored remotely, such as in a CMS, and want to take advantage of the collections helper functions and Content Layer API instead of using `fetch()` or SDKs.
- You need to fetch (tens of) thousands of related pieces of data, and need a querying and caching method that handles at scale.

### When not to create a collection

Collections provide excellent structure, safety, and organization when you have **multiple pieces of content that must share the same properties**.

Collections **may not be your solution** if:

- You have only one or a small number of different pages. Consider [making individual page components](/en/basics/astro-pages/) such as `src/pages/about.astro` with your content directly instead.
- Your data is not stored in a supported format, such as TOML. Use other methods of [importing files](/en/guides/imports/#import-statements) or [fetching data](/en/guides/data-fetching/) instead.
- You are displaying files that are not processed by Astro, such as PDFs. Place these static assets in the [`public/` directory](/en/basics/project-structure/#public) of your project instead.
- You are using APIs that need to be updated in real time. Content collections are only updated at build time, so if you need live data you should consider [on-demand rendering](/en/guides/server-side-rendering/). UPDATE THIS LINK TO ON-DEMAND RENDERING GUIDE


## Collections using the previous API

Existing content and data collections using the original Content Collections API will continue to function alongside collections using the Content Layer API for a transition period.

No change to your existing collections is necessary until you decide to update them. You can even have both kinds of collections defined in your content configuration file at the same time.

You can find complete documentation for collections using the original API in this unmaintained snapshot of v4.x docs. No updates will be made to how these collections are used, and you can rely on that documentation until these collections are no longer supported.

We recommend updating any existing collections as soon as you are able, and making any new collections using the Content Layer API.

### Updating existing collections

You can convert an existing content collection with Markdown, MDX, Markdoc, or JSON entries to use the Content Layer API.

<Steps>

1. **Move the collection folder out of `src/content/`** (e.g. to `src/data/`). All collections located in the `src/content/` folder will use the existing Content Collections API. This is a temporary restriction necessary during the transition period where both types of collections are allowed.

    **Do not move the existing `src/content/config.ts` file**. This file will define all collections, using either API.

2. **Edit the collection definition**. Your updated collection requires a `loader`, and the option to select a collection `type` is no longer available.

    ```ts ins={3,8} del={7}
    // src/content/config.ts
    import { defineCollection, z } from 'astro:content';
    import { glob } from 'astro/loaders';

    const blog = defineCollection({
      // For content layer you no longer define a `type`
      type: 'content',
      loader: glob({ pattern: '**\/[^_]*.md', base: "./src/data/blog" }),
      schema: z.object({
        title: z.string(),
        description: z.string(),
        pubDate: z.coerce.date(),
        updatedDate: z.coerce.date().optional(),
      }),
    });
    ```

3. **Change references from `slug` to `id`**. Content layer collections do not have a `slug` field. Instead, all updated collections will have an `id`.

    ```astro ins={7} del={6}
    // src/pages/index.astro
    ---
    export async function getStaticPaths() {
      const posts = await getCollection('blog');
      return posts.map((post) => ({
        params: { slug: post.slug },
        params: { slug: post.id },
        props: post,
      }));
    }
    ---
    ```

4. **Switch to the new `render()` function**. Entries no longer have a `render()` method, as they are now serializable plain objects. Instead, import the `render()` function from `astro:content`.

    ```astro title="src/pages/index.astro" ins=", render" del={6} ins={7}
    ---
    import { getEntry, render } from 'astro:content';

    const post = await getEntry('blog', params.slug);

    const { Content, headings } = await post.render();
    const { Content, headings } = await render(post);
    ---
    <Content />
    ```
</Steps>
