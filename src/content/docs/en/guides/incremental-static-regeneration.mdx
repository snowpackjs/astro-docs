---
title: Incremental Static Regeneration
---
If your website fetches content from a CMS or a database that updates infrequently, you can use a technique called **Incremental Static Regeneration**, or ISR, to update your site without rebuilding the entire project. This is a great way to keep your site up-to-date while still enjoying the benefits of static hosting.

:::note
ISR is often presented as an alternative to SSG and SSR, but it's more helpful to think of it as SSR with caching.
:::

:::note
Incremental static regeneration is different from **incremental builds**, which speeds up full rebuilds by reusing work done by the previous builds.
:::


## Applying ISR in Your Project

ISR involves saving the response such that it can be reused for future requests. The exact implementation depends on your deployment target.

### Self-hosted Node.js
ISR can be implemented in Node.js by writing a caching middleware. The following middleware caches the response in memory for 60 seconds:

```ts title="src/middleware.ts"

const cache = {}

export const onRequest = async ({ request }, next) => {
    const cached = cache[request.url]
    
    if (cached) {
        if (cached.expires > Date.now()) {
            // return cached response
            return cached.response.clone()
        }
        else {
            // remove stale response
            delete cache[request.url]
        }
    }
    
    else {
        const response = await next()
        cache[request.url] = {
            expires: Date.now() + 60 * 1000,
            response: response.clone()
        }
        // return fresh response
        return response
    }
}
```

### Node.js on AWS Lambda
Lambda instances are ephemeral, which means they might lose all state between invocation - on-disk and in-memory.
:::note
TODO: Investigate disk mounts
:::

### Self-hosted Deno
The middleware approach used for Node will work on Deno. However, Deno also implements the Web Cache API that can persist the cache across restarts. The following middleware uses the Web Cache API to cache responses for 60 seconds:

```ts title="src/middleware.ts"

const cache = await caches.open('astro')

export const onRequest = async ({ request }, next) => {
    const cachedResponse = await cache.match(request)
    
    if (cachedResponse) {
        const expires = Number(cachedResponse.headers.get('X-expires'))
        if (expires > Date.now()) {
            // return cached response
            return cachedResponse
        }
        else {
            // remove stale response
            await cache.delete(request)
        }
    }
    
    else {
        const response = await next()
        
        // set expiry
        response.headers.set('X-expires', String(Date.now() + 60 * 1000))

        await cache.put(request.url, response.clone())
        // return fresh response
        return response
    }
}
```

### Deno Deploy
Deno Deploy does not provide a way to persist data. However, you may be able to use a third-party database to manually cache responses. While this avoids calls to your CMS, you may still experience significant latencies due to the network round-trip time between the Deno Deploy instance and your database.

### Nginx, Traeffik, other reverse proxies that offer caching
:::note
TODO
:::

### Vercel
Vercel provides a built-in caching layer that automatically saves cacheable responses. Make sure your server-rendered page or endpoint sets a `Cache-Control` header.

```astro title="src/pages/index.astro"
---
Astro.response.headers.set('Cache-Control', 's-maxage=60')
---
<h1>Welcome to Astro</h1>
```

```ts title="src/pages/api.ts"
export async function get({ params, request }) {
    ...
    return new Response(content, {
        headers: { "Cache-Control": "s-maxage=60" }
    })
}
```
:::note
The presence of `s-maxage=60` in your `Cache-Control` header tells the caching server to cache the response for 60 seconds, whereas `max-age=60` tells the same to your visitors' browsers as well. Use `max-age` when your content is unlikely to be edited. If a page with `max-age` updates after it has been visited by a user, their browser will show them the cached version until the expiration time.
:::

### Netlify
Netlify supports caching responses why its (On-demand builders)[https://docs.netlify.com/configure-builds/on-demand-builders/] feature. You can leverage it by enabling them in your config file.

```ts title="stro.config.js" ins={6}
import { defineConfig } from 'astro/config'
import netlify from '@astrojs/netlify/functions'

export default defineConfig({
  output: 'server',
  adapter: netlify({ builders: true })
})
```
:::note
TODO: Investigate whether this works on edge functions.
:::

### Cloudflare Pages/Workers
Cloudflare Workers implements the Web Cache API, with a glaring difference being the fact it will automatically delete stale cache. You can use a combination of a caching middleware along with settings response headers in your frontmatter.
  
```astro title="src/pages/index.astro"
---
Astro.response.headers.set('Cache-Control', 'max-age=3600')
---
<h1>Welcome to Astro</h1>
```
  
```ts title="src/middleware.ts"

// caches.default is specific to cloudflare
const cache = caches.default

export const onRequest = async ({ request }, next) => {
    const cachedResponse = await cache.match(request)
    
    if (cachedResponse) {
        // return cached response
        return cachedResponse
    }
    
    else {
        // render a fresh response
        const response = await next()
        
        // add to cache
        await cache.put(request, response.clone())
        
        // return fresh response
        return response
    }
}
```
