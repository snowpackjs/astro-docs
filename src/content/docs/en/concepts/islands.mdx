---
title: Island Architecture
description: "Island architecture is a webpage architecture pattern pioneered by Astro, optimized for performance. Island architecture was first coined by Etsy's frontend architect Katie Sylor-Miller in 2019, and expanded on by Preact creator Jason Miller."
i18nReady: true
---

import IslandsDiagram from '~/components/IslandsDiagram.astro';

Astro was created to help pioneer and popularize a new frontend architecture pattern called **Island Architecture.** Island architecture works by rendering the majority of your page to fast, static HTML with smaller "islands" of JavaScript added when interactivity or personalization is needed on the page (an image carousel, for example). This avoids the monolithic JavaScript payloads that slow down the responsiveness of many other, modern JavaScript web frameworks.

## A brief history

The term "component island" was first coined by Etsy's frontend architect [Katie Sylor-Miller](https://twitter.com/ksylor) in 2019. This idea was then expanded on and documented in [this post](https://jasonformat.com/islands-architecture/) by Preact creator Jason Miller on August 11, 2020.

> The general idea of an "Islands" architecture is deceptively simple: render HTML pages on the server, and inject placeholders or slots around highly dynamic regions [...] that can then be "hydrated" on the client into small self-contained widgets, reusing their server-rendered initial HTML.  
> — Jason Miller, Creator of Preact

The technique that this architectural pattern builds on is also known as **partial** or **selective hydration.**

In contrast, most JavaScript-based web frameworks hydrate & render an entire website as one large JavaScript application (also known as a single-page application, or SPA). SPAs provide simplicity and power but suffer from page-load performance problems due to heavy client-side JavaScript usage.

SPAs have their place, even [embedded inside an Astro page](/en/guides/migrate-to-astro/from-create-react-app/). But, SPAs lack the native ability to selectively and strategically hydrate, making them a heavy-handed choice for most projects on the web today.

Astro became popular as the first mainstream JavaScript web framework with selective hydration built-in, using that same component islands pattern first coined by Sylor-Miller. We've since expanded and evolved on Sylor-Miller's original work, adding support for more powerful islands like dynamic [server islands](#server-islands).

## What is an island?

**In Astro, an island refers to special, enhanced pieces of UI on an otherwise static page of HTML.** A **client island** refers to an interactive JavaScript UI component, while a **server island** refers to some dynamically server-rendered UI component.

<IslandsDiagram>
  <Fragment slot="headerApp">Header (interactive island)</Fragment>
  <Fragment slot="sidebarApp">Sidebar (static HTML)</Fragment>
  <Fragment slot="main">
    Static content like text, images, etc.
  </Fragment>
  <Fragment slot="carouselApp">Image carousel (interactive island)</Fragment>
  <Fragment slot="footer">Footer (static HTML)</Fragment>
  <Fragment slot="source">Source: [Island Architecture: Jason Miller](https://jasonformat.com/islands-architecture/)</Fragment>
</IslandsDiagram>

An island always runs in isolation from other islands on the page, and multiple islands can exist on a page. Client islands can still share state and communicate with each other, even though they run in different component contexts.

This flexibility allows Astro to support multiple UI frameworks like [React](https://react.dev/), [Preact](https://preactjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), and [SolidJS](https://www.solidjs.com/). Because they are independent, you can even mix several frameworks on each page.

:::tip
Although most developers will stick to just one UI framework, Astro supports multiple frameworks in the same project. This allows you to:

- Choose the framework that is best for each component.
- Learn a new framework without needing to start a new project.
- Collaborate with others even when working in different frameworks.
- Incrementally convert an existing site to another framework with no downtime.
:::

## Client islands

By default, Astro will automatically render every UI component to just HTML & CSS, **stripping out all client-side JavaScript automatically.** 


```astro title="src/pages/index.astro"
<MyReactComponent />
```

This may sound strict, but this behavior is what keeps Astro websites fast by default and protects developers from accidentally sending unnecessary or unwanted JavaScript that might slow down their website.

Turning any static UI component into an interactive island requires only a `client:*` directive. Astro then automatically builds and bundles your client-side JavaScript for optimized performance.

```astro title="src/pages/index.astro" ins="client:load"
<!-- This component is now interactive on the page! 
     The rest of your website remains static. -->
<MyReactComponent client:load />
```

With islands, client-side JavaScript is only loaded for the explicit interactive components that you mark using `client:*` directives.

And because interaction is configured at the component-level, you can handle different loading priorities for each component based on its usage. For example, `client:idle` tells a component to load when the browser becomes idle, and `client:visible` tells a component to load only once it enters the viewport.

### Benefits of client islands

The most obvious benefit of building with Astro Islands is performance: the majority of your website is converted to fast, static HTML and JavaScript is only loaded for the individual components that need it. JavaScript is one of the slowest assets that you can load per-byte, so every byte counts.

Another benefit is parallel loading. In the example illustration above, the low-priority "image carousel" island doesn't need to block the high-priority "header" island. The two load in parallel and hydrate in isolation, meaning that the header becomes interactive immediately without having to wait for the heavier carousel lower down the page.

Even better, you can tell Astro exactly how and when to render each component. If that image carousel is really expensive to load, you can attach a special [client directive](/en/reference/directives-reference/#client-directives) that tells Astro to only load the carousel when it becomes visible on the page. If the user never sees it, it never loads.

In Astro, it’s up to you as the developer to explicitly tell Astro which components on the page need to also run in the browser. Astro will only hydrate exactly what’s needed on the page and leave the rest of your site as static HTML. 

**Client islands are the secret to Astro’s fast-by-default performance story!**

## Server islands

Each server island is a UI component that is rendered to the page independently from the rest, making it easy to combine high performance static HTML and dynamic server-generated components.

Add the [`server:defer` directive](/en/reference/directives-reference/#server-directives) to any component on your page to turn it into its own island:

```astro title="src/pages/index.astro" "server:defer"
---
import Avatar from '../components/Avatar.astro';
---
<Avatar server:defer />
```

This allows your page's critical content to be rendered immediately as a shell, while deferring your most dynamic UI elements, such as user avatars or product reviews. Different API endpoints load at different speeds, and server islands all load individually in parallel. A slower island won’t delay the rest of the page's personalized content from being available.

Server islands provide a single caching solution for pages that combine multiple types of content:

- Completely static and never changes.
- Dynamically backed by a database that changes infrequently, but more often than you deploy.
- Personalized content, tailored to individual users.

Astro's server island implementation happens mostly at build time, where component content is swapped out for a small script. When Astro builds your site, it will omit the component and inject a script in its place, with fallback content will be visible for a short amount of time before the dynamic islands are then loaded.

This rendering pattern was built to be portable. It does not depend on any server infrastructure so it will work with any host you have, from a Node.js server in a Docker container, to the serverless provider of your choice.

### Benefits of server islands

The most obvious benefit of server islands is the ability to render the more highly dynamic parts of your page on the fly. This allows the outer shell and main content to be more aggressively cached, providing faster performance.

Another benefit is providing a great visitor experience. Server islands are optimized and load quickly. Before the browser has even painted the page it is able to start loading the islands in most cases. But in the short time it takes for your islands to render, you can display custom fallback content and prevent any layout shift.

An example of a site that benefits from Astro's server islands is an e-commerce storefront. Although the main content of product pages change infrequently, these pages typically have some dynamic pieces:

- The user's avatar in the heading.
- Special deals and sales for the product.
- User reviews.

Using server islands, each of those UI elements can be dynamically rendered without sacrificing the performance of the rest of the page. This means the user will see the most important part, your product, immediately. Generic avatars, loading spinners, and store announcements can be displayed as fallback content until the personalized parts are available.

**Server islands are Astro's secret to rendering performance, CWV, cacheability... will need Matthew's help here!**