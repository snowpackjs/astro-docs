---
title: 升级到 Astro v5
description: 如何将你的项目升级到 Astro v5.0。
sidebar:
  label: v5.0
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import { Steps } from '@astrojs/starlight/components';
import ReadMore from '~/components/ReadMore.astro'
import SourcePR from '~/components/SourcePR.astro'

本指南将帮助你从 Astro v4 迁移到 Astro v5。

需要将旧项目升级到 v4 吗？请参阅我们的 [旧版本迁移指南](/zh-cn/guides/upgrade-to/v4/))。

需要查阅 v4 的文档？请访问这个[旧版本文档站 (不被维护的 v4.16 快照)](https://v4.docs.astro.build/)。

## 升级 Astro

使用你的包管理器将项目的 Astro 和所有官方集成升级到最新版本。

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # 同时升级 Astro 和官方集成
  npx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # 同时升级 Astro 和官方集成
  pnpm dlx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # 同时升级 Astro 和官方集成
  yarn dlx @astrojs/upgrade
  ```
  </Fragment>
</PackageManagerTabs>

如果需要的话，你也可以 [手动升级 Astro 集成](/zh-cn/guides/integrations-guide/#手动更新)，你可能还需要升级项目中的其他依赖。

:::note[需要继续吗？]
升级 Astro 到最新版本后，你可能不需要对你的项目做任何更改！

但是，如果你注意到错误或意外的行为，请检查下面的内容，看看有什么变化可能需要在你的项目中更新。
:::

Astro v5.0 包含了一些 [潜在的破坏性变更](#破坏性更改)，以及对于功能的一些移除和弃用。

如果你的项目在升级到 v5.0 后的行为不符合预期，请参考本指南，了解所有破坏性更改的概述以及如何修改你的代码的说明。

完整的发行说明请参阅 [Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md)。

## 依赖升级

对 Astro 依赖项的任何重大升级都可能导致你的项目发生破坏性变更。

### Vite 6.0

Astro v5.0 已升级到将 Vite v6.0 作为开发服务器和生产打包工具。

#### 我应该做什么？

如果你正在使用 Vite 的插件、配置或 API，请查看 [Vite 迁移指南](https://cn.vite.dev/guide/migration) 中的破坏性更改，并根据需要升级你的项目。

### `@astrojs/mdx`

<SourcePR number="11741" title="Cleanup unused JSX code"/>

在 Astro v4.x 中，Astro 为 `@astrojs/mdx` 集成执行内部 JSX 处理。

Astro v5.0 将这一责任转移到直接处理和渲染 JSX 和 MDX 的 `@astrojs/mdx` 包中。这意味着 Astro 5.0 不再与旧版本的 MDX 集成兼容。

#### 我应该做什么？

如果你的项目中包含 `.mdx` 文件，那么你必须将 `@astrojs/mdx` 升级到最新版本（v4.0.0），以使得你的 JSX 文件可以被集成正确的处理。

如果你正在使用 MDX 服务器端渲染器的实验性功能 [Astro Container API](/zh-cn/reference/container-reference/)，那么你必须要更新导入语句来对应新的位置：

```ts del={1} ins={2}
import mdxRenderer from "astro/jsx/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";
```

<ReadMore>了解有关 [在项目中使用 MDX](/zh-cn/guides/integrations-guide/mdx/) 的更多信息。</ReadMore>

## 遗留

以下的功能现在被认为是遗留功能。它们应该可以正常运行，但不再推荐使用它们，并且它们处于维护模式。它们不会在未来得到改进，也不会更新文档。这些功能最终将被弃用，然后完全删除。

### 遗留：v2.0 内容集合 API

在 Astro 4.x 中，内容集合是使用 [Astro v2.0 中首次介绍的内容集合 API](https://astro.build/blog/introducing-content-collections/) 来实现定义、查询和渲染的。所有的集合条目都是被保存在 `src/content` 文件夹下的本地文件。此外，Astro 的 [排除构建单个页面的文件名约定](/zh-cn/guides/routing/#排除页面) 也内置于内容集合 API 中。

Astro 5.0 引入了一个采用 Content Layer API 的新版内容集合，它带来了多项性能提升和附加功能。虽然旧版本（遗留）和新版本（Content Layer API）的集合可以继续在当前的发布版本同时存在，但是可能仍会对现有的遗留集合产生潜在的破坏性变更。

该发布版本同时也移除了一个选项，该选项可以通过对集合条目文件前添加下划线（`_`）来防止构建路由。

#### 我应该做什么？

我们建议你尽快 [将任何现有集合转换成新的 Content Layer API](#升级现有的集合)，并使用 Content Layer API 来创建任何新集合。

如果你无法转换你的集合，请参考 [遗留集合破坏性变更](#对遗留的-content-和-data-集合的破坏性变更) 来查看你的现有集合是否被影响了或是需要升级。

如果你此时无法对你的集合做出任何改变，你可以 [启用 `legacy.collections` 标志](#启用-legacycollections-标志)，这会允许你在保持你的集合在他们现有的状态下不变，直到遗留标志不再被支持。

<ReadMore>了解有关更新后的 [内容集合](/zh-cn/guides/content-collections/) 的更多信息。</ReadMore>

##### 升级现有的集合

参阅下面的步骤来更新一个现有的内容集合（`type: 'content'` 或是 `type: 'data'`）以使用 Content Layer API。

<details>
<summary>更新一个集合的步骤说明</summary>

<Steps>

1. **移动内容配置文件**。该文件不再位于 `src/content/` 文件夹中。该文件现在位于 `src/content.config.ts`。

2. **编辑集合定义**。你的更新后的集合需要一个 `loader`，该 loader 同时指明了你集合所在的文件夹（`base`），和定义集合条目文件名和扩展名相匹配的 `pattern`。（你可能需要相应的匹配下面的示例。你可以使用 [globster.xyz](https://globster.xyz/) 来检查你的 glob 模式。）选择集合 `type` 的选项不再可用。

    ```ts ins={3,8} del={7}
    // src/content.config.ts
    import { defineCollection, z } from 'astro:content';
    import { glob } from 'astro/loaders';

    const blog = defineCollection({
      // 对于 content layer 来说，你不再需要定义一个 `type`
      type: 'content',
      loader: glob({ pattern: '**/[^_]*.{md,mdx}', base: "./src/data/blog" }),
      schema: z.object({
        title: z.string(),
        description: z.string(),
        pubDate: z.coerce.date(),
        updatedDate: z.coerce.date().optional(),
      }),
    });
    ```

3. **将引用的 `slug` 更改为 `id`**。Content layer 集合不再保留 `slug` 字段。相反的，所有更新后的集合将会有一个 `id`。你可能还需要更新动态路由的文件名，以匹配更新后的 getStaticPaths() 参数：

    ```astro ins={7} del={6}
    // src/pages/[id].astro
    ---
    export async function getStaticPaths() {
      const posts = await getCollection('blog');
      return posts.map((post) => ({
        params: { slug: post.slug },
        params: { id: post.id },
        props: post,
      }));
    }
    ---
    ```

4. **切换到新的 `render()` 函数**。条目不再具有 `render()` 方法，因为他们现在是可序列化的简单对象。相反的，应该从 `astro:content` 导入 `render()` 函数。

    ```astro title="src/pages/index.astro" ins=", render" del={6} ins={7}
    ---
    import { getEntry, render } from 'astro:content';

    const post = await getEntry('blog', params.slug);

    const { Content, headings } = await post.render();
    const { Content, headings } = await render(post);
    ---
    <Content />
    ```
</Steps>

</details>

##### 对遗留的 `content` 和 `data` 集合的破坏性变更

<SourcePR number="11976" title="Implement legacy collections using glob" />

默认情况下，使用旧的 `type` 属性的集合（可能是 `content` 或 `data`）且没有定义 `loader` 的集合现在都通过使用 Content Layer API 内置的 `glob()` loader（加载器）在后台实现了，并额外具有了向下兼容的处理。

另外，临时的向下兼容性还能用于将配置文件保留在其原来的位置，即 `src/content/config.ts`。

这种向下兼容的实现方式能够模拟大部分遗留集合的功能，并允许多数的遗留集合在不升级代码的前提下得以继续使用。但是，**仍然有一些差异和限制可能会使得现有的集合受到破坏性变更的影响**：

  - 在以往的 Astro 版本中，会为 `src/content/` 中所有的文件夹生成集合，即使它们没有在 `src/content/config.ts` 中被定义。此行为现已弃用，集合应始终在 `src/content.config.ts` 中被定义。对于现有的集合，定义可以是空声明（例如 `const blog = defineCollection({})`），并且 Astro 会以与新的加载行为兼容的方式隐式地为你定义遗留的集合。
  - Markdown 集合条目不支持特殊的 `layout` 字段。此属性仅适用于位于 `src/pages/` 中的独立页面文件，不太可能位于你的集合条目中。但是，如果你之前使用的是此属性，则现在必须创建包含页面样式的动态路由。
  - 生成的集合的排序顺序是不确定的，并且取决于平台。这意味着，如果你调用 `getCollection()`，现在返回条目的顺序可能与以前不同。如果需要特定顺序，则必须自己对集合条目进行排序。
  - `image().refine()` 已不被支持。现在如果你想要验证图像的属性，那么你可能需要在运行时于页面或组件中来实现。
  - `getEntry(collection, key)` 的参数 `key` 是 `string` 类型，而不是每个条目都有类型。
  - 以前，当使用静态字符串作为键来调用 `getEntry(collection, key)` 时，返回类型不可为空。现在类型包括了 `undefined`，因此你必须在使用结果之前检查条目是否已定义，否则将出现类型错误。

##### 启用 `legacy.collections` 标志

<SourcePR number="11976" title="Implement legacy collections using glob" />

如果你还没准备好去升级你的现有集合的话，你可以启用 [`legacy.collections`](/zh-cn/reference/legacy-flags/)，这样一来你的现有集合就能像之前一样继续使用。

## 弃用

以下弃用的功能已不再被支持，也不会再被文档记录。请相应地更新你的项目。

部分弃用的功能可能暂时地继续工作，直到它们被完全移除。其他的可能会默默地没有任何效果，或者抛出一个错误提示你更新你的代码。

### 弃用：`Astro.glob()`

<SourcePR number="11826" title="Deprecate glob"/>

在 Astro v4.x 中，你可以在 `.astro` 组件中使用 `Astro.glob()` 来查询项目中的多个文件。这有一些限制（在可以使用的地方、性能等），并且使用来自内容集合 API 或 Vite 自己的 `import.meta.glob()` 的查询函数通常会提供更多的功能和灵活性。

Astro 5.0 弃用了 `Astro.glob()` 转而使用 `getCollection()` 来查询你的集合，而用 `import.meta.glob()` 来查询项目中的其他源文件。

#### 我应该做什么？

将所有使用到 `Astro.glob()` 的地方替换为 `import.meta.glob()`。请注意，`import.meta.glob()` 不再返回 `Promise`，因此你可能必须相应地更新你的代码。你无需对 [glob 模式](/zh-cn/guides/imports/#glob-模式) 进行任何更新。

```astro title="src/pages/blog.astro" del={2} ins={3}
---
const posts = await Astro.glob('./posts/*.md');
const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));
---

{posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
```

在适当的情况下，请考虑使用 [内容集合](/zh-cn/guides/content-collections/) 来组织你的内容，这些内容具有独属于自己的，更新且性能更高的查询功能。

你可能还希望考虑使用 NPM 的 glob 包，例如 [`fast-glob`](https://www.npmjs.com/package/fast-glob)。

<ReadMore>了解有关 [使用 import.meta.glob 导入文件](/zh-cn/guides/imports/#importmetaglob) 的更多信息。</ReadMore>
 
### 弃用：`functionPerRoute`（适配器 API）

<SourcePR number="11714" title="Remove functionPerRoute option"/>

在 Astro v4.x 中，你可以选择性的为项目中定义的每个路由创建一个单独的文件，镜像构建文件夹中的 `src/pages/` 目录。默认情况下，Astro 输出一个 `entry.mjs` 文件，它负责在每个请求中输出渲染的页面。

Astro v5.0 移除了该默认行为中选择性的选项。此行为现​​在是标准且不可配置的。

从 `adapterFeatures` 配置中删除 `functionPerRoute` 属性。它不再可用。

```js title="my-adapter.mjs" del={10}
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}

```

<ReadMore>了解有关用于构建适配器集成的 [适配器 API](/zh-cn/guides/imports/#importmetaglob) 的更多信息。</ReadMore>

### 弃用：`astro:build:done` 钩子的 `routes` 选项（集成 API）

<SourcePR number="12329" title="feat(next): astro:routes:resolved"/>

在 Astro v4.x 中，集成都是从 `astro:build:done` 钩子来读取路由的。

Astro v5.0 弃用了传递给此钩子的 `routes` 数组。取而代之的是，它暴露了一个新的 `astro:routes:resolved` 钩子，它在 `astro:config:done` 之前运行，并且在开发过程中每当路由发生变化时运行。它具有与已经弃用的 `routes` 列表相同的所有属性，但 `distURL` 除外，它仅在构建期间可用。

#### 我应该做什么？

删除传递给 `astro:build:done` 的任何 `routes` 实例，并将其替换为新的 `astro:routes:resolved` 钩子。在新暴露的 `assets` 映射上读取 `distURL`：

```js title="my-integration.mjs" ins={2,6-8,11,13-18} del={10}
const integration = () => {
    let routes
    return {
        name: 'my-integration',
        hooks: {
            'astro:routes:resolved': (params) => {
                routes = params.routes
            },
            'astro:build:done': ({
                routes
                assets
            }) => {
                for (const route of routes) {
                    const distURL = assets.get(route.pattern)
                    if (distURL) {
                        Object.assign(route, { distURL })
                    }
                }
                console.log(routes)
            }
        }
    }
}
```

<ReadMore>了解有关用于构建集成的 [集成 API `astro:routes:resolved` 钩子](/zh-cn/reference/integrations-reference/#astroroutesresolved) 的更多信息。</ReadMore>

## 移除

以下功能现已从代码库中完全删除，无法再使用。其中一些功能即使在弃用后也可能继续在你的项目中工作。其他的可能默默地没有效果。

现在包含这些已删除功能的项目将无法构建，并且将不再有任何支持文档提示你删除这些功能。

### 移除：Lit 集成

<SourcePR number="11680" title="Remove `@astrojs/lit`"/>

在 Astro v4.x 中，[Lit](https://lit.dev/) 是通过 `@astrojs/lit` 包实现的核心维护框架库。

Astro v5.0 移除了该集成，并且它也不会收到与 5.x 及更高版本兼容的进一步更新。

#### 我应该做什么？

你可以通过添加客户端脚本标签来继续将 Lit 用于客户端组件。例如：

```astro
<script>
  import "../components/MyTabs";
</script>

<my-tabs title="These are my tabs">...</my-tabs>
```

如果你有兴趣自己维护 Lit 集成，你可能希望使用 [`@astrojs/lit` 最新发布的版本](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit) 作为起点并升级相关的包。

<ReadMore>了解更多关于 [Astro 的官方集成](/zh-cn/guides/integrations-guide/)。</ReadMore>

### `hybrid` 渲染模式

<SourcePR number="11824" title="Merge output:hybrid and output:static" />

在 Astro v4.x 中，Astro 提供了三种 `output` 渲染模式：`'static'`、`'hybrid'` 和 `'server'`。

Astro v5.0 将 `output: 'hybrid'` 与 `output: 'static'` 这两种配置项合并成了一种配置项（现在叫做 `'static'`），其工作方式与之前的 `hybrid` 选项相同。

现在不再需要在 Astro 配置中指定 `output: 'hybrid'` 来使用服务器渲染的页面。新的 `output: 'static'` 已经包含了此功能。

Astro 现在将自动允许你选择退出静态站点中的预渲染，而无需更改输出配置。任何页面路由或端点都可以包含 `export const prerender = false` 以实现服务器端的按需渲染，而你网站的其余部分则是静态生成的。

#### 我应该做什么？

如果你的项目之前使用了混合（hybrid）渲染，你现在必须从 Astro 配置中删除 `output: 'hybrid'` 选项，因为它已经不存在了。但是，不需要对项目进行其他更改，也无需做破坏性变更。只不过以前的 `'hybrid'` 行为现在是默认行为，新名称为 `'static'`。

```js title="astro.config.mjs" del={4}
import { defineConfig } from "astro/config";

export default defineConfig({
  output: 'hybrid',
});
```

如果你之前用的是 `output: 'static'`（默认）选项，你可以像以前一样继续使用它。默认情况下，你的所有页面都将继续被预渲染，你将拥有一个完全静态的网站。你的项目无需破坏性变更。

无论你的项目使用哪种 `output` 模式，部署包含任何服务器渲染页面的 Astro 项目仍然需要一个适配器。如果不包含适配器，则会导致开发过程中出现警告，并在构建时出现错误。

<ReadMore>了解更多关于 [Astro 中的按需渲染](/zh-cn/guides/on-demand-rendering/)。</ReadMore>

### 移除：Squoosh 图像服务

<SourcePR number="11770" title="remove the squoosh image service"/>

在 Astro 4.x 中，你可以配置 `image.service: squooshImageService()` 以使用 Squoosh 来代替 Sharp 转换你的图像。但是，底层库 `libsquoosh` 不再维护，并且存在内存和性能问题。

Astro 5.0 已将 Squoosh 图像优化服务完全移除。

#### 我应该做什么？

要切换到内置的 Sharp 图像服务，请从 Astro 配置中删除对 `squooshImageService` 的导入。默认情况下，你将对 `astro:assets` 使用 Sharp。

```ts title="astro.config.mjs" del={1, 5-7}
import { squooshImageService } from "astro/config";
import { defineConfig } from "astro/config";

export default defineConfig({
 image: {
   service: squooshImageService()
 }
});
```

如果你正在使用像 `pnpm` 这样的严格包管理器，你可能需要手动安装 `sharp` 包才能使用 Sharp 图像服务，即使它默认内置在 Astro 中。

如果你的适配器不支持 Astro 内置的 Sharp 图像优化，你可以 [配置一个不进行优化的图像服务](/zh-cn/guides/images/#配置-no-op-透传服务) 来允许你使用 `<Image />` 和 `<Picture />` 组件。

或者，如果你无法使用 Sharp 图像服务，你可能会去考虑使用 [社区维护的 Squoosh 图像服务](https://github.com/Princesseuh/astro-image-service-squoosh)。

##### 针对适配器

如果你的适配器之前确认过它与 Squoosh 的兼容性状态，则现在应从适配器配置中删除此信息。

```js title="my-adapter.mjs" del={2-4}
supportedAstroFeatures: {
  assets: {
    isSquooshCompatible: true
  }
}
```

<ReadMore>阅读有关 [配置默认图像服务](/zh-cn/guides/images/#默认图像服务) 的详细信息。</ReadMore>

### 移除：一些公有类型

<SourcePR number="11715" title="Refactor/types"/>

在 Astro v4.x 中，`@types/astro.ts` 向用户公共地暴露了所有类型，无论它们是否仍在积极使用或仅供内部使用。

Astro v5.0 重构了此文件以删除过时的内部类型。此重构将为你的编辑器带来改进（例如，更快的完成速度、更低的内存使用和更相关的完成选项）。但是，此重构可能会导致某些项目出现错误，这些项目一直依赖于不再公有的类型。

#### 我应该做什么？

移除现在导致项目出错的任何类型的信息，因为你无法再读取到它们。这些 API 大多是以前已弃用和移除的 API，但也可能包括现在属于内部的类型。

<ReadMore>请参阅 [暴露以供使用的公有类型](https://github.com/withastro/astro/tree/main/packages/astro/src/types/public)。</ReadMore>

### 实验性标志

以下实验性标志已在 Astro v5.0 中移除，这些功能可供使用：

- `env`
- `serverIslands`

此外，以下实验性标志已被移除，**现在它们是 Astro v5.0 中的默认或推荐行为**。

- `directRenderScript`（有关对 [默认 `<script>` 行为](#script-标签将按照声明直接渲染) 的破坏性变更，请参阅下文。）
- `globalRoutePriority`（有关对 [默认的路由优先级顺序](#对于注入路由和重定向的路由优先级顺序) 的破坏性变更，请参阅下文。）
- `contentLayer`（请参阅 [将现有内容集合升级](#遗留-v20-内容集合-API) 到新的首选 Content Layer API 的指南。）

以下实验标志已被删除，**它们相应的功能不属于 Astro v5.0 的一部分**。

- `contentCollectionsCache`

如果你之前使用过这些实验性标志，请删除它们，并将你的 `env` 配置移至 Astro 配置的根目录：

```js del={5-12} ins={14-16} title="astro.config.mjs"
import { defineConfig } from 'astro/config';

export default defineConfig({
  experimental: {
    directRenderScript: true,
    globalRoutePriority: true,
    contentLayer: true,
    serverIslands: true,
    contentCollectionsCache: true,
    env: {
      schema: {...}
    }
  },
  env: {
      schema: {...}
  }
})
```

这些功能在 Astro v5.0 中默认可用。

<ReadMore>请阅读 [v5.0 博客文章](https://astro.build/blog/astro-5/)，了解这些激动人心的功能及更多信息。</ReadMore>

## 默认值变更

Astro v5.0 中的一些默认行为已更改，你的项目代码可能需要更新以适应这些更改。

在大多数情况下，唯一需要的操作是审查现有项目的部署并确保它继续按你的预期运行，然后根据需要更新代码。而在某些情况下，可能会有一个配置允许你继续使用以前的默认行为。

### CSRF 保护现已默认开启

<SourcePR number="11788" title="change default value of checkOrigin"/>

在 Astro v4.x 中，`security.checkOrigin` 的默认值为 `false`。以前，你必须显式将此值设置为 `true` 才能启用跨站点请求伪造（CSRF）保护。

Astro v5.0 将此选项的默认值更改为 `true`，并将自动检查 "origin" 标头是否与按需渲染页面中每个请求发送的 URL 匹配。

#### 我应该做什么？

如果你之前配置过 `security.checkOrigin: true`，则 Astro 配置中不再需要此行。现在这是默认值。

要禁用此行为，你必须显式设置 `security.checkOrigin: false`。

```js title="astro.config.mjs" ins={3-5}
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: false
  }
})
```

<ReadMore>阅读有关 [安全配置选项](/zh-cn/reference/configuration-reference/#security) 的更多信息。</ReadMore>

### 对于注入路由和重定向的路由优先级顺序

<SourcePR number="11798" title="Remove legacy route prioritization"/>

在 Astro v4.x 中，`experimental.globalRoutePriority` 是一个可选标志，它用于确保 [对所有路由使用优先级顺序规则](/zh-cn/guides/routing/#路由优先级顺序)，如注入路由、基于文件的路由和重定向。通过非自动的方法，来确定某些类型的路由的优先级并标准化路由优先级顺序，这可以更好地控制项目中的路由。

Astro v5.0 删除了这个实验性标志，并使其成为 Astro 中新的默认行为：重定向和注入路由现在与基于文件的项目路由同等优先。

请注意，这已经是 Starlight 中的默认行为，并且不应影响更新过的 Starlight 项目。

#### 我应该做什么？

如果你的项目包含注入路由或重定向，请检查你的路由是否按预期构建页面 URL。下面显示了新的预期行为的示例。

在包含以下路由的项目中：

- 基于文件的路由：`/blog/post/[pid]`
- 基于文件的路由：`/[page]`
- 注入路由：`/blog/[...slug]`
- 重定向：`/blog/tags/[tag] -> /[tag]`
- 重定向：`/posts -> /blog`

将构建以下 URL（而不是遵循 Astro v4.x 的路由优先级顺序）：

- `/blog/tags/astro` 是通过重定向到 `/tags/[tag]` 构建的（而不是注入的路由 `/blog/[...slug]`）
- `/blog/post/0` 由基于文件的路由 `/blog/post/[pid]` 构建（而不是注入的路由 `/blog/[...slug]`）
- `/posts` 是通过重定向到 `/blog` 构建的（而不是基于文件的路由 `/[page]`）

如果发生路由冲突的情况，即两条路由优先级相同的路由尝试构建相同的 URL，Astro 将记录一条警告，来标识冲突的路由。

<ReadMore>详细了解 [路由优先顺序规则](/zh-cn/guides/routing/#路由优先级顺序)。</ReadMore>

### `<script>` 标签将按照声明直接渲染

<SourcePR number="11791" title="Make directRenderScript the default"/>

在 Astro v4.x 中，`experimental.directRenderScript` 是一个可选标志，用于直接渲染 `.astro` 文件中声明的 `<scripts>`（包括 TypeScript、导入 `node_modules` 和去重脚本等现有功能）。此策略可防止脚本在未使用的地方执行。

Astro 5.0 删除了这个实验性标志，并使其成为 Astro 中新的默认行为：脚本不再被提升到 `<head>`，页面上的多个脚本也不再被一起打包，并且 `<script>` 标签可能会干扰 CSS 样式。

#### 我应该做什么？

请检查你的 `<script>` 标签并确保它们的行为符合预期。

<ReadMore>详细了解 [在 Astro 中使用 `script` 标签](/zh-cn/guides/client-side-scripts/#在-astro-中使用-script)。</ReadMore>

## 破坏性变更

下面的这些变更被认为是 Astro v5.0 中的破坏性变更。破坏性变更可能会提供临时的向下兼容，也有可能不会。如果你正在使用这些功能，你可能必须按照每个条目中的建议来更新你的代码。

{/* 如果你需要参考 v4.x 项目的文档，你可以浏览此 [v5.0 发布之前的文档的（未维护）快照](https://docs-git-v3-docs-unmaintained-astrodotbuild.vercel.app/)。 */}

### 重命名：`<ViewTransitions />` 组件

<SourcePR number="11980" title="Rename the ViewTransitions component to ClientRouter"/>

在 Astro 4.x 中，Astro 的视图过渡 API 包含了一个 `<ViewTransitions />` 路由器组件，用于启用客户端路由、页面转换等。

Astro 5.0 将此组件重命名为 `<ClientRouter />`，以明确该组件在 API 中充当的角色。这更清楚地表明，你从 Astro 的 `<ClientRouter />` 路由组件获得的功能与原生的、基于 CSS 的 MPA 路由器略有不同。

功能没有改变。该组件仅更改了名称。

#### 我应该做什么？

将所有出现的 `ViewTransitions` 导入语句和组件替换为 `ClientRouter`：

```astro title="src/layouts/MyLayout.astro" del={1,7} ins={2,8}
import { ViewTransitions } from 'astro:transitions';
import { ClientRouter } from 'astro:transitions';

<html>
  <head>
    ...
   <ViewTransitions />
   <ClientRouter />
  </head>
</html>
```

<ReadMore>阅读有关 [Astro 中的视图转换和客户端路由](/zh-cn/guides/view-transitions/) 的更多信息。</ReadMore>

### 改动：TypeScript 配置

<SourcePR number="11859" title="better tsconfig"/>

在 Astro v4.x 中，Astro 依赖 `src/env.d.ts` 文件进行类型推断并为依赖于生成类型的功能定义模块。

Astro 5.0 使用 `.astro/types.d.ts` 文件进行类型推断，现在更建议在 `tsconfig.json` 中设置 `include` 和 `exclude`，以从 Astro 类型中受益并避免检查构建文件。

运行 `astrosync` 不再创建或更新 `src/env.d.ts`，因为标准 Astro 项目的类型检查不需要它。

#### 我应该做什么？

要将你的项目更新为 Astro 推荐的 TypeScript 设置，请将以下 `include` 和 `exclude` 属性添加到现有的 `tsconfig.json` 中：

```ts ins={3,4} title="tsconfig.json"
{
  "extends": "astro/tsconfigs/base",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}
```

请注意，仅当你添加了自定义配置，或者不使用 `tsconfig.json` 文件时，才需要 `src/env.d.ts`。

<ReadMore>详细了解 [Astro 中的 TypeScript 配置](/zh-cn/guides/typescript/#设置)。</ReadMore>

### 改动：HTML 表单提交的 action 不再使用 cookie 重定向

<SourcePR number="12373" title="Actions middleware"/>

在 Astro 4.x 中，从 HTML 表单调用的 action 将触发重定向，并使用 cookie 来转发结果。这会导致出现大量的表单错误和返回值超出基于 cookie 存储的 4 KB 限制的问题。

Astro 5.0 现在将 action 的结果渲染为 POST 结果，而无需任何转发。当用户尝试刷新页面时，会弹出对话框提示 "confirm form resubmission?（确认重新提交表单？）"，但它不再对 action 的返回值施加 4 KB 的限制。

#### 我应该做什么？

You should update handling for action results that relies on redirects, and optionally address the "confirm form resubmission?" dialog with middleware.
你应该更新对依赖重定向的 action 结果的处理，并且可以选择用中间件来解决 "确认重新提交表单？" 的问题。

##### 出错时重定向到上一个路由

如果你的 HTML 表单 action 定向到不同的路由（即 `action={"/success-page" + actions.name}`），Astro 将不再在出错时重定向到上一个路由。你可以使用 Astro 组件的重定向来手动实现此行为。相反，此示例在成功时会重定向到新路由，否则处理当前页面上的错误：

```astro title="src/pages/newsletter.astro" ins={4-9} del="'/confirmation' + "
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.newsletter);
if (!result?.error) {
  // 如果需要，在 URL 中嵌入相关结果数据
  // 示例：redirect(`/confirmation?email=${result.data.email}`);
  return redirect('/confirmation');
}
---

<form method="POST" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type="email" name="email" /></label>
  <button>Sign up</button>
</form>
```

##### （可选）删除刷新时的确认对话框

要解决在刷新时弹出的 "确认重新提交表单？" 的对话框，或者为了实现跨会话保留 action 的结果，你现在可以从中间件 [自定义 action 结果处理](/zh-cn/guides/actions/#高级通过-session-持久化-action-结果)。

我们建议使用会话存储（session storage）的方式，[就如 Netlify Blob 示例中所述](/zh-cn/guides/actions/#高级通过-session-持久化-action-结果)。但是，如果你更喜欢 4.X 中的 cookie 转发行为并接受 4 KB 大小限制，则可以实现此示例片段中所示的模式：

```ts title="src/middleware.ts"
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  // 跳过预渲染页面的请求
  if (context.isPrerendered) return next();

	const { action, setActionResult, serializeActionResult } = getActionContext(context);

	// 如果 action 结果作为 cookie 转发，则设置结果
	// 可以从 `Astro.getActionResult()` 访问
	const payload = context.cookies.get('ACTION_PAYLOAD');
	if (payload) {
		const { actionName, actionResult } = payload.json();
		setActionResult(actionName, actionResult);
		context.cookies.delete('ACTION_PAYLOAD');
		return next();
	}

	// 如果从 HTML 表单 action 调用操作，
	// 则调用 action handler 并用 cookie 作为结果进行重定向。
	if (action?.calledFrom === 'form') {
		const actionResult = await action.handler();

		context.cookies.set('ACTION_PAYLOAD', {
			actionName: action.name,
			actionResult: serializeActionResult(actionResult),
		});

		if (actionResult.error) {
		// 出错时重定向回上一页
			const referer = context.request.headers.get('Referer');
			if (!referer) {
				throw new Error('Internal: Referer unexpectedly missing from Action POST request.');
			}
			return context.redirect(referer);
		}
		// 成功则跳转至目标页面
		return context.redirect(context.originPathname);
	}

	return next();
})
```

### 改动：`compiledContent()` 现在是一个异步函数

<SourcePR number="11782" title="Remove TLA by making compiledContent async"/>

在 Astro 4.x 中，顶层 await 包含在 Markdown 模块中。这导致 Markdown 中的自定义图像服务和图像出现一些问题，导致 Node 在没有错误信息的情况下突然退出。

Astro 5.0 使 Markdown 上的 `compiledContent()` 属性导入了一个异步函数，它需要 `await` 来解析内容。

#### 我应该做什么？

更新你的代码以在调用 `compiledContent()` 时，使用 `await`。

```astro title="src/pages/post.astro" del={4} ins={5}
---
import * as myPost from "../blog/post.md";

const content = myPost.compiledContent();
const content = await myPost.compiledContent();
---

<Fragment set:html={content} />
```

<ReadMore>阅读有关用于返回编译后的 Markdown 的 [`compiledContent()` 函数](/zh-cn/guides/markdown-content/#导入-markdown)的更多信息。</ReadMore>

### Changed: `astro:content` can no longer be used on the client

<SourcePR number="11827" title="Prevent usage of `astro:content` in the client "/>

In Astro 4.x, it was possible to access the `astro:content` module on the client.

Astro 5.0 removes this access as it was never intentionally exposed for client use. Using `astro:content` this way had limitations and bloated client bundles.

#### What should I do?

If you are currently using `astro:content` in the client, pass the data you need through props to your client components instead:

```astro title="src/pages/blog.astro"
---
import { getCollection } from 'astro:content';
import ClientComponent from '../components/ClientComponent';

const posts = await getCollection('blog');
const postsData = posts.map(post => post.data);
---

<ClientComponent posts={postsData} />
```

<ReadMore>Read more about [the `astro:content` API](/en/reference/modules/astro-content/).</ReadMore>

### Renamed: Shiki `css-variables` theme color token names

<SourcePR number="11661" title="Update to new shiki token names"/>

In Astro v4.x, the Shiki `css-variables` theme used the `--astro-code-color-text` and `--astro-code-color-background` tokens for styling the foreground and background colors of code blocks respectively.

Astro v5.0 renames them to `--astro-code-foreground` and `--astro-code-background` respectively to better align with the Shiki v1 defaults.

#### What should I do?

You can perform a global find and replace in your project to migrate to the new token names.

```css title="src/styles/global.css" del={2,3} ins={4,5}
:root {
  --astro-code-color-text: #000;
  --astro-code-color-background: #fff;
  --astro-code-foreground: #000;
  --astro-code-background: #fff;
}
```

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: internal Shiki rehype plugin for highlighting code blocks

<SourcePR number="11825" title="Refactor createShikiHighlighter"/>

In Astro 4.x, Astro's internal Shiki rehype plugin highlighted code blocks as HTML.

Astro 5.0 updates this plugin to highlight code blocks as hast. This allows a more direct Markdown and MDX processing and improves the performance when building the project. However, this may cause issues with existing Shiki transformers.

#### What should I do?

If you are using Shiki transformers passed to `markdown.shikiConfig.transformers`, you must make sure they do not use the `postprocess` hook. This hook no longer runs on code blocks in `.md` and `.mdx` files. (See [the Shiki documentation on transformer hooks](https://shiki.style/guide/transformers#transformer-hooks) for more information).

Code blocks in `.mdoc` files and Astro's built-in `<Code />` component do not use the internal Shiki rehype plugin and are unaffected.

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: Automatic `charset=utf-8` behavior for Markdown and MDX pages

<SourcePR number="12231" title="Unset charset=utf-8 content-type for md/mdx pages"/>

In Astro 4.0, Markdown and MDX pages (located in `src/pages/`) automatically responded with `charset=utf-8` in the `Content-Type` header, which allowed rendering non-ASCII characters in your pages.

Astro 5.0 updates the behaviour to add the `<meta charset="utf-8">` tag instead, and only for pages that do not use Astro's special `layout` frontmatter property. Similarly for MDX pages, Astro will only add the tag if the MDX content does not import a wrapping `Layout` component.

If your Markdown or MDX pages use the `layout` frontmatter property, or if the MDX page content imports a wrapping `Layout` component, then the HTML encoding will be handled by the designated layout component instead, and the `<meta charset="utf-8">` tag will not be added to your page by default.

#### What should I do?

If you require `charset=utf-8` to render your page correctly, make sure that your layout components contain the `<meta charset="utf-8">` tag. You may need to add this if you have not already done so.

<ReadMore>Read more about [Markdown layouts](/en/basics/layouts/#markdown-layouts).</ReadMore>

### Changed: Astro-specific metadata attached in remark and rehype plugins

<SourcePR number="11861" title="Clean up Astro metadata in vfile.data"/>

In Astro 4.x, the Astro-specific metadata attached to `vfile.data` in remark and rehype plugins was attached in different locations with inconsistent names.

Astro 5 cleans up the API and the metadata is now renamed as below:

 - `vfile.data.__astroHeadings` -> `vfile.data.astro.headings`
 - `vfile.data.imagePaths` -> `vfile.data.astro.imagePaths`

The types of `imagePaths` has also been updated from `Set<string>` to `string[]`. The `vfile.data.astro.frontmatter` metadata is left unchanged.

#### What should I do?

While we don't consider these APIs public, they can be accessed by remark and rehype plugins that want to re-use Astro's metadata. If you are using these APIs, make sure to access them in the new locations.

<ReadMore>Read more about [using Markdown plugins in Astro](/en/guides/markdown-content/#markdown-plugins).</ReadMore>

### Changed: image endpoint configuration

<SourcePR number="11908" title="Allow customising the route of the image endpoint"/>

In Astro 4.x, you could set an endpoint in your `image` configuration to use for image optimization.

Astro 5.0 allows you to customize a `route` and `entrypoint` of the `image.endpoint` config. This can be useful in niche situations where the default route `/_image` conflicts with an existing route or your local server setup.

#### What should I do?

If you had previously customized `image.endpoint`, move this endpoint to the new `endpoint.entrypoint` property. Optionally, you may customize a `route`:

```js title="astro.config.mjs" del={5} ins={6-9}
import { defineConfig } from "astro/config";

defineConfig({
  image: {
    endpoint: './src/image-endpoint.ts',
    endpoint: {
      route: "/image",
      entrypoint: "./src/image_endpoint.ts"
    }
  },
})
```

<ReadMore>Read more about [setting an endpoint to use for image optimization](/en/reference/configuration-reference/#imageendpoint).</ReadMore>

### Changed: `build.client` and `build.server` resolve behavior

<SourcePR number="11916" title="Fix build.client and build.server resolve behaviour" />

In Astro v4.x, the `build.client` and `build.server` options were documented to resolve relatively from the `outDir` option, but it didn't always work as expected.

Astro 5.0 fixes the behavior to correctly resolve from the `outDir` option. For example, if `outDir` is set to `./dist/nested/`, then by default:

- `build.client` will resolve to `<root>/dist/nested/client/`
- `build.server` will resolve to `<root>/dist/nested/server/`

Previously the values were incorrectly resolved:

- `build.client` was resolved to `<root>/dist/nested/dist/client/`
- `build.server` was resolved to `<root>/dist/nested/dist/server/`

#### What should I do?

If you were relying on the previous build paths, make sure that your project code is updated to the new build paths.

<ReadMore>Read more about [`build` configuration options in Astro](/en/reference/configuration-reference/#build-options).</ReadMore>

### Changed: JS dependencies in config file are no longer processed by Vite

<SourcePR number="11819" title="Set external: true when loading astro config"/>

In Astro 4.x, locally-linked JS dependencies (e.g. `npm link`, in a monorepo, etc) were able to use Vite features like `import.meta.glob` when imported by the Astro config file.

Astro 5 updates the Astro config loading flow to ignore processing locally-linked JS dependencies with Vite. Dependencies exporting raw TypeScript files are unaffected. Instead, these JS dependencies will be normally imported by the Node.js runtime the same way as other dependencies from `node_modules`.

This change was made as the previous behavior caused confusion among integration authors who tested against a package that worked locally, but not when published. It also restricted using CJS-only dependencies because Vite required the code to be ESM. While this change only affects JS dependencies, it's also recommended for packages to export JavaScript instead of raw TypeScript where possible to prevent accidental Vite-specific usage as it's an implementation detail of Astro's config loading flow.

#### What should I do?

Make sure your locally-linked JS dependencies are built before running your Astro project. Then, the config loading should work as before.

<ReadMore>Read more about [Vite configuration settings in Astro](/en/reference/configuration-reference/#vite).</ReadMore>

### Changed: URLs returned by `paginate()`

<SourcePR number="11253" title="Add base to paginate"/>

In Astro v4.x, the URL returned by `paginate()` (e.g. `page.url.next`, `page.url.first`, etc.) did not include the value set for `base` in your Astro config. You had to manually prepend your configured value for `base` to the URL path.

Astro 5.0 automatically includes the `base` value in `page.url`.

#### What should I do?

If you are using the `paginate()` function for these URLs, remove any existing `base` value as it is now added for you:

```astro del={16} ins={17}
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  return paginate(astronautPages, { pageSize: 1 });
}
const { page } = Astro.props;
// `base: /'docs'` configured in `astro.config.mjs`
const prev = "/docs" + page.url.prev;
const prev = page.url.prev;
---
<a id="prev" href={prev}>Back</a>
```

<ReadMore>Read more about [pagination in Astro](/en/guides/routing/#pagination).</ReadMore>

### Changed: non-boolean HTML attribute values

<SourcePR number="11660" title="Fix attribute rendering for boolean values (take 2)"/>

In Astro v4.x, non-[boolean HTML attributes](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML) may not have included their values when rendered to HTML.

Astro v5.0 renders the values explicitly as `="true"` or `="false"`, matching proper attribute handling in browsers.

In the following `.astro` examples, only `allowfullscreen` is a boolean attribute:

```astro
<!-- src/pages/index.astro -->
<!-- `allowfullscreen` is a boolean attribute -->
<p allowfullscreen={true}></p>
<p allowfullscreen={false}></p>
<!-- `inherit` is *not* a boolean attribute -->
<p inherit={true}></p>
<p inherit={false}></p>
<!-- `data-*` attributes are not boolean attributes -->
<p data-light={true}></p>
<p data-light={false}></p>
```

Astro v5.0 now preserves the full data attribute with its value when rendering the HTML of non-boolean attributes:

```astro del={5,8,10} ins={6,9,11}
<p allowfullscreen></p>
<p></p>

<p inherit="true"></p>
<p inherit></p>
<p inherit="false"></p>

<p data-light></p>
<p data-light="true"></p>
<p></p>
<p data-light="false"></p>
```

#### What should I do?

If you rely on attribute values, for example, to locate elements or to conditionally render, update your code to match the new non-boolean attribute values:

```js del={1,4} ins={2,5}
el.getAttribute('inherit') === ''
el.getAttribute('inherit') === 'false'

el.hasAttribute('data-light')
el.dataset.light === 'true'
```

<ReadMore>Read more about [using HTML attributes in Astro](/en/reference/astro-syntax/#dynamic-attributes).</ReadMore>

### Changed: adding values to `context.locals`

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, it was possible to completely replace the entire `locals` object in middleware, API endpoints, and pages when adding new values.

Astro 5.0 requires you to append values to the existing `locals` object without deleting it. Locals in middleware, API endpoints, and pages, can no longer be completely overridden.

#### What should I do?

Where you previously were overwriting the object, you must now instead assign values to it:

```js title="src/middleware.js" del={1,5} ins={2,6}
ctx.locals = {
Object.assign(ctx.locals, {
  one: 1,
  two: 2
}
})
```

<ReadMore>See more about [storing data in `context.locals`](/en/guides/middleware/#storing-data-in-contextlocals).</ReadMore>

### Changed: `params` no longer decoded

<SourcePR number="12079" title="decode pathname early, don't decode params"/>

In Astro v4.x, `params` passed to `getStaticPath()` were automatically decoded using `decodeURIComponent`.

Astro v5.0 no longer decodes the value of `params` passed to `getStaticPaths`. You must manually decode them yourself if needed.

#### What should I do?

If you were previously relying on the automatic decoding, use `decodeURI` when passing `params`.


```astro title="src/pages/[id].astro" del={4} ins={5}
---
export function getStaticPaths() {
  return [
    { params: { id: "%5Bpage%5D" } },
    { params: { id: decodeURI("%5Bpage%5D") } },
  ]
}

const { id } = Astro.params;
---
```

Note that the use of [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) is discouraged for `getStaticPaths` because it decodes more characters than it should, for example `/`, `?`, `#` and more.

<ReadMore>Read more about [creating dynamic routes with `params`](/en/guides/routing/#static-ssg-mode).</ReadMore>

### Changed: `RouteData` type replaced by `IntegrationsRouteData` (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, the `entryPoints` type inside the `astro:build:ssr` and `astro:build:done` hooks was `RouteData`.

Astro v5.0 the `entryPoints` type is now `IntegrationRouteData`, which contains a subset of the `RouteData` type. The fields `isIndex` and `fallbackRoutes` were removed.

#### What should I do?

Update your adapter to change the type of `entryPoints` from `RouteData` to `IntegrationRouteData`.

```js del={1,4} ins={2,5}
import type {RouteData} from 'astro';
import type {IntegrationRouteData} from "astro"

function useRoute(route: RouteData) {
function useRoute(route: IntegrationRouteData) {
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: `distURL` is now an array (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, `RouteData.distURL` was `undefined` or a `URL`.

Astro v5.0 updates the shape of `IntegrationRouteData.distURL` to be `undefined` or an array of `URL`s. This fixes a previous error because a route can generate multiple files on disk, especially when using dynamic routes such as `[slug]` or `[...slug]`.

#### What should I do?

Update your code to handle `IntegrationRouteData.distURL` as an array.

```js del={2-4} ins={5-9}
if (route.distURL) {
  if (route.distURL.endsWith('index.html')) {
    // do something
  }
  for (const url of route.distURL) {
    if (url.endsWith('index.html')) {
      // do something
    }
  }
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: Arguments passed to `app.render()` (Adapter API)

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, The Adapter API method `app.render()` could receive three arguments: a mandatory `request`, an object of options or a `routeData` object, and `locals`.

Astro 5.0 combines these last two arguments into a single options argument named `renderOptions`.

#### What should I do?

Pass an object as the second argument to `app.render()`, which can include `routeData` and `locals` as properties.

```js del={1} ins={2}
const response = await app.render(request, routeData, locals);
const response = await app.render(request, {routeData, locals});
```

<ReadMore>See the [Adapter API reference for `renderOptions`](/en/reference/adapter-reference/#renderoptions).</ReadMore>

### Changed: Properties on `supportedAstroFeatures` (Adapter API)

<SourcePR number="11806" title="rework supportedAstroFeatures"/>

In Astro 4.x, `supportedAstroFeatures`, which allows adapter authors to specify which features their integration supports, included an `assets` property to specify which of Astro's image services were supported.

Astro 5.0 replaces this property with a dedicated `sharpImageService` property, used to determine whether the adapter is compatible with the built-in sharp image service.

v5.0 also adds a new `limited` value for the different properties of `supportedAstroFeatures` for adapters, which indicates that the adapter is compatible with the feature, but with some limitations. This is useful for adapters that support a feature, but not in all cases or with all options.

Additionally, the value of the different properties on `supportedAstroFeatures` for adapters can now be objects, with `support` and `message` properties. The content of the `message` property will show a helpful message in the Astro CLI when the adapter is not compatible with a feature. This is notably useful with the new `limited` value, to explain to the user why support is limited.

#### What should I do?

If you were using the `assets` property, remove this as it is no longer available. To specify that your adapter supports the built-in sharp image service, replace this with `sharpImageService`.

You may also wish to update your supported features with the new `limited` option and include a message about your adapter's support.

```ts title="my-adapter.mjs" del={2-6} ins={7-10}
supportedAstroFeatures: {
  assets: {
    supportKind: "stable",
    isSharpCompatible: true,
    isSquooshCompatible: true,
  },
  sharpImageService: {
    support: "limited",
    message: 'This adapter supports the built-in sharp image service, but with some limitations.'
  }
}
```

<ReadMore>Read more about [specifying supported Astro features in an adapter](/en/reference/adapter-reference/#astro-features).</ReadMore>

### Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)

<SourcePR number="11987" title="Remove deprecated dev toolbar app shape"/>

In Astro 4.x, when building a dev toolbar app, it was still possible to use the previously deprecated `addDevToolbarApp(string);` signature. The `id`, `title`, and `icon` properties to define the app were then made available through the default export of the app's `entrypoint`.

Astro 5.0 completely removes this option entirely in favor of the current object shape when defining a dev toolbar app in an integration that's more intuitive and allows Astro to provide better errors when toolbar apps fail to load correctly.

#### What should I do?

If you were using the deprecated shape, update your dev toolbar app to use the new shape:

```js title="my-integration.mjs" del={1-2} ins={4-10}
// Old shape
addDevToolbarApp("./my-app.js");

// New shape
addDevToolbarApp({
  id: "my-app",
  name: "My App",
  icon: "<svg>...</svg>",
  entrypoint: "./my-app.js",
});
```

```js title="my-dev-toolbar-app.mjs" del={2-4}
export default {
  id: 'my-dev-toolbar-app',
  title: 'My Dev Toolbar App',
  icon: '🚀',
  init() {
    // ...
  }
}
```

<ReadMore>Read more about [developing a dev toolbar app for Astro using the Dev Toolbar API](/en/reference/dev-toolbar-app-reference/).</ReadMore>

### Removed: configuring Typescript during `create-astro`

<SourcePR number="12083" title="create-astro updates"/>

In Astro v4.x, it was possible to choose between Astro's three TypeScript settings when creating a new project using `create astro`, either by answering a question or by passing an associated `--typescript` flag with the desired TypeScript setting. 

Astro 5.0 updates the `create astro` CLI command to remove the TypeScript question and its associated `--typescript` flag. The "strict" preset is now the default for all new projects created with the command line and it is no longer possible to customize this at that time. However, the TypeScript template can still be changed manually in `tsconfig.json`.

#### What should I do?

If you were using the `--typescript` flag with `create-astro`, remove it from your command.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```diff lang=shell
  -npm create astro@latest -- --template <example-name> --typescript strict
  +npm create astro@latest -- --template <example-name>
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```diff lang=shell
  -pnpm create astro@latest --template <example-name> --typescript strict
  +pnpm create astro@latest --template <example-name>
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```diff lang=shell
  -yarn create astro --template <example-name> --typescript strict
  +yarn create astro --template <example-name>
  ```
  </Fragment>
</PackageManagerTabs>

<ReadMore>See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md)</ReadMore>

## Community Resources

Know a good resource for Astro v5.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v5.mdx) and add a link below!

## Known Issues

Please check [Astro's issues on GitHub](https://github.com/withastro/astro/issues/) for any reported issues, or to file an issue yourself.
